<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › pci › pci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	PCI Bus Services, see include/linux/pci.h for further explanation.</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,</span>
<span class="cm"> *	David Mosberger-Tang</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright 1997 -- 2000 Martin Mares &lt;mj@ucw.cz&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/pci-aspm.h&gt;</span>
<span class="cp">#include &lt;linux/pm_wakeup.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;asm-generic/pci-bridge.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &quot;pci.h&quot;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pci_power_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;error&quot;</span><span class="p">,</span> <span class="s">&quot;D0&quot;</span><span class="p">,</span> <span class="s">&quot;D1&quot;</span><span class="p">,</span> <span class="s">&quot;D2&quot;</span><span class="p">,</span> <span class="s">&quot;D3hot&quot;</span><span class="p">,</span> <span class="s">&quot;D3cold&quot;</span><span class="p">,</span> <span class="s">&quot;unknown&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_power_names</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">isa_dma_bridge_buggy</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">isa_dma_bridge_buggy</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pci_pci_problems</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_pci_problems</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_pm_d3_delay</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">pci_pme_list_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pci_pme_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">pci_pme_work</span><span class="p">,</span> <span class="n">pci_pme_list_scan</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pci_pme_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PME_TIMEOUT 1000 </span><span class="cm">/* How long between PME checks */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_dev_d3_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">d3_delay</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&lt;</span> <span class="n">pci_pm_d3_delay</span><span class="p">)</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">pci_pm_d3_delay</span><span class="p">;</span>

	<span class="n">msleep</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_DOMAINS</span>
<span class="kt">int</span> <span class="n">pci_domains_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define DEFAULT_CARDBUS_IO_SIZE		(256)</span>
<span class="cp">#define DEFAULT_CARDBUS_MEM_SIZE	(64*1024*1024)</span>
<span class="cm">/* pci=cbmemsize=nnM,cbiosize=nn can override this */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_cardbus_io_size</span> <span class="o">=</span> <span class="n">DEFAULT_CARDBUS_IO_SIZE</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_cardbus_mem_size</span> <span class="o">=</span> <span class="n">DEFAULT_CARDBUS_MEM_SIZE</span><span class="p">;</span>

<span class="cp">#define DEFAULT_HOTPLUG_IO_SIZE		(256)</span>
<span class="cp">#define DEFAULT_HOTPLUG_MEM_SIZE	(2*1024*1024)</span>
<span class="cm">/* pci=hpmemsize=nnM,hpiosize=nn can override this */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_hotplug_io_size</span>  <span class="o">=</span> <span class="n">DEFAULT_HOTPLUG_IO_SIZE</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_hotplug_mem_size</span> <span class="o">=</span> <span class="n">DEFAULT_HOTPLUG_MEM_SIZE</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">pcie_bus_config_types</span> <span class="n">pcie_bus_config</span> <span class="o">=</span> <span class="n">PCIE_BUS_TUNE_OFF</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The default CLS is used if arch didn&#39;t set CLS explicitly and not</span>
<span class="cm"> * all pci devices agree on the same value.  Arch can override either</span>
<span class="cm"> * the dfl or actual value as it sees fit.  Don&#39;t forget this is</span>
<span class="cm"> * measured in 32-bit words, not bytes.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="n">pci_dfl_cache_line_size</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="n">L1_CACHE_BYTES</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">u8</span> <span class="n">pci_cache_line_size</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If we set up a device for bus mastering, we need to check the latency</span>
<span class="cm"> * timer as certain BIOSes forget to set it properly.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcibios_max_latency</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

<span class="cm">/* If set, the PCIe ARI capability will not be used. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pcie_ari_disabled</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * pci_bus_max_busnr - returns maximum PCI bus number of given bus&#39; children</span>
<span class="cm"> * @bus: pointer to PCI bus structure to search</span>
<span class="cm"> *</span>
<span class="cm"> * Given a PCI bus, returns the highest PCI bus number present in the set</span>
<span class="cm"> * including the given PCI bus and its list of child PCI buses.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">pci_bus_max_busnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span><span class="o">*</span> <span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">max</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">pci_bus_max_busnr</span><span class="p">(</span><span class="n">pci_bus_b</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_bus_max_busnr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAS_IOMEM</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">pci_ioremap_bar</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure the BAR is actually a memory resource, not an IO resource</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span>
				     <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_ioremap_bar</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/**</span>
<span class="c"> * pci_max_busnr - returns maximum PCI bus number</span>
<span class="c"> *</span>
<span class="c"> * Returns the highest PCI bus number present in the system global list of</span>
<span class="c"> * PCI buses.</span>
<span class="c"> */</span>
<span class="c">unsigned char __devinit</span>
<span class="c">pci_max_busnr(void)</span>
<span class="c">{</span>
<span class="c">	struct pci_bus *bus = NULL;</span>
<span class="c">	unsigned char max, n;</span>

<span class="c">	max = 0;</span>
<span class="c">	while ((bus = pci_find_next_bus(bus)) != NULL) {</span>
<span class="c">		n = pci_bus_max_busnr(bus);</span>
<span class="c">		if(n &gt; max)</span>
<span class="c">			max = n;</span>
<span class="c">	}</span>
<span class="c">	return max;</span>
<span class="c">}</span>

<span class="cp">#endif  /*  0  */</span>

<span class="cp">#define PCI_FIND_CAP_TTL	48</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_find_next_cap_ttl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ttl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">ttl</span><span class="p">)</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_CAP_LIST_ID</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">PCI_CAP_LIST_NEXT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_find_next_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">PCI_FIND_CAP_TTL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__pci_find_next_cap_ttl</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ttl</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pci_find_next_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_find_next_cap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span>
				   <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_CAP_LIST_NEXT</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_find_next_capability</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_bus_find_cap_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">u8</span> <span class="n">hdr_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">pci_bus_read_config_word</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_CAP_LIST</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hdr_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_HEADER_TYPE_NORMAL</span>:
	<span class="k">case</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span>:
		<span class="k">return</span> <span class="n">PCI_CAPABILITY_LIST</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_HEADER_TYPE_CARDBUS</span>:
		<span class="k">return</span> <span class="n">PCI_CB_CAPABILITY_LIST</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_find_capability - query for devices&#39; capabilities </span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @cap: capability code</span>
<span class="cm"> *</span>
<span class="cm"> * Tell if a device supports a given PCI capability.</span>
<span class="cm"> * Returns the address of the requested capability structure within the</span>
<span class="cm"> * device&#39;s PCI configuration space or 0 in case the device does not</span>
<span class="cm"> * support it.  Possible values for @cap:</span>
<span class="cm"> *</span>
<span class="cm"> *  %PCI_CAP_ID_PM           Power Management </span>
<span class="cm"> *  %PCI_CAP_ID_AGP          Accelerated Graphics Port </span>
<span class="cm"> *  %PCI_CAP_ID_VPD          Vital Product Data </span>
<span class="cm"> *  %PCI_CAP_ID_SLOTID       Slot Identification </span>
<span class="cm"> *  %PCI_CAP_ID_MSI          Message Signalled Interrupts</span>
<span class="cm"> *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap </span>
<span class="cm"> *  %PCI_CAP_ID_PCIX         PCI-X</span>
<span class="cm"> *  %PCI_CAP_ID_EXP          PCI Express</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_find_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_bus_find_cap_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_find_next_cap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_bus_find_capability - query for devices&#39; capabilities </span>
<span class="cm"> * @bus:   the PCI bus to query</span>
<span class="cm"> * @devfn: PCI device to query</span>
<span class="cm"> * @cap:   capability code</span>
<span class="cm"> *</span>
<span class="cm"> * Like pci_find_capability() but works for pci devices that do not have a</span>
<span class="cm"> * pci_dev structure set up yet. </span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the requested capability structure within the</span>
<span class="cm"> * device&#39;s PCI configuration space or 0 in case the device does not</span>
<span class="cm"> * support it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_bus_find_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_type</span><span class="p">;</span>

	<span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_type</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_bus_find_cap_start</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">hdr_type</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_find_next_cap</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_find_ext_capability - Find an extended capability</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @cap: capability code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the requested extended capability structure</span>
<span class="cm"> * within the device&#39;s PCI configuration space or 0 if the device does</span>
<span class="cm"> * not support it.  Possible values for @cap:</span>
<span class="cm"> *</span>
<span class="cm"> *  %PCI_EXT_CAP_ID_ERR		Advanced Error Reporting</span>
<span class="cm"> *  %PCI_EXT_CAP_ID_VC		Virtual Channel</span>
<span class="cm"> *  %PCI_EXT_CAP_ID_DSN		Device Serial Number</span>
<span class="cm"> *  %PCI_EXT_CAP_ID_PWR		Power Budgeting</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_find_ext_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ttl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">;</span>

	<span class="cm">/* minimum 8 bytes per capability */</span>
	<span class="n">ttl</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CFG_SPACE_EXP_SIZE</span> <span class="o">-</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_size</span> <span class="o">&lt;=</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have no capabilities, this is indicated by cap ID,</span>
<span class="cm">	 * cap version and next pointer all being 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">header</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ttl</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_EXT_CAP_ID</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">PCI_EXT_CAP_NEXT</span><span class="p">(</span><span class="n">header</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_find_ext_capability</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_bus_find_ext_capability - find an extended capability</span>
<span class="cm"> * @bus:   the PCI bus to query</span>
<span class="cm"> * @devfn: PCI device to query</span>
<span class="cm"> * @cap:   capability code</span>
<span class="cm"> *</span>
<span class="cm"> * Like pci_find_ext_capability() but works for pci devices that do not have a</span>
<span class="cm"> * pci_dev structure set up yet.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the requested capability structure within the</span>
<span class="cm"> * device&#39;s PCI configuration space or 0 in case the device does not</span>
<span class="cm"> * support it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_bus_find_ext_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ttl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">;</span>

	<span class="cm">/* minimum 8 bytes per capability */</span>
	<span class="n">ttl</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CFG_SPACE_EXP_SIZE</span> <span class="o">-</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">header</span> <span class="o">==</span> <span class="mh">0xffffffff</span> <span class="o">||</span> <span class="n">header</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ttl</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_EXT_CAP_ID</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">PCI_EXT_CAP_NEXT</span><span class="p">(</span><span class="n">header</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">PCI_CFG_SPACE_SIZE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_find_next_ht_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ht_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">PCI_FIND_CAP_TTL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cap</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ht_cap</span> <span class="o">==</span> <span class="n">HT_CAPTYPE_SLAVE</span> <span class="o">||</span> <span class="n">ht_cap</span> <span class="o">==</span> <span class="n">HT_CAPTYPE_HOST</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">HT_3BIT_CAP_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">HT_5BIT_CAP_MASK</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_find_next_cap_ttl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
				      <span class="n">PCI_CAP_ID_HT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ttl</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">ht_cap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_find_next_cap_ttl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span>
					      <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_CAP_LIST_NEXT</span><span class="p">,</span>
					      <span class="n">PCI_CAP_ID_HT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ttl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * pci_find_next_ht_capability - query a device&#39;s Hypertransport capabilities</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @pos: Position from which to continue searching</span>
<span class="cm"> * @ht_cap: Hypertransport capability code</span>
<span class="cm"> *</span>
<span class="cm"> * To be used in conjunction with pci_find_ht_capability() to search for</span>
<span class="cm"> * all capabilities matching @ht_cap. @pos should always be a value returned</span>
<span class="cm"> * from pci_find_ht_capability().</span>
<span class="cm"> *</span>
<span class="cm"> * NB. To be 100% safe against broken PCI devices, the caller should take</span>
<span class="cm"> * steps to avoid an infinite loop.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_find_next_ht_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ht_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_find_next_ht_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_CAP_LIST_NEXT</span><span class="p">,</span> <span class="n">ht_cap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_find_next_ht_capability</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_find_ht_capability - query a device&#39;s Hypertransport capabilities</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @ht_cap: Hypertransport capability code</span>
<span class="cm"> *</span>
<span class="cm"> * Tell if a device supports a given Hypertransport capability.</span>
<span class="cm"> * Returns an address within the device&#39;s PCI configuration space</span>
<span class="cm"> * or 0 in case the device does not support the request capability.</span>
<span class="cm"> * The address points to the PCI capability, of type PCI_CAP_ID_HT,</span>
<span class="cm"> * which has a Hypertransport capability matching @ht_cap.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_find_ht_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ht_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_bus_find_cap_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">__pci_find_next_ht_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ht_cap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_find_ht_capability</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_find_parent_resource - return resource region of parent bus of given region</span>
<span class="cm"> * @dev: PCI device structure contains resources to be searched</span>
<span class="cm"> * @res: child resource record for which parent is sought</span>
<span class="cm"> *</span>
<span class="cm"> *  For given resource region of given device, return the resource</span>
<span class="cm"> *  region of parent bus the given region is contained in or where</span>
<span class="cm"> *  it should be allocated from.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span>
<span class="nf">pci_find_parent_resource</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">best</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="n">pci_bus_for_each_resource</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* Not contained */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IORESOURCE_IO</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* Wrong type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_PREFETCH</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>	<span class="cm">/* Exact match */</span>
		<span class="cm">/* We can&#39;t insert a non-prefetch resource inside a prefetchable parent .. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_PREFETCH</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* .. but we can put a prefetchable resource inside a non-prefetchable one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="p">)</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">best</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)</span>
<span class="cm"> * @dev: PCI device to have its BARs restored</span>
<span class="cm"> *</span>
<span class="cm"> * Restore the BAR values for a given device, so as to make it</span>
<span class="cm"> * accessible by its driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pci_restore_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pci_update_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_platform_pm_ops</span> <span class="o">*</span><span class="n">pci_platform_pm</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">pci_set_platform_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_platform_pm_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">is_manageable</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_state</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">choose_state</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sleep_wake</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">can_wakeup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pci_platform_pm</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">platform_pci_power_manageable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span> <span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">is_manageable</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">platform_pci_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                                                <span class="n">pci_power_t</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span> <span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">set_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pci_power_t</span> <span class="nf">platform_pci_choose_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span>
			<span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">choose_state</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="n">PCI_POWER_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">platform_pci_can_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span> <span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">can_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">platform_pci_sleep_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span>
			<span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">sleep_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">enable</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">platform_pci_run_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_platform_pm</span> <span class="o">?</span>
			<span class="n">pci_platform_pm</span><span class="o">-&gt;</span><span class="n">run_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">enable</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_raw_set_power_state - Use PCI PM registers to set the power state of</span>
<span class="cm"> *                           given PCI device</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUE:</span>
<span class="cm"> * -EINVAL if the requested state is invalid.</span>
<span class="cm"> * -EIO if device does not support PCI PM or its PM capabilities register has a</span>
<span class="cm"> * wrong version, or device doesn&#39;t support the requested state.</span>
<span class="cm"> * 0 if device already is in the requested state.</span>
<span class="cm"> * 0 if device&#39;s power state has been successfully changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_raw_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_restore</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Check if we&#39;re already there */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PCI_D0</span> <span class="o">||</span> <span class="n">state</span> <span class="o">&gt;</span> <span class="n">PCI_D3hot</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Validate current state:</span>
<span class="cm">	 * Can enter D0 from any state, but if we can only go deeper </span>
<span class="cm">	 * to sleep if we&#39;re already in a low power state</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PCI_D0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">&lt;=</span> <span class="n">PCI_D3cold</span>
	    <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">&gt;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid power transition &quot;</span>
			<span class="s">&quot;(from state %d to %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if this device supports the desired state */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">d1_support</span><span class="p">)</span>
	   <span class="o">||</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">d2_support</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>

	<span class="cm">/* If we&#39;re (effectively) in D3, force entire word to 0.</span>
<span class="cm">	 * This doesn&#39;t affect PME_Status, disables PME_En, and</span>
<span class="cm">	 * sets PowerState to 0.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_D0</span>:
	<span class="k">case</span> <span class="n">PCI_D1</span>:
	<span class="k">case</span> <span class="n">PCI_D2</span>:
		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
		<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">state</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_D3hot</span>:
	<span class="k">case</span> <span class="n">PCI_D3cold</span>:
	<span class="k">case</span> <span class="n">PCI_UNKNOWN</span>: <span class="cm">/* Boot-up */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_D3hot</span>
		 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_NO_SOFT_RESET</span><span class="p">))</span>
			<span class="n">need_restore</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* Fall-through: force to D0 */</span>
	<span class="nl">default:</span>
		<span class="n">pmcsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enter specified state */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">);</span>

	<span class="cm">/* Mandatory power management transition delays */</span>
	<span class="cm">/* see PCI PM 1.1 5.6.1 table 18 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D3hot</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">PCI_D3hot</span><span class="p">)</span>
		<span class="n">pci_dev_d3_sleep</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D2</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">PCI_D2</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">PCI_PM_D2_DELAY</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Refused to change power state, &quot;</span>
			<span class="s">&quot;currently in D%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">);</span>

	<span class="cm">/* According to section 5.4.1 of the &quot;PCI BUS POWER MANAGEMENT</span>
<span class="cm">	 * INTERFACE SPECIFICATION, REV. 1.2&quot;, a device transitioning</span>
<span class="cm">	 * from D3hot to D0 _may_ perform an internal reset, thereby</span>
<span class="cm">	 * going to &quot;D0 Uninitialized&quot; rather than &quot;D0 Initialized&quot;.</span>
<span class="cm">	 * For example, at least some versions of the 3c905B and the</span>
<span class="cm">	 * 3c556B exhibit this behaviour.</span>
<span class="cm">	 *</span>
<span class="cm">	 * At least some laptop BIOSen (e.g. the Thinkpad T21) leave</span>
<span class="cm">	 * devices in a D3hot state at boot.  Consequently, we need to</span>
<span class="cm">	 * restore at least the BARs so that the device will be</span>
<span class="cm">	 * accessible to its driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_restore</span><span class="p">)</span>
		<span class="n">pci_restore_bars</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span>
		<span class="n">pcie_aspm_pm_state_change</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_update_current_state - Read PCI power state of given device from its</span>
<span class="cm"> *                            PCI PM registers and cache it</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: State to cache in case the device doesn&#39;t have the PM capability</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_update_current_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_platform_power_transition - Use platform to change device power state</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: State to put the device into.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_platform_power_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">platform_pci_power_manageable</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">platform_pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">pci_update_current_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="cm">/* Fall back to PCI_D0 if native PM is not supported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="cm">/* Fall back to PCI_D0 if native PM is not supported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __pci_start_power_transition - Start power transition of a PCI device</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: State to put the device into.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pci_start_power_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D0</span><span class="p">)</span>
		<span class="n">pci_platform_power_transition</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __pci_complete_power_transition - Complete power transition of a PCI device</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: State to put the device into.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should not be called directly by device drivers.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pci_complete_power_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PCI_D0</span> <span class="o">?</span>
			<span class="n">pci_platform_power_transition</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__pci_complete_power_transition</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_power_state - Set the power state of a PCI device</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.</span>
<span class="cm"> *</span>
<span class="cm"> * Transition a device to a new power state, using the platform firmware and/or</span>
<span class="cm"> * the device&#39;s PCI PM registers.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUE:</span>
<span class="cm"> * -EINVAL if the requested state is invalid.</span>
<span class="cm"> * -EIO if device does not support PCI PM or its PM capabilities register has a</span>
<span class="cm"> * wrong version, or device doesn&#39;t support the requested state.</span>
<span class="cm"> * 0 if device already is in the requested state.</span>
<span class="cm"> * 0 if device&#39;s power state has been successfully changed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* bound the state we&#39;re entering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">PCI_D3hot</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">PCI_D3hot</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PCI_D0</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D1</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pci_no_d1d2</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the device or the parent bridge do not support PCI PM,</span>
<span class="cm">		 * ignore the request if we&#39;re doing anything other than putting</span>
<span class="cm">		 * it into D0 (which would only happen on boot).</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__pci_start_power_transition</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="cm">/* This device is quirked not to be put into D3, so</span>
<span class="cm">	   don&#39;t put it in D3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PCI_D3hot</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">PCI_DEV_FLAGS_NO_D3</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_raw_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__pci_complete_power_transition</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * When aspm_policy is &quot;powersave&quot; this call ensures</span>
<span class="cm">	 * that ASPM is configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span>
		<span class="n">pcie_aspm_powersave_config_link</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_choose_state - Choose the power state of a PCI device</span>
<span class="cm"> * @dev: PCI device to be suspended</span>
<span class="cm"> * @state: target sleep state for the whole system. This is the value</span>
<span class="cm"> *	that is passed to suspend() function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns PCI power state suitable for given device and given system</span>
<span class="cm"> * message.</span>
<span class="cm"> */</span>

<span class="n">pci_power_t</span> <span class="nf">pci_choose_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_power_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PCI_D0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_pci_choose_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">PCI_POWER_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PM_EVENT_ON</span>:
		<span class="k">return</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PM_EVENT_FREEZE</span>:
	<span class="k">case</span> <span class="n">PM_EVENT_PRETHAW</span>:
		<span class="cm">/* REVISIT both freeze and pre-thaw &quot;should&quot; use D0 */</span>
	<span class="k">case</span> <span class="n">PM_EVENT_SUSPEND</span>:
	<span class="k">case</span> <span class="n">PM_EVENT_HIBERNATE</span>:
		<span class="k">return</span> <span class="n">PCI_D3hot</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unrecognized suspend event %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">PCI_D0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_choose_state</span><span class="p">);</span>

<span class="cp">#define PCI_EXP_SAVE_REGS	7</span>

<span class="cp">#define pcie_cap_has_devctl(type, flags)	1</span>
<span class="cp">#define pcie_cap_has_lnkctl(type, flags)		\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1 ||	\</span>
<span class="cp">		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\</span>
<span class="cp">		  type == PCI_EXP_TYPE_ENDPOINT ||	\</span>
<span class="cp">		  type == PCI_EXP_TYPE_LEG_END))</span>
<span class="cp">#define pcie_cap_has_sltctl(type, flags)		\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1 ||	\</span>
<span class="cp">		 ((type == PCI_EXP_TYPE_ROOT_PORT) ||	\</span>
<span class="cp">		  (type == PCI_EXP_TYPE_DOWNSTREAM &amp;&amp;	\</span>
<span class="cp">		   (flags &amp; PCI_EXP_FLAGS_SLOT))))</span>
<span class="cp">#define pcie_cap_has_rtctl(type, flags)			\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1 ||	\</span>
<span class="cp">		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\</span>
<span class="cp">		  type == PCI_EXP_TYPE_RC_EC))</span>
<span class="cp">#define pcie_cap_has_devctl2(type, flags)		\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1)</span>
<span class="cp">#define pcie_cap_has_lnkctl2(type, flags)		\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1)</span>
<span class="cp">#define pcie_cap_has_sltctl2(type, flags)		\</span>
<span class="cp">		((flags &amp; PCI_EXP_FLAGS_VERS) &gt; 1)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="nf">pci_find_saved_cap</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="kt">char</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">saved_cap_space</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">cap_nr</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_save_pcie_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">save_state</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">save_state</span> <span class="o">=</span> <span class="n">pci_find_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;buffer not found in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_devctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_lnkctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_sltctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_SLTCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_rtctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_RTCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_devctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_lnkctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_sltctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_SLTCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_restore_pcie_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">save_state</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">save_state</span> <span class="o">=</span> <span class="n">pci_find_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_state</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_devctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_lnkctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_sltctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_SLTCTL</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_rtctl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_RTCTL</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_devctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_lnkctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL2</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_cap_has_sltctl2</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_SLTCTL2</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_save_pcix_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">save_state</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">save_state</span> <span class="o">=</span> <span class="n">pci_find_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;buffer not found in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_X_CMD</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_restore_pcix_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">save_state</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>

	<span class="n">save_state</span> <span class="o">=</span> <span class="n">pci_find_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_state</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_X_CMD</span><span class="p">,</span> <span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pci_save_state - save the PCI configuration space of a device before suspending</span>
<span class="cm"> * @dev: - PCI device that we&#39;re dealing with</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pci_save_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* XXX: 100% dword access ok here? */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_config_space</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">pci_save_pcie_state</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">pci_save_pcix_state</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_restore_config_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">saved_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">saved_val</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;restoring config space at offset &quot;</span>
			<span class="s">&quot;%#x (was %#x, writing %#x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">saved_val</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">saved_val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">saved_val</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_restore_config_space_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">;</span> <span class="n">index</span><span class="o">--</span><span class="p">)</span>
		<span class="n">pci_restore_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">index</span><span class="p">,</span>
					 <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">saved_config_space</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					 <span class="n">retry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_restore_config_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_NORMAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_restore_config_space_range</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Restore BARs before the command register. */</span>
		<span class="n">pci_restore_config_space_range</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">pci_restore_config_space_range</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_restore_config_space_range</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/** </span>
<span class="cm"> * pci_restore_state - Restore the saved state of a PCI device</span>
<span class="cm"> * @dev: - PCI device that we&#39;re dealing with</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_restore_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* PCI Express register must be restored first */</span>
	<span class="n">pci_restore_pcie_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_restore_ats_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_restore_config_space</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_restore_pcix_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_restore_msi_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_restore_iov_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">config_space</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="n">cap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pci_store_saved_state - Allocate and return an opaque struct containing</span>
<span class="cm"> *			   the device saved state.</span>
<span class="cm"> * @dev: PCI device that we&#39;re dealing with</span>
<span class="cm"> *</span>
<span class="cm"> * Rerturn NULL if no state or error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="nf">pci_store_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_cap_space</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_config_space</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">));</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">;</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_cap_space</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cap</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Empty cap_save terminates list */</span>

	<span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_store_saved_state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_load_saved_state - Reload the provided save state into struct pci_dev.</span>
<span class="cm"> * @dev: PCI device that we&#39;re dealing with</span>
<span class="cm"> * @state: Saved state returned from pci_store_saved_state()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_load_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_config_space</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">));</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">pci_find_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span> <span class="o">||</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cap</span> <span class="o">+</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_cap_saved_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_load_saved_state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_load_and_free_saved_state - Reload the save state pointed to by state,</span>
<span class="cm"> *				   and free the memory allocated for it.</span>
<span class="cm"> * @dev: PCI device that we&#39;re dealing with</span>
<span class="cm"> * @state: Pointer to saved state returned from pci_store_saved_state()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_load_and_free_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">**</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pci_load_saved_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">);</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_load_and_free_saved_state</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_pci_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bars</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pcibios_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_enable</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_reenable_device - Resume abandoned device</span>
<span class="cm"> * @dev: PCI device to be resumed</span>
<span class="cm"> *</span>
<span class="cm"> *  Note this function is a backend of pci_default_resume and is not supposed</span>
<span class="cm"> *  to be called by normal code, write proper resume handler and use it instead.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_reenable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">do_pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_enable_device_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="n">resource_size_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bars</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Power state could be unknown at this point, either due to a fresh</span>
<span class="cm">	 * boot or a device removal call.  So get the current power state</span>
<span class="cm">	 * so that things like MSI message writing will behave as expected</span>
<span class="cm">	 * (e.g. if the device really is in D0 at enable time).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">enable_cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* already enabled */</span>

	<span class="cm">/* only skip sriov related */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PCI_ROM_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span>
			<span class="n">bars</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span>
			<span class="n">bars</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">enable_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_device_io - Initialize a device for use with IO space</span>
<span class="cm"> * @dev: PCI device to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize device before it&#39;s used by a driver. Ask low-level code</span>
<span class="cm"> *  to enable I/O resources. Wake up the device if it was suspended.</span>
<span class="cm"> *  Beware, this function can fail.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_enable_device_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_enable_device_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_IO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_device_mem - Initialize a device for use with Memory space</span>
<span class="cm"> * @dev: PCI device to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize device before it&#39;s used by a driver. Ask low-level code</span>
<span class="cm"> *  to enable Memory resources. Wake up the device if it was suspended.</span>
<span class="cm"> *  Beware, this function can fail.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_enable_device_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_enable_device_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_device - Initialize device before it&#39;s used by a driver.</span>
<span class="cm"> * @dev: PCI device to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize device before it&#39;s used by a driver. Ask low-level code</span>
<span class="cm"> *  to enable I/O and memory. Wake up the device if it was suspended.</span>
<span class="cm"> *  Beware, this function can fail.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note we don&#39;t actually enable the device many times if we call</span>
<span class="cm"> *  this function repeatedly (we just increment the count).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_enable_device_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_IO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Managed PCI resources.  This manages device on/off, intx/msi/msix</span>
<span class="cm"> * on/off and BAR regions.  pci_dev itself records msi/msix status, so</span>
<span class="cm"> * there&#39;s no need to track it separately.  pci_devres is initialized</span>
<span class="cm"> * when a device is enabled using managed PCI device enable interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_devres</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pinned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig_intx</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">restore_intx</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">region_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcim_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gendev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gendev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">msi_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">region_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">pci_release_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">restore_intx</span><span class="p">)</span>
		<span class="n">pci_intx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">orig_intx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pinned</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span> <span class="nf">get_pci_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">,</span> <span class="o">*</span><span class="n">new_dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">devres_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcim_release</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dr</span><span class="p">;</span>

	<span class="n">new_dr</span> <span class="o">=</span> <span class="n">devres_alloc</span><span class="p">(</span><span class="n">pcim_release</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_dr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">devres_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">new_dr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span> <span class="nf">find_pci_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_managed</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">devres_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcim_release</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcim_enable_device - Managed pci_enable_device()</span>
<span class="cm"> * @pdev: PCI device to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> * Managed pci_enable_device().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcim_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">get_pci_dr</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_managed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcim_pin_device - Pin managed PCI device</span>
<span class="cm"> * @pdev: PCI device to pin</span>
<span class="cm"> *</span>
<span class="cm"> * Pin managed PCI device @pdev.  Pinned device won&#39;t be disabled on</span>
<span class="cm"> * driver detach.  @pdev must have been enabled with</span>
<span class="cm"> * pcim_enable_device().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pcim_pin_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_pci_dr</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span> <span class="o">||</span> <span class="o">!</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcibios_disable_device - disable arch specific PCI resources for device dev</span>
<span class="cm"> * @dev: the PCI device to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Disables architecture specific PCI resources for the device. This</span>
<span class="cm"> * is the default implementation. Architecture implementations can</span>
<span class="cm"> * override this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">pcibios_disable_device</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_pci_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pci_command</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_command</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_command</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_MASTER</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">pci_command</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pcibios_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_disable_enabled_device - Disable device without updating enable_cnt</span>
<span class="cm"> * @dev: PCI device to disable</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This function is a backend of PCI power management routines and is</span>
<span class="cm"> * not supposed to be called drivers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_disable_enabled_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">do_pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_disable_device - Disable PCI device after use</span>
<span class="cm"> * @dev: PCI device to be disabled</span>
<span class="cm"> *</span>
<span class="cm"> * Signal to the system that the PCI device is not in use by the system</span>
<span class="cm"> * anymore.  This only involves disabling PCI bus-mastering, if active.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we don&#39;t actually disable the device until all callers of</span>
<span class="cm"> * pci_enable_device() have called pci_disable_device().</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pci_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_pci_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_sub_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">enable_cnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">do_pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcibios_set_pcie_reset_state - set reset state for device dev</span>
<span class="cm"> * @dev: the PCIe device reset</span>
<span class="cm"> * @state: Reset state to enter into</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the PCIe reset state for the device. This is the default</span>
<span class="cm"> * implementation. Architecture implementations can override this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">pcibios_set_pcie_reset_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							<span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_pcie_reset_state - set reset state for device dev</span>
<span class="cm"> * @dev: the PCIe device reset</span>
<span class="cm"> * @state: Reset state to enter into</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the PCI reset state for the device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_set_pcie_reset_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pcibios_set_pcie_reset_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_check_pme_status - Check if given device has generated PME.</span>
<span class="cm"> * @dev: Device to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Check the PME status of the device and if set, clear it and clear PME enable</span>
<span class="cm"> * (if set).  Return &#39;true&#39; if PME status and PME enable were both set or</span>
<span class="cm"> * &#39;false&#39; otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_check_pme_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pmcsr_pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pmcsr_pos</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pmcsr_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Clear PME status. */</span>
	<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable PME to avoid interrupt flood. */</span>
		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pmcsr_pos</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.</span>
<span class="cm"> * @dev: Device to handle.</span>
<span class="cm"> * @pme_poll_reset: Whether or not to reset the device&#39;s pme_poll flag.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if @dev has generated PME and queue a resume request for it in that</span>
<span class="cm"> * case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pme_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pme_poll_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pme_poll_reset</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_poll</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_check_pme_status</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_wakeup_event</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_request_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pme_wakeup_bus - Walk given bus and wake up devices on it, if necessary.</span>
<span class="cm"> * @bus: Top bus of the subtree to walk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_pme_wakeup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span>
		<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">pci_pme_wakeup</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pme_capable - check the capability of PCI device to generate PME#</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @state: PCI state from which device will issue PME#.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_pme_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pme_list_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_pme_device</span> <span class="o">*</span><span class="n">pme_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">pme_dev</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_poll</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_pme_wakeup</span><span class="p">(</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">pme_dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">))</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_work</span><span class="p">,</span>
					      <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PME_TIMEOUT</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pme_active - enable or disable PCI device&#39;s PME# function</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> * @enable: &#39;true&#39; to enable PME# generation; &#39;false&#39; to disable it.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must verify that the device is capable of generating PME# before</span>
<span class="cm"> * calling this function with @enable equal to &#39;true&#39;.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_pme_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
	<span class="cm">/* Clear PME_Status by writing 1 to it and enable PME# */</span>
	<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span> <span class="o">|</span> <span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">;</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">);</span>

	<span class="cm">/* PCI (as opposed to PCIe) PME requires that the device have</span>
<span class="cm">	   its PME# line hooked up correctly. Not all hardware vendors</span>
<span class="cm">	   do this, so the PME never gets delivered and the device</span>
<span class="cm">	   remains asleep. The easiest way around this is to</span>
<span class="cm">	   periodically walk the list of suspended devices and check</span>
<span class="cm">	   whether any have their PME flag set. The assumption is that</span>
<span class="cm">	   we&#39;ll wake up often enough anyway that this won&#39;t be a huge</span>
<span class="cm">	   hit, and the power savings from the devices will still be a</span>
<span class="cm">	   win. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_poll</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_pme_device</span> <span class="o">*</span><span class="n">pme_dev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pme_dev</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_pme_device</span><span class="p">),</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pme_dev</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">))</span>
				<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_work</span><span class="p">,</span>
						      <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PME_TIMEOUT</span><span class="p">));</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pme_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_pme_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pme_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">pme_dev</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_pme_list_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PME# %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __pci_enable_wake - enable PCI device as wakeup event source</span>
<span class="cm"> * @dev: PCI device affected</span>
<span class="cm"> * @state: PCI state from which device will issue wakeup events</span>
<span class="cm"> * @runtime: True if the events are to be generated at run time</span>
<span class="cm"> * @enable: True to enable event generation; false to disable</span>
<span class="cm"> *</span>
<span class="cm"> * This enables the device as a wakeup event source, or disables it.</span>
<span class="cm"> * When such events involves platform-specific hooks, those hooks are</span>
<span class="cm"> * called automatically by this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices with legacy power management (no standard PCI PM capabilities)</span>
<span class="cm"> * always require such platform hooks.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUE:</span>
<span class="cm"> * 0 is returned on success</span>
<span class="cm"> * -EINVAL is returned if device is not supposed to wake up the system</span>
<span class="cm"> * Error code depending on the platform is returned if both the platform and</span>
<span class="cm"> * the native mechanism fail to enable the generation of wake-up events</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pci_enable_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">runtime</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t do the same thing twice in a row for one device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">enable</span> <span class="o">==</span> <span class="o">!!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wakeup_prepared</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * According to &quot;PCI System Architecture&quot; 4th ed. by Tom Shanley &amp; Don</span>
<span class="cm">	 * Anderson we should be doing PME# wake enable followed by ACPI wake</span>
<span class="cm">	 * enable.  To disable wake-up we call the platform first, for symmetry.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_pme_capable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
			<span class="n">pci_pme_active</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">runtime</span> <span class="o">?</span> <span class="n">platform_pci_run_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">:</span>
					<span class="n">platform_pci_sleep_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wakeup_prepared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="p">)</span>
			<span class="n">platform_pci_run_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">platform_pci_sleep_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">pci_pme_active</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wakeup_prepared</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__pci_enable_wake</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold</span>
<span class="cm"> * @dev: PCI device to prepare</span>
<span class="cm"> * @enable: True to enable wake-up event generation; false to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Many drivers want the device to wake up the system from D3_hot or D3_cold</span>
<span class="cm"> * and this function allows them to set that up cleanly - pci_enable_wake()</span>
<span class="cm"> * should not be called twice in a row to enable wake-up due to PCI PM vs ACPI</span>
<span class="cm"> * ordering constraints.</span>
<span class="cm"> *</span>
<span class="cm"> * This function only returns error code if the device is not capable of</span>
<span class="cm"> * generating PME# from both D3_hot and D3_cold, and the platform is unable to</span>
<span class="cm"> * enable wake-up power for it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_wake_from_d3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_pme_capable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="n">enable</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_target_state - find an appropriate low power state for a given PCI dev</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Use underlying platform code to find a supported low power state for @dev.</span>
<span class="cm"> * If the platform can&#39;t manage @dev, return the deepest state from which it</span>
<span class="cm"> * can generate wake events, based on any available PME info.</span>
<span class="cm"> */</span>
<span class="n">pci_power_t</span> <span class="nf">pci_target_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_power_t</span> <span class="n">target_state</span> <span class="o">=</span> <span class="n">PCI_D3hot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">platform_pci_power_manageable</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Call the platform to choose the target state of the device</span>
<span class="cm">		 * and enable wake-up from this state if supported.</span>
<span class="cm">		 */</span>
		<span class="n">pci_power_t</span> <span class="n">state</span> <span class="o">=</span> <span class="n">platform_pci_choose_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PCI_POWER_ERROR</span>:
		<span class="k">case</span> <span class="n">PCI_UNKNOWN</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PCI_D1</span>:
		<span class="k">case</span> <span class="n">PCI_D2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_no_d1d2</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">target_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target_state</span> <span class="o">=</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the deepest state from which the device can generate</span>
<span class="cm">		 * wake-up events, make it the target state and enable device</span>
<span class="cm">		 * to generate PME#.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">target_state</span>
			      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">target_state</span><span class="p">)))</span>
				<span class="n">target_state</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">target_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_prepare_to_sleep - prepare PCI device for system-wide transition into a sleep state</span>
<span class="cm"> * @dev: Device to handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Choose the power state appropriate for the device depending on whether</span>
<span class="cm"> * it can wake up the system and/or is power manageable by the platform</span>
<span class="cm"> * (PCI_D3hot is the default) and put the device into that state.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_prepare_to_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_power_t</span> <span class="n">target_state</span> <span class="o">=</span> <span class="n">pci_target_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_state</span> <span class="o">==</span> <span class="n">PCI_POWER_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Some devices mustn&#39;t be in D3 during system sleep */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_state</span> <span class="o">==</span> <span class="n">PCI_D3hot</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">PCI_DEV_FLAGS_NO_D3_DURING_SLEEP</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">,</span> <span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_back_from_sleep - turn PCI device on during system-wide transition into working state</span>
<span class="cm"> * @dev: Device to handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Disable device&#39;s system wake-up capability and put it into D0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_back_from_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_finish_runtime_suspend - Carry out PCI-specific part of runtime suspend.</span>
<span class="cm"> * @dev: PCI device being suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare @dev to generate wake-up events at run time and put it into a low</span>
<span class="cm"> * power state.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_finish_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_power_t</span> <span class="n">target_state</span> <span class="o">=</span> <span class="n">pci_target_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_state</span> <span class="o">==</span> <span class="n">PCI_POWER_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">__pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">pci_dev_run_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">__pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target_state</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_dev_run_wake - Check if device can generate run-time wake-up events.</span>
<span class="cm"> * @dev: Device to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the device itself is cabable of generating wake-up events</span>
<span class="cm"> * (through the platform or using the native PCIe PME) or if the device supports</span>
<span class="cm"> * PME and one of its upstream bridges can generate wake-up events.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_dev_run_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_run_wake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">device_run_wake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We have reached the root bus. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">device_run_wake</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_dev_run_wake</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pm_init - Initialize PM functions of given PCI device</span>
<span class="cm"> * @dev: PCI device to handle.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_pm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pmc</span><span class="p">;</span>

	<span class="n">pm_runtime_forbid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_enable_async_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wakeup_prepared</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* find PCI PM capability in list */</span>
	<span class="n">pm</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Check device&#39;s ability to generate PME# */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm</span> <span class="o">+</span> <span class="n">PCI_PM_PMC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_VER_MASK</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported PM cap regs version (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_VER_MASK</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">=</span> <span class="n">pm</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d3_delay</span> <span class="o">=</span> <span class="n">PCI_PM_D3_WAIT</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d1_support</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d2_support</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_no_d1d2</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_D1</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d1_support</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_D2</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d2_support</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">d1_support</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">d2_support</span><span class="p">)</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;supports%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">d1_support</span> <span class="o">?</span> <span class="s">&quot; D1&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">d2_support</span> <span class="o">?</span> <span class="s">&quot; D2&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pmc</span> <span class="o">&amp;=</span> <span class="n">PCI_PM_CAP_PME_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;PME# supported from%s%s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_PME_D0</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; D0&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_PME_D1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; D1&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_PME_D2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; D2&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_PME_D3</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; D3hot&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">pmc</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CAP_PME_D3cold</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; D3cold&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span> <span class="o">=</span> <span class="n">pmc</span> <span class="o">&gt;&gt;</span> <span class="n">PCI_PM_CAP_PME_SHIFT</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make device&#39;s PM flags reflect the wake-up capability, but</span>
<span class="cm">		 * let the user space enable it to wake up the system as needed.</span>
<span class="cm">		 */</span>
		<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="cm">/* Disable the PME# generation functionality */</span>
		<span class="n">pci_pme_active</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pme_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_pci_wakeup_init - init platform wakeup if present</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices don&#39;t have PCI PM caps but can still generate wakeup</span>
<span class="cm"> * events through platform methods (like ACPI events).  If @dev supports</span>
<span class="cm"> * platform wakeup events, set the device flag to indicate as much.  This</span>
<span class="cm"> * may be redundant if the device also supports PCI PM caps, but double</span>
<span class="cm"> * initialization should be safe in that case.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">platform_pci_wakeup_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">platform_pci_can_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">platform_pci_sleep_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_add_saved_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">new_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_cap</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">saved_cap_space</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_add_save_buffer - allocate buffer for saving given capability registers</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @cap: the capability to allocate the buffer for</span>
<span class="cm"> * @size: requested size of the buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_add_cap_save_buffer</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">save_state</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">save_state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">save_state</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">cap_nr</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">save_state</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">pci_add_saved_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">save_state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_allocate_cap_save_buffers - allocate buffers for saving capabilities</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_allocate_cap_save_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_add_cap_save_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">,</span>
					<span class="n">PCI_EXP_SAVE_REGS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;unable to preallocate PCI Express save buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_add_cap_save_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;unable to preallocate PCI-X save buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pci_free_cap_save_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">saved_cap_space</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_ari - enable ARI forwarding if hardware support it</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_enable_ari</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_ari_disabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ARI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bridge</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bridge</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">bridge</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ARI is a PCIe v2 feature */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_FLAGS_VERS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCAP2_ARI</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL2_ARI</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="n">bridge</span><span class="o">-&gt;</span><span class="n">ari_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_ido - enable ID-based ordering on a device</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @type: which types of IDO to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enable ID-based ordering on @dev.  @type can contain the bits</span>
<span class="cm"> * %PCI_EXP_IDO_REQUEST and/or %PCI_EXP_IDO_COMPLETION to indicate</span>
<span class="cm"> * which types of transactions are allowed to be re-ordered.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_enable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_IDO_REQUEST</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_IDO_REQ_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_IDO_COMPLETION</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_IDO_CMP_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_ido</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_disable_ido - disable ID-based ordering on a device</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @type: which types of IDO to disable</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_disable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_IDO_REQUEST</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_IDO_REQ_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_IDO_COMPLETION</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_IDO_CMP_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_disable_ido</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_obff - enable optimized buffer flush/fill</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @type: type of signaling to use</span>
<span class="cm"> *</span>
<span class="cm"> * Try to enable @type OBFF signaling on @dev.  It will try using WAKE#</span>
<span class="cm"> * signaling if possible, falling back to message signaling only if</span>
<span class="cm"> * WAKE# isn&#39;t supported.  @type should indicate whether the PCIe link</span>
<span class="cm"> * be brought out of L0s or L1 to send the message.  It should be either</span>
<span class="cm"> * %PCI_EXP_OBFF_SIGNAL_ALWAYS or %PCI_OBFF_SIGNAL_L0.</span>
<span class="cm"> *</span>
<span class="cm"> * If your device can benefit from receiving all messages, even at the</span>
<span class="cm"> * power cost of bringing the link back up from a low power state, use</span>
<span class="cm"> * %PCI_EXP_OBFF_SIGNAL_ALWAYS.  Otherwise, use %PCI_OBFF_SIGNAL_L0 (the</span>
<span class="cm"> * preferred type).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Zero on success, appropriate error number on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_enable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pci_obff_signal_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_OBFF_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span> <span class="cm">/* no OBFF support at all */</span>

	<span class="cm">/* Make sure the topology supports OBFF as well */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_obff</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_OBFF_WAKE</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_OBFF_WAKE_EN</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PCI_EXP_OBFF_SIGNAL_L0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_OBFF_WAKE_EN</span><span class="p">))</span>
				<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_OBFF_MSGA_EN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PCI_EXP_OBFF_SIGNAL_ALWAYS</span>:
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_OBFF_WAKE_EN</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_OBFF_MSGB_EN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bad OBFF signal type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_obff</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_disable_obff - disable optimized buffer flush/fill</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Disable OBFF on @dev.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_disable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_OBFF_WAKE_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_disable_obff</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_ltr_supported - check whether a device supports LTR</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * True if @dev supports latency tolerance reporting, false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_ltr_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCAP2_LTR</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_ltr_supported</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_ltr - enable latency tolerance reporting</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Enable LTR on @dev if possible, which means enabling it first on</span>
<span class="cm"> * upstream ports.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Zero on success, errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_enable_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_ltr_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="cm">/* Only primary function can enable/disable LTR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Enable upstream ports first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_ltr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_EXP_LTR_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_ltr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_disable_ltr - disable latency tolerance reporting</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_disable_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_ltr_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Only primary function can enable/disable LTR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_LTR_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL2</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_disable_ltr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_ltr_scale</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1023</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">scale</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_ltr - set LTR latency values</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @snoop_lat_ns: snoop latency in nanoseconds</span>
<span class="cm"> * @nosnoop_lat_ns: nosnoop latency in nanoseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Figure out the scale and set the LTR values accordingly.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_set_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">snoop_lat_ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nosnoop_lat_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">snoop_scale</span><span class="p">,</span> <span class="n">nosnoop_scale</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_ltr_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">snoop_scale</span> <span class="o">=</span> <span class="n">__pci_ltr_scale</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snoop_lat_ns</span><span class="p">);</span>
	<span class="n">nosnoop_scale</span> <span class="o">=</span> <span class="n">__pci_ltr_scale</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nosnoop_lat_ns</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snoop_lat_ns</span> <span class="o">&gt;</span> <span class="n">PCI_LTR_VALUE_MASK</span> <span class="o">||</span>
	    <span class="n">nosnoop_lat_ns</span> <span class="o">&gt;</span> <span class="n">PCI_LTR_VALUE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">snoop_scale</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PCI_LTR_SCALE_MASK</span> <span class="o">&gt;&gt;</span> <span class="n">PCI_LTR_SCALE_SHIFT</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nosnoop_scale</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PCI_LTR_SCALE_MASK</span> <span class="o">&gt;&gt;</span> <span class="n">PCI_LTR_SCALE_SHIFT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_LTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">snoop_scale</span> <span class="o">&lt;&lt;</span> <span class="n">PCI_LTR_SCALE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">snoop_lat_ns</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_LTR_MAX_SNOOP_LAT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">nosnoop_scale</span> <span class="o">&lt;&lt;</span> <span class="n">PCI_LTR_SCALE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">nosnoop_lat_ns</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_LTR_MAX_NOSNOOP_LAT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_ltr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pci_acs_enable</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * pci_request_acs - ask for ACS to be enabled if supported</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_request_acs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_acs_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_enable_acs - enable ACS if hardware support it</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_enable_acs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_acs_enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ACS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ACS_CAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ACS_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="cm">/* Source Validation */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_ACS_SV</span><span class="p">);</span>

	<span class="cm">/* P2P Request Redirect */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_ACS_RR</span><span class="p">);</span>

	<span class="cm">/* P2P Completion Redirect */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_ACS_CR</span><span class="p">);</span>

	<span class="cm">/* Upstream Forwarding */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_ACS_UF</span><span class="p">);</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ACS_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTD, 4=INTD)</span>
<span class="cm"> *</span>
<span class="cm"> * Perform INTx swizzling for a device behind one level of bridge.  This is</span>
<span class="cm"> * required by section 9.1 of the PCI-to-PCI bridge specification for devices</span>
<span class="cm"> * behind bridges on add-in cards.  For devices with ARI enabled, the slot</span>
<span class="cm"> * number is always 0 (see the Implementation Note in section 2.2.8.1 of</span>
<span class="cm"> * the PCI Express Base Specification, Revision 2.1)</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">pci_swizzle_interrupt_pin</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_ari_enabled</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(((</span><span class="n">pin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">slot</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pci_get_interrupt_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">bridge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">pin</span><span class="p">;</span>

	<span class="n">pin</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pin</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_root_bus</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pin</span> <span class="o">=</span> <span class="n">pci_swizzle_interrupt_pin</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bridge</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pin</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_common_swizzle - swizzle INTx all the way to root bridge</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @pinp: pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)</span>
<span class="cm"> *</span>
<span class="cm"> * Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI</span>
<span class="cm"> * bridges all the way up to a PCI root bus.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">pci_common_swizzle</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pinp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">pin</span> <span class="o">=</span> <span class="o">*</span><span class="n">pinp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_root_bus</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pin</span> <span class="o">=</span> <span class="n">pci_swizzle_interrupt_pin</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pinp</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_release_region - Release a PCI bar</span>
<span class="cm"> *	@pdev: PCI device whose resources were previously reserved by pci_request_region</span>
<span class="cm"> *	@bar: BAR to release</span>
<span class="cm"> *</span>
<span class="cm"> *	Releases the PCI I/O and memory resources previously reserved by a</span>
<span class="cm"> *	successful call to pci_request_region.  Call this function only</span>
<span class="cm"> *	after all use of the PCI regions has ceased.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_release_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span>
				<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span>
				<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">));</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_pci_dr</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">region_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__pci_request_region - Reserved PCI I/O and memory resource</span>
<span class="cm"> *	@pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> *	@bar: BAR to be reserved</span>
<span class="cm"> *	@res_name: Name to be associated with resource.</span>
<span class="cm"> *	@exclusive: whether the region access is exclusive or not</span>
<span class="cm"> *</span>
<span class="cm"> *	Mark the PCI region associated with PCI device @pdev BR @bar as</span>
<span class="cm"> *	being reserved by owner @res_name.  Do not access any</span>
<span class="cm"> *	address inside the PCI regions unless this call returns</span>
<span class="cm"> *	successfully.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @exclusive is set, then the region is marked so that userspace</span>
<span class="cm"> *	is explicitly not allowed to map the resource via /dev/mem or</span>
<span class="cm"> * 	sysfs MMIO access.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, or %EBUSY on error.  A warning</span>
<span class="cm"> *	message is also printed on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_request_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">,</span>
									<span class="kt">int</span> <span class="n">exclusive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span>
			    <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span> <span class="n">res_name</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__request_mem_region</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span>
					<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">),</span> <span class="n">res_name</span><span class="p">,</span>
					<span class="n">exclusive</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_pci_dr</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">region_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BAR %d: can&#39;t reserve %pR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">bar</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_request_region - Reserve PCI I/O and memory resource</span>
<span class="cm"> *	@pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> *	@bar: BAR to be reserved</span>
<span class="cm"> *	@res_name: Name to be associated with resource</span>
<span class="cm"> *</span>
<span class="cm"> *	Mark the PCI region associated with PCI device @pdev BAR @bar as</span>
<span class="cm"> *	being reserved by owner @res_name.  Do not access any</span>
<span class="cm"> *	address inside the PCI regions unless this call returns</span>
<span class="cm"> *	successfully.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, or %EBUSY on error.  A warning</span>
<span class="cm"> *	message is also printed on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_request_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_request_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_request_region_exclusive - Reserved PCI I/O and memory resource</span>
<span class="cm"> *	@pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> *	@bar: BAR to be reserved</span>
<span class="cm"> *	@res_name: Name to be associated with resource.</span>
<span class="cm"> *</span>
<span class="cm"> *	Mark the PCI region associated with PCI device @pdev BR @bar as</span>
<span class="cm"> *	being reserved by owner @res_name.  Do not access any</span>
<span class="cm"> *	address inside the PCI regions unless this call returns</span>
<span class="cm"> *	successfully.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, or %EBUSY on error.  A warning</span>
<span class="cm"> *	message is also printed on failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	The key difference that _exclusive makes it that userspace is</span>
<span class="cm"> *	explicitly not allowed to map the resource via /dev/mem or</span>
<span class="cm"> * 	sysfs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_request_region_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_request_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">IORESOURCE_EXCLUSIVE</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * pci_release_selected_regions - Release selected PCI I/O and memory resources</span>
<span class="cm"> * @pdev: PCI device whose resources were previously reserved</span>
<span class="cm"> * @bars: Bitmask of BARs to be released</span>
<span class="cm"> *</span>
<span class="cm"> * Release selected PCI I/O and memory resources previously reserved.</span>
<span class="cm"> * Call this function only after all use of the PCI regions has ceased.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_release_selected_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bars</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bars</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">pci_release_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__pci_request_selected_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bars</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">excl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bars</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__pci_request_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">excl</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bars</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">pci_release_region</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pci_request_selected_regions - Reserve selected PCI I/O and memory resources</span>
<span class="cm"> * @pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> * @bars: Bitmask of BARs to be requested</span>
<span class="cm"> * @res_name: Name to be associated with resource</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_request_selected_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bars</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pci_request_selected_regions_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">bars</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span>
			<span class="n">IORESOURCE_EXCLUSIVE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_release_regions - Release reserved PCI I/O and memory resources</span>
<span class="cm"> *	@pdev: PCI device whose resources were previously reserved by pci_request_regions</span>
<span class="cm"> *</span>
<span class="cm"> *	Releases all PCI I/O and memory resources previously reserved by a</span>
<span class="cm"> *	successful call to pci_request_regions.  Call this function only</span>
<span class="cm"> *	after all use of the PCI regions has ceased.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">pci_release_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_request_regions - Reserved PCI I/O and memory resources</span>
<span class="cm"> *	@pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> *	@res_name: Name to be associated with resource.</span>
<span class="cm"> *</span>
<span class="cm"> *	Mark all PCI regions associated with PCI device @pdev as</span>
<span class="cm"> *	being reserved by owner @res_name.  Do not access any</span>
<span class="cm"> *	address inside the PCI regions unless this call returns</span>
<span class="cm"> *	successfully.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, or %EBUSY on error.  A warning</span>
<span class="cm"> *	message is also printed on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_request_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">res_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pci_request_regions_exclusive - Reserved PCI I/O and memory resources</span>
<span class="cm"> *	@pdev: PCI device whose resources are to be reserved</span>
<span class="cm"> *	@res_name: Name to be associated with resource.</span>
<span class="cm"> *</span>
<span class="cm"> *	Mark all PCI regions associated with PCI device @pdev as</span>
<span class="cm"> *	being reserved by owner @res_name.  Do not access any</span>
<span class="cm"> *	address inside the PCI regions unless this call returns</span>
<span class="cm"> *	successfully.</span>
<span class="cm"> *</span>
<span class="cm"> *	pci_request_regions_exclusive() will mark the region so that</span>
<span class="cm"> * 	/dev/mem and the sysfs MMIO access will not be allowed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, or %EBUSY on error.  A warning</span>
<span class="cm"> *	message is also printed on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_request_regions_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_request_selected_regions_exclusive</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					<span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">res_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pci_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">old_cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">old_cmd</span> <span class="o">|</span> <span class="n">PCI_COMMAND_MASTER</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">old_cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_MASTER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">old_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s bus mastering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enabling&quot;</span> <span class="o">:</span> <span class="s">&quot;disabling&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span> <span class="o">=</span> <span class="n">enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcibios_set_master - enable PCI bus-mastering for device dev</span>
<span class="cm"> * @dev: the PCI device to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enables PCI bus-mastering for the device.  This is the default</span>
<span class="cm"> * implementation.  Architecture specific implementations can override</span>
<span class="cm"> * this if necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">pcibios_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">lat</span><span class="p">;</span>

	<span class="cm">/* The latency timer doesn&#39;t apply to PCIe (either Type 0 or Type 1) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lat</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">lat</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span> <span class="o">&lt;=</span> <span class="n">pcibios_max_latency</span><span class="p">)</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="n">pcibios_max_latency</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lat</span> <span class="o">&gt;</span> <span class="n">pcibios_max_latency</span><span class="p">)</span>
		<span class="n">lat</span> <span class="o">=</span> <span class="n">pcibios_max_latency</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setting latency timer to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lat</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="n">lat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_master - enables bus-mastering for device dev</span>
<span class="cm"> * @dev: the PCI device to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enables bus-mastering on the device and calls pcibios_set_master()</span>
<span class="cm"> * to do the needed arch specific settings.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__pci_set_master</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">pcibios_set_master</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_clear_master - disables bus-mastering for device dev</span>
<span class="cm"> * @dev: the PCI device to disable</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_clear_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__pci_set_master</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed</span>
<span class="cm"> * @dev: the PCI device for which MWI is to be enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Helper function for pci_set_mwi.</span>
<span class="cm"> * Originally copied from drivers/net/acenic.c.</span>
<span class="cm"> * Copyright 1998-2001 by Jes Sorensen, &lt;jes@trained-monkey.org&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: An appropriate -ERRNO error value on error, or zero for success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_set_cacheline_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">cacheline_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_cache_line_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Validate current setting: the PCI_CACHE_LINE_SIZE must be</span>
<span class="cm">	   equal to or multiple of the right value. */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cacheline_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cacheline_size</span> <span class="o">&gt;=</span> <span class="n">pci_cache_line_size</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cacheline_size</span> <span class="o">%</span> <span class="n">pci_cache_line_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Write the correct value. */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="n">pci_cache_line_size</span><span class="p">);</span>
	<span class="cm">/* Read it back. */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cacheline_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cacheline_size</span> <span class="o">==</span> <span class="n">pci_cache_line_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cache line size of %d is not &quot;</span>
		   <span class="s">&quot;supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_cache_line_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_set_cacheline_size</span><span class="p">);</span>

<span class="cp">#ifdef PCI_DISABLE_MWI</span>
<span class="kt">int</span> <span class="nf">pci_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pci_try_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pci_clear_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_mwi - enables memory-write-invalidate PCI transaction</span>
<span class="cm"> * @dev: the PCI device for which MWI is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: An appropriate -ERRNO error value on error, or zero for success.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pci_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_cacheline_size</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;enabling Mem-Wr-Inval</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_try_set_mwi - enables memory-write-invalidate PCI transaction</span>
<span class="cm"> * @dev: the PCI device for which MWI is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.</span>
<span class="cm"> * Callers are not required to check the return value.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: An appropriate -ERRNO error value on error, or zero for success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_try_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_mwi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_clear_mwi - disables Memory-Write-Invalidate for device dev</span>
<span class="cm"> * @dev: the PCI device to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Disables PCI Memory-Write-Invalidate transaction on the device</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pci_clear_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ! PCI_DISABLE_MWI */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * pci_intx - enables/disables PCI INTx for device dev</span>
<span class="cm"> * @pdev: the PCI device to operate on</span>
<span class="cm"> * @enable: boolean: whether to enable or disable PCI INTx</span>
<span class="cm"> *</span>
<span class="cm"> * Enables/disables PCI INTx for device dev</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pci_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pci_command</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_command</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">pci_command</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">pci_command</span> <span class="o">|</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="n">pci_command</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

		<span class="n">dr</span> <span class="o">=</span> <span class="n">find_pci_dr</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">restore_intx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dr</span><span class="o">-&gt;</span><span class="n">restore_intx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dr</span><span class="o">-&gt;</span><span class="n">orig_intx</span> <span class="o">=</span> <span class="o">!</span><span class="n">enable</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_intx_mask_supported - probe for INTx masking support</span>
<span class="cm"> * @dev: the PCI device to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the device dev support INTx masking via the config space</span>
<span class="cm"> * command word.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_intx_mask_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">mask_supported</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">orig</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">pci_cfg_access_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span>
			      <span class="n">orig</span> <span class="o">^</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s no way to protect against hardware bugs or detect them</span>
<span class="cm">	 * reliably, but as long as we know what the value should be, let&#39;s</span>
<span class="cm">	 * go ahead and check it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new</span> <span class="o">^</span> <span class="n">orig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Command register changed from &quot;</span>
			<span class="s">&quot;0x%x to 0x%x: driver or hardware bug?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">new</span> <span class="o">^</span> <span class="n">orig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask_supported</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_cfg_access_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mask_supported</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_intx_mask_supported</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pci_check_and_set_intx_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">mask_updated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_status_dword</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">origcmd</span><span class="p">,</span> <span class="n">newcmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_pending</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do a single dword read to retrieve both command and status.</span>
<span class="cm">	 * Document assumptions that make this possible.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PCI_COMMAND</span> <span class="o">%</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PCI_COMMAND</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">PCI_STATUS</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_status_dword</span><span class="p">);</span>

	<span class="n">irq_pending</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd_status_dword</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_INTERRUPT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check interrupt status register to see whether our device</span>
<span class="cm">	 * triggered the interrupt (when masking) or the next IRQ is</span>
<span class="cm">	 * already pending (when unmasking).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="n">irq_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask_updated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">origcmd</span> <span class="o">=</span> <span class="n">cmd_status_dword</span><span class="p">;</span>
	<span class="n">newcmd</span> <span class="o">=</span> <span class="n">origcmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span>
		<span class="n">newcmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newcmd</span> <span class="o">!=</span> <span class="n">origcmd</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">newcmd</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask_updated</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_check_and_mask_intx - mask INTx on pending interrupt</span>
<span class="cm"> * @dev: the PCI device to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the device dev has its INTx line asserted, mask it and</span>
<span class="cm"> * return true in that case. False is returned if not interrupt was</span>
<span class="cm"> * pending.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_check_and_mask_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_check_and_set_intx_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_check_and_mask_intx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_check_and_mask_intx - unmask INTx of no interrupt is pending</span>
<span class="cm"> * @dev: the PCI device to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the device dev has its INTx line asserted, unmask it if not</span>
<span class="cm"> * and return true. False is returned and the mask remains active if</span>
<span class="cm"> * there was still an interrupt pending.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_check_and_unmask_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_check_and_set_intx_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_check_and_unmask_intx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_msi_off - disables any msi or msix capabilities</span>
<span class="cm"> * @dev: the PCI device to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * If you want to use msi see pci_enable_msi and friends.</span>
<span class="cm"> * This is a lower level primitive that allows us to disable</span>
<span class="cm"> * msi operation at the device level.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_msi_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">control</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_MSI_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_MSI_FLAGS_ENABLE</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_MSI_FLAGS</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_MSIX_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_MSIX_FLAGS_ENABLE</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_MSIX_FLAGS</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_msi_off</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pci_set_dma_max_seg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_set_max_seg_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_dma_max_seg_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pci_set_dma_seg_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_set_seg_boundary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_dma_seg_boundary</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcie_flr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">,</span> <span class="n">control</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCAP_FLR</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for Transaction Pending bit clean */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVSTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVSTA_TRPND</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">clear</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;transaction is not cleared; &quot;</span>
			<span class="s">&quot;proceeding with reset anyway</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">clear:</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL_BCR_FLR</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_af_flr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_AF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_AF_CAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_AF_CAP_TP</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">PCI_AF_CAP_FLR</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for Transaction Pending bit clean */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_AF_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI_AF_STATUS_TP</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">clear</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;transaction is not cleared; &quot;</span>
			<span class="s">&quot;proceeding with reset anyway</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">clear:</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_AF_CTRL</span><span class="p">,</span> <span class="n">PCI_AF_CTRL_FLR</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pm_reset - Put device into PCI_D3 and back into PCI_D0.</span>
<span class="cm"> * @dev: Device to reset.</span>
<span class="cm"> * @probe: If set, only check if the device can be reset this way.</span>
<span class="cm"> *</span>
<span class="cm"> * If @dev supports native PCI PM and its PCI_PM_CTRL_NO_SOFT_RESET flag is</span>
<span class="cm"> * unset, it will be reinitialized internally when going from PCI_D3hot to</span>
<span class="cm"> * PCI_D0.  If that&#39;s the case and the device is not in a low-power state</span>
<span class="cm"> * already, force it into PCI_D3hot and back to PCI_D0, causing it to be reset.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This causes the caller to sleep for twice the device power transition</span>
<span class="cm"> * cooldown period, which for the D0-&gt;D3hot and D3hot-&gt;D0 transitions is 10 ms</span>
<span class="cm"> * by devault (i.e. unless the @dev&#39;s d3_delay field has a different value).</span>
<span class="cm"> * Moreover, only devices in D0 can be reset by this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">csr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">csr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_NO_SOFT_RESET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">csr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
	<span class="n">csr</span> <span class="o">|=</span> <span class="n">PCI_D3hot</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
	<span class="n">pci_dev_d3_sleep</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">csr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
	<span class="n">csr</span> <span class="o">|=</span> <span class="n">PCI_D0</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
	<span class="n">pci_dev_d3_sleep</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_parent_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_root_bus</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PCI_BRIDGE_CTL_BUS_RESET</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_BRIDGE_CTL_BUS_RESET</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pci_dev_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_dev_specific_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcie_flr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_af_flr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_pm_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_parent_bus_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_dev_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_cfg_access_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* block PM suspend, driver probe, etc. */</span>
		<span class="n">device_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">__pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pci_cfg_access_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * __pci_reset_function - reset a PCI device function</span>
<span class="cm"> * @dev: PCI device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices allow an individual function to be reset without affecting</span>
<span class="cm"> * other functions in the same device.  The PCI device must be responsive</span>
<span class="cm"> * to PCI config space in order to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The device function is presumed to be unused when this function is called.</span>
<span class="cm"> * Resetting the device will make the contents of PCI configuration space</span>
<span class="cm"> * random, so any caller of this must be prepared to reinitialise the</span>
<span class="cm"> * device including MSI, bus mastering, BARs, decoding IO and memory spaces,</span>
<span class="cm"> * etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the device function was successfully reset or negative if the</span>
<span class="cm"> * device doesn&#39;t support resetting a single function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pci_reset_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__pci_reset_function</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __pci_reset_function_locked - reset a PCI device function while holding</span>
<span class="cm"> * the @dev mutex lock.</span>
<span class="cm"> * @dev: PCI device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices allow an individual function to be reset without affecting</span>
<span class="cm"> * other functions in the same device.  The PCI device must be responsive</span>
<span class="cm"> * to PCI config space in order to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The device function is presumed to be unused and the caller is holding</span>
<span class="cm"> * the device mutex lock when this function is called.</span>
<span class="cm"> * Resetting the device will make the contents of PCI configuration space</span>
<span class="cm"> * random, so any caller of this must be prepared to reinitialise the</span>
<span class="cm"> * device including MSI, bus mastering, BARs, decoding IO and memory spaces,</span>
<span class="cm"> * etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the device function was successfully reset or negative if the</span>
<span class="cm"> * device doesn&#39;t support resetting a single function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pci_reset_function_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__pci_reset_function_locked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_probe_reset_function - check whether the device can be safely reset</span>
<span class="cm"> * @dev: PCI device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices allow an individual function to be reset without affecting</span>
<span class="cm"> * other functions in the same device.  The PCI device must be responsive</span>
<span class="cm"> * to PCI config space in order to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the device function can be reset or negative if the</span>
<span class="cm"> * device doesn&#39;t support resetting a single function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_probe_reset_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_reset_function - quiesce and reset a PCI device function</span>
<span class="cm"> * @dev: PCI device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices allow an individual function to be reset without affecting</span>
<span class="cm"> * other functions in the same device.  The PCI device must be responsive</span>
<span class="cm"> * to PCI config space in order to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not just reset the PCI portion of a device, but</span>
<span class="cm"> * clears all the state associated with the device.  This function differs</span>
<span class="cm"> * from __pci_reset_function in that it saves and restores device state</span>
<span class="cm"> * over the reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the device function was successfully reset or negative if the</span>
<span class="cm"> * device doesn&#39;t support resetting a single function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_reset_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * both INTx and MSI are disabled after the Interrupt Disable bit</span>
<span class="cm">	 * is set and the Bus Master bit is cleared.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_dev_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_reset_function</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns mmrbc: maximum designed memory read count in bytes</span>
<span class="cm"> *    or appropriate error value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcix_get_max_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_X_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">512</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_X_STATUS_MAX_READ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcix_get_max_mmrbc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcix_get_mmrbc - get PCI-X maximum memory read byte count</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns mmrbc: maximum memory read count in bytes</span>
<span class="cm"> *    or appropriate error value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcix_get_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_X_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">512</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_X_CMD_MAX_READ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcix_get_mmrbc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcix_set_mmrbc - set PCI-X maximum memory read byte count</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @mmrbc: maximum memory read count in bytes</span>
<span class="cm"> *    valid values are 512, 1024, 2048, 4096</span>
<span class="cm"> *</span>
<span class="cm"> * If possible sets maximum memory read byte count, some bridges have erratas</span>
<span class="cm"> * that prevent this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcix_set_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mmrbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">o</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmrbc</span> <span class="o">&lt;</span> <span class="mi">512</span> <span class="o">||</span> <span class="n">mmrbc</span> <span class="o">&gt;</span> <span class="mi">4096</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">mmrbc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">mmrbc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_X_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_X_STATUS_MAX_READ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_X_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">o</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_X_CMD_MAX_READ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">o</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_flags</span> <span class="o">&amp;</span> <span class="n">PCI_BUS_FLAGS_NO_MMRBC</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_X_CMD_MAX_READ</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_X_CMD</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcix_set_mmrbc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcie_get_readrq - get PCI Express read request size</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns maximum memory read request in bytes</span>
<span class="cm"> *    or appropriate error value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcie_get_readrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCTL_READRQ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcie_get_readrq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcie_set_readrq - set PCI Express maximum memory read request</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @rq: maximum memory read count in bytes</span>
<span class="cm"> *    valid values are 128, 256, 512, 1024, 2048, 4096</span>
<span class="cm"> *</span>
<span class="cm"> * If possible sets maximum memory read request in bytes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcie_set_readrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">&lt;</span> <span class="mi">128</span> <span class="o">||</span> <span class="n">rq</span> <span class="o">&gt;</span> <span class="mi">4096</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If using the &quot;performance&quot; PCIe config, we clamp the</span>
<span class="cm">	 * read rq size to the max packet size to prevent the</span>
<span class="cm">	 * host bridge generating requests larger than we can</span>
<span class="cm">	 * cope with</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_bus_config</span> <span class="o">==</span> <span class="n">PCIE_BUS_PERFORMANCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mps</span> <span class="o">=</span> <span class="n">pcie_get_mps</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mps</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mps</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="p">)</span>
			<span class="n">rq</span> <span class="o">=</span> <span class="n">mps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCTL_READRQ</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_DEVCTL_READRQ</span><span class="p">;</span>
		<span class="n">ctl</span> <span class="o">|=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcie_set_readrq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pcie_get_mps - get PCI Express maximum payload size</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns maximum payload size in bytes</span>
<span class="cm"> *    or appropriate error value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcie_get_mps</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCTL_PAYLOAD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcie_set_mps - set PCI Express maximum payload size</span>
<span class="cm"> * @dev: PCI device to query</span>
<span class="cm"> * @mps: maximum payload size in bytes</span>
<span class="cm"> *    valid values are 128, 256, 512, 1024, 2048, 4096</span>
<span class="cm"> *</span>
<span class="cm"> * If possible sets maximum payload size</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcie_set_mps</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mps</span> <span class="o">&lt;</span> <span class="mi">128</span> <span class="o">||</span> <span class="n">mps</span> <span class="o">&gt;</span> <span class="mi">4096</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">mps</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">mps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_mpss</span><span class="p">)</span> 
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">&lt;&lt;=</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCTL_PAYLOAD</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_DEVCTL_PAYLOAD</span><span class="p">;</span>
		<span class="n">ctl</span> <span class="o">|=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_select_bars - Make BAR mask from the type of resource</span>
<span class="cm"> * @dev: the PCI device for which BAR mask is made</span>
<span class="cm"> * @flags: resource type mask to be selected</span>
<span class="cm"> *</span>
<span class="cm"> * This helper routine makes bar mask from the type of resource.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_select_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bars</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span>
			<span class="n">bars</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bars</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_resource_bar - get position of the BAR associated with a resource</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @resno: the resource number</span>
<span class="cm"> * @type: the BAR type to be filled in</span>
<span class="cm"> *</span>
<span class="cm"> * Returns BAR position in config space, or 0 if the BAR is invalid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_resource_bar</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resno</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pci_bar_type</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resno</span> <span class="o">&lt;</span> <span class="n">PCI_ROM_RESOURCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">pci_bar_unknown</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PCI_BASE_ADDRESS_0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">resno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">resno</span> <span class="o">==</span> <span class="n">PCI_ROM_RESOURCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">pci_bar_mem32</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rom_base_reg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">resno</span> <span class="o">&lt;</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* device specific resource */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">pci_iov_resource_bar</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">resno</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BAR %d: invalid resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resno</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some architectures require additional programming to enable VGA */</span>
<span class="k">static</span> <span class="n">arch_set_vga_state_t</span> <span class="n">arch_set_vga_state</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pci_register_set_vga_state</span><span class="p">(</span><span class="n">arch_set_vga_state_t</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_set_vga_state</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>	<span class="cm">/* NULL disables */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_set_vga_state_arch</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command_bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arch_set_vga_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">arch_set_vga_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">decode</span><span class="p">,</span> <span class="n">command_bits</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_set_vga_state - set VGA decode state on device and parents if requested</span>
<span class="cm"> * @dev: the PCI device</span>
<span class="cm"> * @decode: true = enable decoding, false = disable decoding</span>
<span class="cm"> * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY</span>
<span class="cm"> * @flags: traverse ancestors and change bridges</span>
<span class="cm"> * CHANGE_BRIDGE_ONLY / CHANGE_BRIDGE</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_set_vga_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command_bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PCI_VGA_STATE_CHANGE_DECODES</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">command_bits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PCI_COMMAND_IO</span><span class="o">|</span><span class="n">PCI_COMMAND_MEMORY</span><span class="p">)));</span>

	<span class="cm">/* ARCH specific VGA enables */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_vga_state_arch</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">decode</span><span class="p">,</span> <span class="n">command_bits</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PCI_VGA_STATE_CHANGE_DECODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">decode</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
			<span class="n">cmd</span> <span class="o">|=</span> <span class="n">command_bits</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">command_bits</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PCI_VGA_STATE_CHANGE_BRIDGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">decode</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
				<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_BRIDGE_CTL_VGA</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_BRIDGE_CTL_VGA</span><span class="p">;</span>
			<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span>
					      <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">resource_alignment_param</span><span class="p">[</span><span class="n">RESOURCE_ALIGNMENT_PARAM_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">resource_alignment_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_specified_resource_alignment - get resource alignment specified by user.</span>
<span class="cm"> * @dev: the PCI device to get</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: Resource alignment if it is specified.</span>
<span class="cm"> *          Zero if it is not specified.</span>
<span class="cm"> */</span>
<span class="n">resource_size_t</span> <span class="nf">pci_specified_resource_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">align_order</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">resource_alignment_param</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%d%n&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">align_order</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
							<span class="n">p</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">align_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%x:%x:%x.%x%n&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%x:%x.%x%n&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Invalid format */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI: Can&#39;t parse resource_alignment parameter: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">p</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">bus</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&amp;&amp;</span>
			<span class="n">slot</span> <span class="o">==</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">func</span> <span class="o">==</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">align_order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">align</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">align</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">align_order</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Found */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;;&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* End of param or invalid format */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">align</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_is_reassigndev - check if specified PCI is target device to reassign</span>
<span class="cm"> * @dev: the PCI device to check</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: non-zero for PCI device is a target device to reassign,</span>
<span class="cm"> *          or zero is not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_is_reassigndev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pci_specified_resource_alignment</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function disables memory decoding and releases memory resources</span>
<span class="cm"> * of the device specified by kernel&#39;s boot parameter &#39;pci=resource_alignment=&#39;.</span>
<span class="cm"> * It also rounds up size to specified alignment.</span>
<span class="cm"> * Later on, the kernel will assign page-aligned memory resource back</span>
<span class="cm"> * to the device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_reassigndev_resource_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">command</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_reassigndev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_NORMAL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_BRIDGE_HOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Can&#39;t reassign resources to host bridge.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Disabling memory decoding and releasing memory resources.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_MEMORY</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="n">align</span> <span class="o">=</span> <span class="n">pci_specified_resource_alignment</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">align</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">align</span><span class="p">;</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Rounding up size of resource #%d to %#llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Need to disable bridge&#39;s resource window,</span>
<span class="cm">	 * to enable the kernel to reassign new resource</span>
<span class="cm">	 * window later on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_BRIDGE_PCI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_disable_bridge_window</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">pci_set_resource_alignment_param</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">RESOURCE_ALIGNMENT_PARAM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">RESOURCE_ALIGNMENT_PARAM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">resource_alignment_param</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">resource_alignment_param</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">pci_get_resource_alignment_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">resource_alignment_param</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_alignment_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pci_resource_alignment_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_get_resource_alignment_param</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pci_resource_alignment_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_set_resource_alignment_param</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">resource_alignment</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pci_resource_alignment_show</span><span class="p">,</span>
					<span class="n">pci_resource_alignment_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_resource_alignment_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bus_attr_resource_alignment</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">pci_resource_alignment_sysfs_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_no_domains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_DOMAINS</span>
	<span class="n">pci_domains_supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_ext_cfg_enabled - can we access extended PCI config space?</span>
<span class="cm"> * @dev: The PCI device of the root bridge.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if we can access PCI extended config space (offsets</span>
<span class="cm"> * greater than 0xff). This is the default implementation. Architecture</span>
<span class="cm"> * implementations can override this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">pci_ext_cfg_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">pci_fixup_cardbus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_fixup_cardbus</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span>
			<span class="o">*</span><span class="n">k</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">str</span> <span class="o">=</span> <span class="n">pcibios_setup</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nomsi&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_no_msi</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;noaer&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_no_aer</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;realloc=&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_realloc_get_opt</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;realloc&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_realloc_get_opt</span><span class="p">(</span><span class="s">&quot;on&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nodomains&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_no_domains</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;noari&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_ari_disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;cbiosize=&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_cardbus_io_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;cbmemsize=&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_cardbus_mem_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;resource_alignment=&quot;</span><span class="p">,</span> <span class="mi">19</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_set_resource_alignment_param</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span>
							<span class="n">strlen</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">19</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;ecrc=&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_ecrc_get_policy</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;hpiosize=&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_hotplug_io_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;hpmemsize=&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_hotplug_mem_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pcie_bus_tune_off&quot;</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_bus_config</span> <span class="o">=</span> <span class="n">PCIE_BUS_TUNE_OFF</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pcie_bus_safe&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_bus_config</span> <span class="o">=</span> <span class="n">PCIE_BUS_SAFE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pcie_bus_perf&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_bus_config</span> <span class="o">=</span> <span class="n">PCIE_BUS_PERFORMANCE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pcie_bus_peer2peer&quot;</span><span class="p">,</span> <span class="mi">18</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcie_bus_config</span> <span class="o">=</span> <span class="n">PCIE_BUS_PEER2PEER</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pcie_scan_all&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_add_flags</span><span class="p">(</span><span class="n">PCI_SCAN_ALL_PCIE_DEVS</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI: Unknown option `%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">str</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;pci&quot;</span><span class="p">,</span> <span class="n">pci_setup</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_reenable_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_device_io</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_enable_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcim_enable_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcim_pin_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_disable_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_find_capability</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_find_capability</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_release_regions</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_regions</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_regions_exclusive</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_release_region</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_region</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_region_exclusive</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_release_selected_regions</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_selected_regions</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_request_selected_regions_exclusive</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_master</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_clear_master</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_mwi</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_try_set_mwi</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_clear_mwi</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_intx</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_assign_resource</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_find_parent_resource</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_select_bars</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_set_power_state</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_save_state</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_restore_state</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_pme_capable</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_pme_active</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_wake_from_d3</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_target_state</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_prepare_to_sleep</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_back_from_sleep</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_set_pcie_reset_state</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
