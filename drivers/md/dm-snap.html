<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-snap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-snap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * dm-snapshot.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001-2002 Sistina Software (UK) Limited.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/device-mapper.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/dm-kcopyd.h&gt;</span>

<span class="cp">#include &quot;dm-exception-store.h&quot;</span>

<span class="cp">#define DM_MSG_PREFIX &quot;snapshots&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">dm_snapshot_merge_target_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;snapshot-merge&quot;</span><span class="p">;</span>

<span class="cp">#define dm_target_is_snapshot_merge(ti) \</span>
<span class="cp">	((ti)-&gt;type-&gt;name == dm_snapshot_merge_target_name)</span>

<span class="cm">/*</span>
<span class="cm"> * The size of the mempool used to track chunks in use.</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_IOS 256</span>

<span class="cp">#define DM_TRACKED_CHUNK_HASH_SIZE	16</span>
<span class="cp">#define DM_TRACKED_CHUNK_HASH(x)	((unsigned long)(x) &amp; \</span>
<span class="cp">					 (DM_TRACKED_CHUNK_HASH_SIZE - 1))</span>

<span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">hash_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hash_shift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">origin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">cow</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>

	<span class="cm">/* List of snapshots per Origin */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * You can&#39;t use a snapshot if this is 0 (e.g. if full).</span>
<span class="cm">	 * A snapshot-merge target never clears this.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>

	<span class="cm">/* Origin writes don&#39;t trigger exceptions until this is set */</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">pending_exceptions_count</span><span class="p">;</span>

	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">pending_pool</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="n">pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="n">complete</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pe_lock protects all pending_exception operations and access</span>
<span class="cm">	 * as well as the snapshot_bios list.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">pe_lock</span><span class="p">;</span>

	<span class="cm">/* Chunks with outstanding reads */</span>
	<span class="n">spinlock_t</span> <span class="n">tracked_chunk_lock</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">tracked_chunk_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">tracked_chunk_hash</span><span class="p">[</span><span class="n">DM_TRACKED_CHUNK_HASH_SIZE</span><span class="p">];</span>

	<span class="cm">/* The on disk metadata handler */</span>
	<span class="k">struct</span> <span class="n">dm_exception_store</span> <span class="o">*</span><span class="n">store</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_kcopyd_client</span> <span class="o">*</span><span class="n">kcopyd_client</span><span class="p">;</span>

	<span class="cm">/* Wait for events based on state_bits */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state_bits</span><span class="p">;</span>

	<span class="cm">/* Range of chunks currently being merged. */</span>
	<span class="n">chunk_t</span> <span class="n">first_merging_chunk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_merging_chunks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The merge operation failed if this flag is set.</span>
<span class="cm">	 * Failure modes are handled as follows:</span>
<span class="cm">	 * - I/O error reading the header</span>
<span class="cm">	 *   	=&gt; don&#39;t load the target; abort.</span>
<span class="cm">	 * - Header does not have &quot;valid&quot; flag set</span>
<span class="cm">	 *   	=&gt; use the origin; forget about the snapshot.</span>
<span class="cm">	 * - I/O error when reading exceptions</span>
<span class="cm">	 *   	=&gt; don&#39;t load the target; abort.</span>
<span class="cm">	 *         (We can&#39;t use the intermediate origin state.)</span>
<span class="cm">	 * - I/O error while merging</span>
<span class="cm">	 *	=&gt; stop merging; set merge_failed; process I/O normally.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">merge_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Incoming bios that overlap with chunks being merged must wait</span>
<span class="cm">	 * for them to be committed.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios_queued_during_merge</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * state_bits:</span>
<span class="cm"> *   RUNNING_MERGE  - Merge operation is in progress.</span>
<span class="cm"> *   SHUTDOWN_MERGE - Set to signal that merge needs to be stopped;</span>
<span class="cm"> *                    cleared afterwards.</span>
<span class="cm"> */</span>
<span class="cp">#define RUNNING_MERGE          0</span>
<span class="cp">#define SHUTDOWN_MERGE         1</span>

<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="nf">dm_snap_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_snap_origin</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="nf">dm_snap_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_snap_cow</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">chunk_to_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_store</span> <span class="o">*</span><span class="n">store</span><span class="p">,</span>
				<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chunk</span> <span class="o">&lt;&lt;</span> <span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdev_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There is only ever one instance of a particular block</span>
<span class="cm">	 * device so we can compare pointers safely.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="n">e</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Origin buffers waiting for this to complete are held</span>
<span class="cm">	 * in a bio list</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">origin_bios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">snapshot_bios</span><span class="p">;</span>

	<span class="cm">/* Pointer back to snapshot context */</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 1 indicates the exception has already been sent to</span>
<span class="cm">	 * kcopyd.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">started</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For writing a complete chunk, bypassing the copy.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">full_bio</span><span class="p">;</span>
	<span class="n">bio_end_io_t</span> <span class="o">*</span><span class="n">full_bio_end_io</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">full_bio_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Hash table mapping origin volumes to lists of snapshots and</span>
<span class="cm"> * a lock to protect it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">exception_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">pending_cache</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">tracked_chunk_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="o">*</span><span class="nf">track_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
						 <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span><span class="p">,</span>
							<span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_hash</span><span class="p">[</span><span class="n">DM_TRACKED_CHUNK_HASH</span><span class="p">(</span><span class="n">chunk</span><span class="p">)]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_tracking_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__chunk_is_tracked</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span>
	    <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_hash</span><span class="p">[</span><span class="n">DM_TRACKED_CHUNK_HASH</span><span class="p">(</span><span class="n">chunk</span><span class="p">)],</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This conflicting I/O is extremely improbable in the caller,</span>
<span class="cm"> * so msleep(1) is sufficient and there is no need for a wait queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__check_for_conflicting_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__chunk_is_tracked</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * One of these per registered origin, held in the snapshot_origins hash</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">origin</span> <span class="p">{</span>
	<span class="cm">/* The origin device */</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">hash_list</span><span class="p">;</span>

	<span class="cm">/* List of snapshots for this origin */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">snapshots</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the hash table for origin volumes. If we make this</span>
<span class="cm"> * the size of the minors list then it should be nearly perfect</span>
<span class="cm"> */</span>
<span class="cp">#define ORIGIN_HASH_SIZE 256</span>
<span class="cp">#define ORIGIN_MASK      0xFF</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">_origins</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">_origins_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">_pending_exceptions_done</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">_pending_exceptions_done_spinlock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">_pending_exceptions_done_count</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_origin_hash</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">_origins</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ORIGIN_HASH_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span>
			   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_origins</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;unable to allocate memory&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ORIGIN_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">_origins</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_origin_hash</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">_origins</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">origin_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span> <span class="o">&amp;</span> <span class="n">ORIGIN_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="nf">__lookup_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

	<span class="n">ol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_origins</span><span class="p">[</span><span class="n">origin_hash</span><span class="p">(</span><span class="n">origin</span><span class="p">)];</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ol</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdev_equal</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">o</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__insert_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_origins</span><span class="p">[</span><span class="n">origin_hash</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)];</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">hash_list</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _origins_lock must be held when calling this function.</span>
<span class="cm"> * Returns number of snapshots registered using the supplied cow device, plus:</span>
<span class="cm"> * snap_src - a snapshot suitable for use as a source of exception handover</span>
<span class="cm"> * snap_dest - a snapshot capable of receiving exception handover.</span>
<span class="cm"> * snap_merge - an existing snapshot-merge target linked to the same origin.</span>
<span class="cm"> *   There can be at most one snapshot-merge target. The parameter is optional.</span>
<span class="cm"> *</span>
<span class="cm"> * Possible return values and states of snap_src and snap_dest.</span>
<span class="cm"> *   0: NULL, NULL  - first new snapshot</span>
<span class="cm"> *   1: snap_src, NULL - normal snapshot</span>
<span class="cm"> *   2: snap_src, snap_dest  - waiting for handover</span>
<span class="cm"> *   2: snap_src, NULL - handed over, waiting for old to be deleted</span>
<span class="cm"> *   1: NULL, snap_dest - source got destroyed without handover</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__find_snapshots_sharing_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">**</span><span class="n">snap_src</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">**</span><span class="n">snap_dest</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">**</span><span class="n">snap_merge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">;</span>

	<span class="n">o</span> <span class="o">=</span> <span class="n">__lookup_origin</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_is_snapshot_merge</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">snap_merge</span><span class="p">)</span>
			<span class="o">*</span><span class="n">snap_merge</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev_equal</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">active</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snap_src</span><span class="p">)</span>
				<span class="o">*</span><span class="n">snap_src</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">snap_dest</span><span class="p">)</span>
			<span class="o">*</span><span class="n">snap_dest</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On success, returns 1 if this snapshot is a handover destination,</span>
<span class="cm"> * otherwise returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__validate_exception_handover</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">snap_dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_merge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Does snapshot need exceptions handed over to it? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">__find_snapshots_sharing_cow</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_dest</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">snap_merge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">snap_dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Snapshot cow pairing for exception &quot;</span>
				  <span class="s">&quot;table handover failed&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If no snap_src was found, snap cannot become a handover</span>
<span class="cm">	 * destination.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snap_src</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Non-snapshot-merge handover?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dm_target_is_snapshot_merge</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not allow more than one merging snapshot.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snap_merge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;A snapshot is already merging.&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">prepare_merge</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">commit_merge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Snapshot exception store does not &quot;</span>
				  <span class="s">&quot;support snapshot-merge.&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__insert_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="cm">/* Sort the list according to chunk size, largest-first smallest-last */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make a note of the snapshot and its origin so we can look it</span>
<span class="cm"> * up when the origin has a write on it.</span>
<span class="cm"> *</span>
<span class="cm"> * Also validate snapshot exception store handovers.</span>
<span class="cm"> * On success, returns 1 if this registration is a handover destination,</span>
<span class="cm"> * otherwise returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">new_o</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_o</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_o</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_o</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__validate_exception_handover</span><span class="p">(</span><span class="n">snap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_o</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">o</span> <span class="o">=</span> <span class="n">__lookup_origin</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_o</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* New origin */</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">new_o</span><span class="p">;</span>

		<span class="cm">/* Initialise the struct */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">);</span>
		<span class="n">o</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>

		<span class="n">__insert_origin</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__insert_snapshot</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">snap</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move snapshot to correct place in list according to chunk size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reregister_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">__insert_snapshot</span><span class="p">(</span><span class="n">__lookup_origin</span><span class="p">(</span><span class="n">bdev</span><span class="p">),</span> <span class="n">s</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="n">o</span> <span class="o">=</span> <span class="n">__lookup_origin</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">hash_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implementation of the exception hash tables.</span>
<span class="cm"> * The lowest hash_shift bits of the chunk number are ignored, allowing</span>
<span class="cm"> * some consecutive chunks to be grouped together.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_exception_table_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="o">*</span><span class="n">et</span><span class="p">,</span>
				   <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">hash_shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">et</span><span class="o">-&gt;</span><span class="n">hash_shift</span> <span class="o">=</span> <span class="n">hash_shift</span><span class="p">;</span>
	<span class="n">et</span><span class="o">-&gt;</span><span class="n">hash_mask</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">dm_vcalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_exception_table_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="o">*</span><span class="n">et</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">et</span><span class="o">-&gt;</span><span class="n">hash_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">list_for_each_entry_safe</span> <span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">exception_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="o">*</span><span class="n">et</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&gt;&gt;</span> <span class="n">et</span><span class="o">-&gt;</span><span class="n">hash_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">et</span><span class="o">-&gt;</span><span class="n">hash_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_remove_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">hash_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the exception data for a sector, or NULL if not</span>
<span class="cm"> * remapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="nf">dm_lookup_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="o">*</span><span class="n">et</span><span class="p">,</span>
						<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">exception_hash</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)];</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">&amp;&amp;</span>
		    <span class="n">chunk</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">+</span> <span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="nf">alloc_completed_exception</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">exception_cache</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">exception_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_completed_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">exception_cache</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="nf">alloc_pending_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span><span class="p">,</span>
							     <span class="n">GFP_NOIO</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_exceptions_count</span><span class="p">);</span>
	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pending_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span><span class="p">);</span>
	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_exceptions_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_insert_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="o">*</span><span class="n">eh</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">new_e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">exception_hash</span><span class="p">(</span><span class="n">eh</span><span class="p">,</span> <span class="n">new_e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="p">)];</span>

	<span class="cm">/* Add immediately if this table doesn&#39;t support consecutive chunks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">hash_shift</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* List is ordered by old_chunk */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Insert after an existing chunk? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">+</span>
					 <span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">new_e</span><span class="o">-&gt;</span><span class="n">new_chunk</span> <span class="o">==</span> <span class="p">(</span><span class="n">dm_chunk_number</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span><span class="p">)</span> <span class="o">+</span>
					 <span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dm_consecutive_chunk_count_inc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="n">free_completed_exception</span><span class="p">(</span><span class="n">new_e</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Insert before an existing chunk? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">new_e</span><span class="o">-&gt;</span><span class="n">new_chunk</span> <span class="o">==</span> <span class="p">(</span><span class="n">dm_chunk_number</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dm_consecutive_chunk_count_inc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="o">--</span><span class="p">;</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span><span class="o">--</span><span class="p">;</span>
			<span class="n">free_completed_exception</span><span class="p">(</span><span class="n">new_e</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_e</span><span class="o">-&gt;</span><span class="n">hash_list</span><span class="p">,</span> <span class="n">e</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">hash_list</span> <span class="o">:</span> <span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback used by the exception stores to load exceptions when</span>
<span class="cm"> * initialising.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_add_exception</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">old</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">alloc_completed_exception</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>

	<span class="cm">/* Consecutive_count is implicitly initialised to zero */</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">dm_insert_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a minimum chunk size of all snapshots that have the specified origin.</span>
<span class="cm"> * Return zero if the origin has no snapshots.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">__minimum_chunk_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">chunk_size</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span>
						  <span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chunk_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hard coded magic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_max_buckets</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use a fixed size of 2MB */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">mem</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate room for a suitable hash table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_hash_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">hash_size</span><span class="p">,</span> <span class="n">cow_dev_size</span><span class="p">,</span> <span class="n">origin_dev_size</span><span class="p">,</span> <span class="n">max_buckets</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate based on the size of the original volume or</span>
<span class="cm">	 * the COW volume...</span>
<span class="cm">	 */</span>
	<span class="n">cow_dev_size</span> <span class="o">=</span> <span class="n">get_dev_size</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">origin_dev_size</span> <span class="o">=</span> <span class="n">get_dev_size</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">max_buckets</span> <span class="o">=</span> <span class="n">calc_max_buckets</span><span class="p">();</span>

	<span class="n">hash_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">origin_dev_size</span><span class="p">,</span> <span class="n">cow_dev_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_shift</span><span class="p">;</span>
	<span class="n">hash_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">hash_size</span><span class="p">,</span> <span class="n">max_buckets</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash_size</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">hash_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">hash_size</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">hash_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm_exception_table_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">hash_size</span><span class="p">,</span>
				    <span class="n">DM_CHUNK_CONSECUTIVE_BITS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate hash table for in-flight exceptions</span>
<span class="cm">	 * Make this smaller than the real hash table</span>
<span class="cm">	 */</span>
	<span class="n">hash_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_size</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">hash_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_exception_table_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">hash_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dm_exception_table_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">exception_cache</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">merge_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit_unlock</span><span class="p">(</span><span class="n">RUNNING_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">,</span> <span class="n">RUNNING_MERGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">__release_queued_bios_after_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio_list_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bios_queued_during_merge</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove one chunk from the index of completed exceptions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__remove_single_exception_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					   <span class="n">chunk_t</span> <span class="n">old_chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">old_chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Corruption detected: exception for block %llu is &quot;</span>
		      <span class="s">&quot;on disk but not in memory&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_chunk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the only chunk using this exception, remove exception.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dm_remove_exception</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="n">free_completed_exception</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The chunk may be either at the beginning or the end of a</span>
<span class="cm">	 * group of consecutive chunks - never in the middle.  We are</span>
<span class="cm">	 * removing chunks in the opposite order to that in which they</span>
<span class="cm">	 * were added, so this should always be true.</span>
<span class="cm">	 * Decrement the consecutive chunk counter and adjust the</span>
<span class="cm">	 * starting point if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_chunk</span> <span class="o">==</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="o">++</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_chunk</span> <span class="o">!=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">+</span>
		   <span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Attempt to merge block %llu from the &quot;</span>
		      <span class="s">&quot;middle of a chunk range [%llu - %llu]&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_chunk</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		      <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span> <span class="o">+</span> <span class="n">dm_consecutive_chunk_count</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dm_consecutive_chunk_count_dec</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_single_exception_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">old_chunk</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process chunks (and associated exceptions) in reverse order</span>
<span class="cm">	 * so that dm_consecutive_chunk_count_dec() accounting works.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">__remove_single_exception_chunk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">old_chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">old_chunk</span><span class="o">--</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span><span class="p">);</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">__release_queued_bios_after_merge</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
		<span class="n">flush_bios</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">origin_write_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">merging_snap</span><span class="p">,</span>
			       <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">chunk_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">merge_callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_err</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">read_pending_exceptions_done_count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">pending_exceptions_done</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pending_exceptions_done_spinlock</span><span class="p">);</span>
	<span class="n">pending_exceptions_done</span> <span class="o">=</span> <span class="n">_pending_exceptions_done_count</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pending_exceptions_done_spinlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pending_exceptions_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">increment_pending_exceptions_done_count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pending_exceptions_done_spinlock</span><span class="p">);</span>
	<span class="n">_pending_exceptions_done_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pending_exceptions_done_spinlock</span><span class="p">);</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pending_exceptions_done</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snapshot_merge_next_chunks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">linear_chunks</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">old_chunk</span><span class="p">,</span> <span class="n">new_chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">io_size</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">previous_count</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">RUNNING_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SHUTDOWN_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * valid flag never changes during merge, so no lock required.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Snapshot is invalid: can&#39;t merge&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">linear_chunks</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">prepare_merge</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_chunk</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">new_chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">linear_chunks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">linear_chunks</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Read error in exception store: &quot;</span>
			      <span class="s">&quot;shutting down merge&quot;</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">merge_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Adjust old_chunk and new_chunk to reflect start of linear region */</span>
	<span class="n">old_chunk</span> <span class="o">=</span> <span class="n">old_chunk</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">linear_chunks</span><span class="p">;</span>
	<span class="n">new_chunk</span> <span class="o">=</span> <span class="n">new_chunk</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">linear_chunks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use one (potentially large) I/O to copy all &#39;linear_chunks&#39;</span>
<span class="cm">	 * from the exception store to the origin</span>
<span class="cm">	 */</span>
	<span class="n">io_size</span> <span class="o">=</span> <span class="n">linear_chunks</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">;</span>

	<span class="n">dest</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">dest</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">chunk_to_sector</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">old_chunk</span><span class="p">);</span>
	<span class="n">dest</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">io_size</span><span class="p">,</span> <span class="n">get_dev_size</span><span class="p">(</span><span class="n">dest</span><span class="p">.</span><span class="n">bdev</span><span class="p">)</span> <span class="o">-</span> <span class="n">dest</span><span class="p">.</span><span class="n">sector</span><span class="p">);</span>

	<span class="n">src</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">src</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">chunk_to_sector</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">new_chunk</span><span class="p">);</span>
	<span class="n">src</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">dest</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reallocate any exceptions needed in other snapshots then</span>
<span class="cm">	 * wait for the pending exceptions to complete.</span>
<span class="cm">	 * Each time any pending exception (globally on the system)</span>
<span class="cm">	 * completes we are woken and repeat the process to find out</span>
<span class="cm">	 * if we can proceed.  While this may not seem a particularly</span>
<span class="cm">	 * efficient algorithm, it is not expected to have any</span>
<span class="cm">	 * significant impact on performance.</span>
<span class="cm">	 */</span>
	<span class="n">previous_count</span> <span class="o">=</span> <span class="n">read_pending_exceptions_done_count</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">origin_write_extent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dest</span><span class="p">.</span><span class="n">sector</span><span class="p">,</span> <span class="n">io_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">_pending_exceptions_done</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">read_pending_exceptions_done_count</span><span class="p">()</span> <span class="o">!=</span>
			    <span class="n">previous_count</span><span class="p">));</span>
		<span class="cm">/* Retry after the wait, until all exceptions are done. */</span>
		<span class="n">previous_count</span> <span class="o">=</span> <span class="n">read_pending_exceptions_done_count</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">=</span> <span class="n">old_chunk</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span> <span class="o">=</span> <span class="n">linear_chunks</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Wait until writes to all &#39;linear_chunks&#39; drain */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">linear_chunks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__check_for_conflicting_io</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">old_chunk</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">dm_kcopyd_copy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">merge_callback</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">shut:</span>
	<span class="n">merge_shutdown</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">error_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">merge_callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span> <span class="o">||</span> <span class="n">write_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span><span class="p">)</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Read error: shutting down merge.&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Write error: shutting down merge.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">commit_merge</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span>
					 <span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Write error in exception store: shutting down merge&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remove_single_exception_chunk</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">shut</span><span class="p">;</span>

	<span class="n">snapshot_merge_next_chunks</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">shut:</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">merge_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">__release_queued_bios_after_merge</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">error_bios</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="n">merge_shutdown</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">RUNNING_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">))</span>
		<span class="n">snapshot_merge_next_chunks</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_schedule</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop the merging process and wait until it finishes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SHUTDOWN_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">);</span>
	<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">,</span> <span class="n">RUNNING_MERGE</span><span class="p">,</span> <span class="n">wait_schedule</span><span class="p">,</span>
		    <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SHUTDOWN_MERGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct a snapshot mapping: &lt;origin_dev&gt; &lt;COW-dev&gt; &lt;p/n&gt; &lt;chunk-size&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">origin_path</span><span class="p">,</span> <span class="o">*</span><span class="n">cow_path</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">args_used</span><span class="p">,</span> <span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">origin_mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;requires exactly 4 arguments&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_is_snapshot_merge</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">origin_mode</span> <span class="o">=</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate private snapshot structure&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">origin_path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">argv</span><span class="o">++</span><span class="p">;</span>
	<span class="n">argc</span><span class="o">--</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">origin_path</span><span class="p">,</span> <span class="n">origin_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot get origin device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_origin</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cow_path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">argv</span><span class="o">++</span><span class="p">;</span>
	<span class="n">argc</span><span class="o">--</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">cow_path</span><span class="p">,</span> <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot get COW device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_cow</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_exception_store_create</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args_used</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t create exception store&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_store</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">argv</span> <span class="o">+=</span> <span class="n">args_used</span><span class="p">;</span>
	<span class="n">argc</span> <span class="o">-=</span> <span class="n">args_used</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_exceptions_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pe_lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">merge_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bios_queued_during_merge</span><span class="p">);</span>

	<span class="cm">/* Allocate hash table for COW data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_hash_tables</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Unable to allocate hash table space&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_hash_tables</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span> <span class="o">=</span> <span class="n">dm_kcopyd_client_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">);</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Could not create kcopyd client&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_kcopyd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">MIN_IOS</span><span class="p">,</span> <span class="n">pending_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Could not allocate mempool for pending exceptions&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_pending_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">MIN_IOS</span><span class="p">,</span>
							 <span class="n">tracked_chunk_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Could not allocate tracked_chunk mempool for &quot;</span>
			    <span class="s">&quot;tracking reads&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_tracked_chunk_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DM_TRACKED_CHUNK_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_lock</span><span class="p">);</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="n">num_flush_requests</span><span class="p">;</span>

	<span class="cm">/* Add snapshot to the list of snapshots for this origin */</span>
	<span class="cm">/* Exceptions aren&#39;t triggered till snapshot_resume() is called */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">register_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Snapshot origin struct allocation failed&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_load_and_register</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* invalid handover, register_snapshot has set ti-&gt;error */</span>
		<span class="k">goto</span> <span class="n">bad_load_and_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Metadata must only be loaded into one table at once, so skip this</span>
<span class="cm">	 * if metadata will be handed over during resume.</span>
<span class="cm">	 * Chunk size will be set during the handover - set it to zero to</span>
<span class="cm">	 * ensure it&#39;s ignored.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">read_metadata</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">dm_add_exception</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Failed to read snapshot metadata&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_read_metadata</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Snapshot is marked invalid.&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Chunk size not set&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_read_metadata</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_read_metadata:</span>
	<span class="n">unregister_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

<span class="nl">bad_load_and_register:</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span><span class="p">);</span>

<span class="nl">bad_tracked_chunk_pool:</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span><span class="p">);</span>

<span class="nl">bad_pending_pool:</span>
	<span class="n">dm_kcopyd_client_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">);</span>

<span class="nl">bad_kcopyd:</span>
	<span class="n">dm_exception_table_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">pending_cache</span><span class="p">);</span>
	<span class="n">dm_exception_table_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">exception_cache</span><span class="p">);</span>

<span class="nl">bad_hash_tables:</span>
	<span class="n">dm_exception_store_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">);</span>

<span class="nl">bad_store:</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="p">);</span>

<span class="nl">bad_cow:</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">);</span>

<span class="nl">bad_origin:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

<span class="nl">bad:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_exceptions</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_kcopyd_client_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dm_exception_table_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">pending_cache</span><span class="p">);</span>
	<span class="n">dm_exception_table_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">exception_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__handover_exceptions</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_src</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_exception_table</span> <span class="n">table_swap</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dm_exception_store</span> <span class="o">*</span><span class="n">store_swap</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Swap all snapshot context information between the two instances.</span>
<span class="cm">	 */</span>
	<span class="n">u</span><span class="p">.</span><span class="n">table_swap</span> <span class="o">=</span> <span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">;</span>
	<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">;</span>
	<span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">table_swap</span><span class="p">;</span>

	<span class="n">u</span><span class="p">.</span><span class="n">store_swap</span> <span class="o">=</span> <span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">;</span>
	<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">store</span> <span class="o">=</span> <span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">;</span>
	<span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">store</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">store_swap</span><span class="p">;</span>

	<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">snap</span> <span class="o">=</span> <span class="n">snap_dest</span><span class="p">;</span>
	<span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">snap</span> <span class="o">=</span> <span class="n">snap_src</span><span class="p">;</span>

	<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">;</span>
	<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set source invalid to ensure it receives no further I/O.</span>
<span class="cm">	 */</span>
	<span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snapshot_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DM_DEBUG</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">snap_dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="cm">/* Check whether exception handover must be cancelled */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__find_snapshots_sharing_cow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_dest</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snap_src</span> <span class="o">&amp;&amp;</span> <span class="n">snap_dest</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">snap_src</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Cancelling snapshot handover.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_is_snapshot_merge</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span>
		<span class="n">stop_merge</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Prevent further origin writes from using this snapshot. */</span>
	<span class="cm">/* After this returns there can be no new kcopyd jobs. */</span>
	<span class="n">unregister_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_exceptions_count</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure instructions in mempool_destroy aren&#39;t reordered</span>
<span class="cm">	 * before atomic_read.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_DM_DEBUG</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DM_TRACKED_CHUNK_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_hash</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="cp">#endif</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">tracked_chunk_pool</span><span class="p">);</span>

	<span class="n">__free_exceptions</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_pool</span><span class="p">);</span>

	<span class="n">dm_exception_store_destroy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">);</span>

	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="p">);</span>

	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush a list of buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Flush a list of buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retry_origin_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">do_origin</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">)</span>
			<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Error a list of buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">error_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__invalidate_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Invalidating snapshot: Error reading/writing.&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Invalidating snapshot: Unable to allocate exception.&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">drop_snapshot</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">drop_snapshot</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dm_table_event</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pending_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">success</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">origin_bios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">snapshot_bios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">full_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read/write error - snapshot is unusable */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__invalidate_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">alloc_completed_exception</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__invalidate_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_completed_exception</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for conflicting reads */</span>
	<span class="n">__check_for_conflicting_io</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">.</span><span class="n">old_chunk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add a proper exception, and remove the</span>
<span class="cm">	 * in-flight exception from the list.</span>
<span class="cm">	 */</span>
	<span class="n">dm_insert_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">dm_remove_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">);</span>
	<span class="n">snapshot_bios</span> <span class="o">=</span> <span class="n">bio_list_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">snapshot_bios</span><span class="p">);</span>
	<span class="n">origin_bios</span> <span class="o">=</span> <span class="n">bio_list_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">origin_bios</span><span class="p">);</span>
	<span class="n">full_bio</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">full_bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio_end_io</span><span class="p">;</span>
		<span class="n">full_bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>

	<span class="n">increment_pending_exceptions_done_count</span><span class="p">();</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Submit any pending write bios */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">full_bio</span><span class="p">)</span>
			<span class="n">bio_io_error</span><span class="p">(</span><span class="n">full_bio</span><span class="p">);</span>
		<span class="n">error_bios</span><span class="p">(</span><span class="n">snapshot_bios</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">full_bio</span><span class="p">)</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">full_bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">flush_bios</span><span class="p">(</span><span class="n">snapshot_bios</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">retry_origin_bios</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">origin_bios</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">commit_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">success</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="n">pending_complete</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">success</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the copy I/O has finished.  kcopyd actually runs</span>
<span class="cm"> * this code so don&#39;t block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span> <span class="o">||</span> <span class="n">write_err</span><span class="p">)</span>
		<span class="n">pending_complete</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">else</span>
		<span class="cm">/* Update the metadata if we are persistent */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">commit_exception</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">,</span>
						 <span class="n">commit_callback</span><span class="p">,</span> <span class="n">pe</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dispatches the copy operation to kcopyd.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">dev_size</span><span class="p">;</span>

	<span class="n">dev_size</span> <span class="o">=</span> <span class="n">get_dev_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">src</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">src</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">chunk_to_sector</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">.</span><span class="n">old_chunk</span><span class="p">);</span>
	<span class="n">src</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">sector_t</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">dev_size</span> <span class="o">-</span> <span class="n">src</span><span class="p">.</span><span class="n">sector</span><span class="p">);</span>

	<span class="n">dest</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">dest</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">chunk_to_sector</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">.</span><span class="n">new_chunk</span><span class="p">);</span>
	<span class="n">dest</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Hand over to kcopyd */</span>
	<span class="n">dm_kcopyd_copy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy_callback</span><span class="p">,</span> <span class="n">pe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">full_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="n">dm_kcopyd_do_callback</span><span class="p">(</span><span class="n">callback_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_full_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">;</span>

	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio_end_io</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio_private</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="n">callback_data</span> <span class="o">=</span> <span class="n">dm_kcopyd_prepare_callback</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">,</span>
						   <span class="n">copy_callback</span><span class="p">,</span> <span class="n">pe</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">full_bio_end_io</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">callback_data</span><span class="p">;</span>

	<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span>
<span class="nf">__lookup_pending_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_snap_pending_exception</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Looks to see if this snapshot already has a pending exception</span>
<span class="cm"> * for this chunk, otherwise it allocates a new one and inserts</span>
<span class="cm"> * it into the pending table.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: a write lock must be held on snap-&gt;lock before calling</span>
<span class="cm"> * this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span>
<span class="nf">__find_pending_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe2</span><span class="p">;</span>

	<span class="n">pe2</span> <span class="o">=</span> <span class="n">__lookup_pending_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pe2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pe2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">.</span><span class="n">old_chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">origin_bios</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">snapshot_bios</span><span class="p">);</span>
	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pe</span><span class="o">-&gt;</span><span class="n">full_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">prepare_exception</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dm_insert_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remap_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">chunk_to_sector</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span>
					 <span class="n">dm_chunk_number</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">new_chunk</span><span class="p">)</span> <span class="o">+</span>
					 <span class="p">(</span><span class="n">chunk</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">old_chunk</span><span class="p">))</span> <span class="o">+</span>
					 <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&amp;</span>
					  <span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">sector_to_chunk</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>

	<span class="cm">/* Full snapshots are not usable */</span>
	<span class="cm">/* To get here the table must be live so s-&gt;active is always set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* FIXME: should only take write lock if we need</span>
<span class="cm">	 * to copy an exception */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the block is already remapped - use that, else remap it */</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remap_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write to snapshot - higher level takes care of RW/RO</span>
<span class="cm">	 * flags so we should only get this if we are</span>
<span class="cm">	 * writeable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pe</span> <span class="o">=</span> <span class="n">__lookup_pending_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">pe</span> <span class="o">=</span> <span class="n">alloc_pending_exception</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
				<span class="n">remap_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pe</span> <span class="o">=</span> <span class="n">__find_pending_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pe</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__invalidate_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">remap_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">chunk_size</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">start_full_bio</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">snapshot_bios</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this is protected by snap-&gt;lock */</span>
			<span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">start_copy</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">track_chunk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A snapshot-merge target behaves like a combination of a snapshot</span>
<span class="cm"> * target and a snapshot-origin target.  It only generates new</span>
<span class="cm"> * exceptions in other snapshots and not in the one that is being</span>
<span class="cm"> * merged.</span>
<span class="cm"> *</span>
<span class="cm"> * For each chunk, if there is an existing exception, it is used to</span>
<span class="cm"> * redirect I/O to the cow device.  Otherwise I/O is sent to the origin,</span>
<span class="cm"> * which in turn might generate exceptions in other snapshots.</span>
<span class="cm"> * If merging is currently taking place on the chunk in question, the</span>
<span class="cm"> * I/O is deferred by adding it to s-&gt;bios_queued_during_merge.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_merge_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			      <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_context</span><span class="o">-&gt;</span><span class="n">target_request_nr</span><span class="p">)</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">sector_to_chunk</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Full merging snapshots are redirected to the origin */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">redirect_to_origin</span><span class="p">;</span>

	<span class="cm">/* If the block is already remapped - use that */</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Queue writes overlapping with chunks being merged */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">chunk</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">&amp;&amp;</span>
		    <span class="n">chunk</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">first_merging_chunk</span> <span class="o">+</span>
			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">num_merging_chunks</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bios_queued_during_merge</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">remap_exception</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
			<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">track_chunk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">redirect_to_origin:</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">do_origin</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snap_tracked_chunk</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
		<span class="n">stop_tracking_chunk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snapshot_merge_presuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">stop_merge</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_preresume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">snap_dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__find_snapshots_sharing_cow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_dest</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snap_src</span> <span class="o">&amp;&amp;</span> <span class="n">snap_dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">snap_src</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Unable to resume snapshot source until &quot;</span>
			      <span class="s">&quot;handover completes.&quot;</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dm_suspended</span><span class="p">(</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Unable to perform snapshot handover until &quot;</span>
			      <span class="s">&quot;source is suspended.&quot;</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snapshot_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap_src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">snap_dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__find_snapshots_sharing_cow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snap_dest</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snap_src</span> <span class="o">&amp;&amp;</span> <span class="n">snap_dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">down_write_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="n">__handover_exceptions</span><span class="p">(</span><span class="n">snap_src</span><span class="p">,</span> <span class="n">snap_dest</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap_src</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="cm">/* Now we have correct chunk size, reregister */</span>
	<span class="n">reregister_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">get_origin_minimum_chunksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">min_chunksize</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="n">min_chunksize</span> <span class="o">=</span> <span class="n">__minimum_chunk_size</span><span class="p">(</span><span class="n">__lookup_origin</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">min_chunksize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snapshot_merge_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handover exceptions from existing snapshot.</span>
<span class="cm">	 */</span>
	<span class="n">snapshot_resume</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * snapshot-merge acts as an origin, so set ti-&gt;split_io</span>
<span class="cm">	 */</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">get_origin_minimum_chunksize</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">start_merge</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;Invalid&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">merge_failed</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;Merge failed&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sector_t</span> <span class="n">total_sectors</span><span class="p">,</span> <span class="n">sectors_allocated</span><span class="p">,</span>
					 <span class="n">metadata_sectors</span><span class="p">;</span>
				<span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">total_sectors</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">sectors_allocated</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">metadata_sectors</span><span class="p">);</span>
				<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu/%llu %llu&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sectors_allocated</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">total_sectors</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">metadata_sectors</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;Unknown&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * kdevname returns a static pointer so we need</span>
<span class="cm">		 * to make private copies if the output is to</span>
<span class="cm">		 * make sense.</span>
<span class="cm">		 */</span>
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">,</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">result</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span>
					  <span class="n">maxlen</span> <span class="o">-</span> <span class="n">sz</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snapshot_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				    <span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">snap</span><span class="o">-&gt;</span><span class="n">cow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">get_dev_size</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Origin methods</span>
<span class="cm"> *---------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * If no exceptions need creating, DM_MAPIO_REMAPPED is returned and any</span>
<span class="cm"> * supplied bio was ignored.  The caller may submit it immediately.</span>
<span class="cm"> * (No remapping actually occurs as the origin is always a direct linear</span>
<span class="cm"> * map.)</span>
<span class="cm"> *</span>
<span class="cm"> * If further exceptions are required, DM_MAPIO_SUBMITTED is returned</span>
<span class="cm"> * and any supplied bio is added to a list to be submitted once all</span>
<span class="cm"> * the necessary exceptions exist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__origin_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">snap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_exception</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe_to_start_now</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_snap_pending_exception</span> <span class="o">*</span><span class="n">pe_to_start_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">chunk_t</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="cm">/* Do all the snapshots on this origin */</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="n">snapshots</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t make new exceptions in a merging snapshot</span>
<span class="cm">		 * because it has effectively been deleted</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_is_snapshot_merge</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Only deal with valid and active snapshots */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">||</span> <span class="o">!</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>

		<span class="cm">/* Nothing to do if writing beyond end of snapshot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;=</span> <span class="n">dm_table_get_size</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remember, different snapshots can have</span>
<span class="cm">		 * different chunk sizes.</span>
<span class="cm">		 */</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">sector_to_chunk</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check exception table to see if block</span>
<span class="cm">		 * is already remapped in this snapshot</span>
<span class="cm">		 * and trigger an exception if not.</span>
<span class="cm">		 */</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>

		<span class="n">pe</span> <span class="o">=</span> <span class="n">__lookup_pending_exception</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">pe</span> <span class="o">=</span> <span class="n">alloc_pending_exception</span><span class="p">(</span><span class="n">snap</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">e</span> <span class="o">=</span> <span class="n">dm_lookup_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_pending_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pe</span> <span class="o">=</span> <span class="n">__find_pending_exception</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="n">pe</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__invalidate_snapshot</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next_snapshot</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If an origin bio was supplied, queue it to wait for the</span>
<span class="cm">		 * completion of this exception, and start this one last,</span>
<span class="cm">		 * at the end of the function.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">origin_bios</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">pe_to_start_last</span> <span class="o">=</span> <span class="n">pe</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pe</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pe_to_start_now</span> <span class="o">=</span> <span class="n">pe</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">next_snapshot:</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pe_to_start_now</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start_copy</span><span class="p">(</span><span class="n">pe_to_start_now</span><span class="p">);</span>
			<span class="n">pe_to_start_now</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Submit the exception against which the bio is queued last,</span>
<span class="cm">	 * to give the other exceptions a head start.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pe_to_start_last</span><span class="p">)</span>
		<span class="n">start_copy</span><span class="p">(</span><span class="n">pe_to_start_last</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called on a write from the origin driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="n">o</span> <span class="o">=</span> <span class="n">__lookup_origin</span><span class="p">(</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">__origin_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Trigger exceptions in all non-merging snapshots.</span>
<span class="cm"> *</span>
<span class="cm"> * The chunk size of the merging snapshot may be larger than the chunk</span>
<span class="cm"> * size of some other snapshot so we may need to reallocate multiple</span>
<span class="cm"> * chunks in other snapshots.</span>
<span class="cm"> *</span>
<span class="cm"> * We scan all the overlapping exceptions in the other snapshots.</span>
<span class="cm"> * Returns 1 if anything was reallocated and must be waited for,</span>
<span class="cm"> * otherwise returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * size must be a multiple of merging_snap&#39;s chunk_size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_write_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_snapshot</span> <span class="o">*</span><span class="n">merging_snap</span><span class="p">,</span>
			       <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">must_wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">origin</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The origin&#39;s __minimum_chunk_size() got stored in split_io</span>
<span class="cm">	 * by snapshot_merge_resume().</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>
	<span class="n">o</span> <span class="o">=</span> <span class="n">__lookup_origin</span><span class="p">(</span><span class="n">merging_snap</span><span class="o">-&gt;</span><span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">merging_snap</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__origin_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">snapshots</span><span class="p">,</span> <span class="n">sector</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">)</span>
			<span class="n">must_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_origins_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">must_wait</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Origin: maps a linear range of a device, with hooks for snapshotting.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Construct an origin mapping: &lt;dev_path&gt;</span>
<span class="cm"> * The context for an origin is merely a &#39;struct dm_dev *&#39;</span>
<span class="cm"> * pointing to the real device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;origin: incorrect number of arguments&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot get target device&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">origin_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		      <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>

	<span class="cm">/* Only tell snapshots if this is a write */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">do_origin</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bio</span><span class="p">)</span> <span class="o">:</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the target &quot;split_io&quot; field to the minimum of all the snapshots&#39;</span>
<span class="cm"> * chunk sizes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">origin_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">get_origin_minimum_chunksize</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
		<span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="o">*</span><span class="n">bvm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">biovec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max_size</span><span class="p">;</span>

	<span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bvm</span><span class="p">,</span> <span class="n">biovec</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">origin_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				  <span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">origin_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&quot;snapshot-origin&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span>     <span class="o">=</span> <span class="n">origin_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>     <span class="o">=</span> <span class="n">origin_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>     <span class="o">=</span> <span class="n">origin_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">origin_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span>  <span class="o">=</span> <span class="n">origin_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">merge</span>	 <span class="o">=</span> <span class="n">origin_merge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">origin_iterate_devices</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">snapshot_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&quot;snapshot&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span>     <span class="o">=</span> <span class="n">snapshot_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>     <span class="o">=</span> <span class="n">snapshot_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>     <span class="o">=</span> <span class="n">snapshot_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end_io</span>  <span class="o">=</span> <span class="n">snapshot_end_io</span><span class="p">,</span>
	<span class="p">.</span><span class="n">preresume</span>  <span class="o">=</span> <span class="n">snapshot_preresume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">snapshot_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span>  <span class="o">=</span> <span class="n">snapshot_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">snapshot_iterate_devices</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">merge_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="n">dm_snapshot_merge_target_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span>     <span class="o">=</span> <span class="n">snapshot_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>     <span class="o">=</span> <span class="n">snapshot_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>     <span class="o">=</span> <span class="n">snapshot_merge_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end_io</span>  <span class="o">=</span> <span class="n">snapshot_end_io</span><span class="p">,</span>
	<span class="p">.</span><span class="n">presuspend</span> <span class="o">=</span> <span class="n">snapshot_merge_presuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">preresume</span>  <span class="o">=</span> <span class="n">snapshot_preresume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">snapshot_merge_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span>  <span class="o">=</span> <span class="n">snapshot_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">snapshot_iterate_devices</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dm_snapshot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_exception_store_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to initialize exception stores&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;snapshot target register failed %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_register_snapshot_target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">origin_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Origin target register failed %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_register_origin_target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">merge_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Merge target register failed %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_register_merge_target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">init_origin_hash</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;init_origin_hash failed.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_origin_hash</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">exception_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_exception</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create exception cache.&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_exception_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pending_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_snap_pending_exception</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create pending cache.&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_pending_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tracked_chunk_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_snap_tracked_chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracked_chunk_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create cache to track chunks in use.&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_tracked_chunk_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_tracked_chunk_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pending_cache</span><span class="p">);</span>
<span class="nl">bad_pending_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">exception_cache</span><span class="p">);</span>
<span class="nl">bad_exception_cache:</span>
	<span class="n">exit_origin_hash</span><span class="p">();</span>
<span class="nl">bad_origin_hash:</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">merge_target</span><span class="p">);</span>
<span class="nl">bad_register_merge_target:</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">origin_target</span><span class="p">);</span>
<span class="nl">bad_register_origin_target:</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_target</span><span class="p">);</span>
<span class="nl">bad_register_snapshot_target:</span>
	<span class="n">dm_exception_store_exit</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">dm_snapshot_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_target</span><span class="p">);</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">origin_target</span><span class="p">);</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">merge_target</span><span class="p">);</span>

	<span class="n">exit_origin_hash</span><span class="p">();</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pending_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">exception_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">tracked_chunk_cache</span><span class="p">);</span>

	<span class="n">dm_exception_store_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Module hooks */</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">dm_snapshot_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dm_snapshot_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DM_NAME</span> <span class="s">&quot; snapshot target&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Joe Thornber&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
