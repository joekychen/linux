<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-log-userspace-base.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-log-userspace-base.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006-2009 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the LGPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/dm-dirty-log.h&gt;</span>
<span class="cp">#include &lt;linux/device-mapper.h&gt;</span>
<span class="cp">#include &lt;linux/dm-log-userspace.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;dm-log-userspace-transfer.h&quot;</span>

<span class="cp">#define DM_LOG_USERSPACE_VSN &quot;1.1.0&quot;</span>

<span class="k">struct</span> <span class="n">flush_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">region_t</span> <span class="n">region</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This limit on the number of mark and clear request is, to a degree,</span>
<span class="cm"> * arbitrary.  However, there is some basis for the choice in the limits</span>
<span class="cm"> * imposed on the size of data payload by dm-log-userspace-transfer.c:</span>
<span class="cm"> * dm_consult_userspace().</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_FLUSH_GROUP_COUNT 32</span>

<span class="k">struct</span> <span class="n">log_c</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">log_dev</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">region_size</span><span class="p">;</span>
	<span class="n">region_t</span> <span class="n">region_count</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">luid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="n">DM_UUID_LEN</span><span class="p">];</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">usr_argv_str</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">usr_argc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * in_sync_hint gets set when doing is_remote_recovering.  It</span>
<span class="cm">	 * represents the first region that needs recovery.  IOW, the</span>
<span class="cm">	 * first zero bit of sync_bits.  This can be useful for to limit</span>
<span class="cm">	 * traffic for calls like is_remote_recovering and get_resync_work,</span>
<span class="cm">	 * but be take care in its use for anything else.</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">in_sync_hint</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark and clear requests are held until a flush is issued</span>
<span class="cm">	 * so that we can group, and thereby limit, the amount of</span>
<span class="cm">	 * network traffic between kernel and userspace.  The &#39;flush_lock&#39;</span>
<span class="cm">	 * is used to protect these lists.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">flush_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mark_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">clear_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">flush_entry_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">flush_entry_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pool_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">flush_entry</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_entry_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pool_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_do_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uuid</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">request_type</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_size</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">rdata_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the server isn&#39;t there, -ESRCH is returned,</span>
<span class="cm">	 * and we must keep trying until the server is</span>
<span class="cm">	 * restored.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">request_type</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
				 <span class="n">data_size</span><span class="p">,</span> <span class="n">rdata</span><span class="p">,</span> <span class="n">rdata_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot; Userspace log server not found.&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Attempting to contact userspace log server...&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_CTR</span><span class="p">,</span>
					 <span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argv_str</span><span class="p">,</span>
					 <span class="n">strlen</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argv_str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DMINFO</span><span class="p">(</span><span class="s">&quot;Reconnected to userspace log server... DM_ULOG_CTR complete&quot;</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_RESUME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Error trying to resume userspace log: %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_constructor_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">**</span><span class="n">ctr_str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">str_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ctr_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">str_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">str_size</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* +1 for space between args */</span>

	<span class="n">str_size</span> <span class="o">+=</span> <span class="mi">20</span><span class="p">;</span> <span class="cm">/* Max number of chars in a printed u64 number */</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">str_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for constructor string&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">str_size</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">str_size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">str_size</span><span class="p">,</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="o">*</span><span class="n">ctr_str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">str_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_ctr</span>
<span class="cm"> *</span>
<span class="cm"> * argv contains:</span>
<span class="cm"> *	&lt;UUID&gt; &lt;other args&gt;</span>
<span class="cm"> * Where &#39;other args&#39; is the userspace implementation specific log</span>
<span class="cm"> * arguments.  An example might be:</span>
<span class="cm"> *	&lt;UUID&gt; clustered-disk &lt;arg count&gt; &lt;log dev&gt; &lt;region_size&gt; [[no]sync]</span>
<span class="cm"> *</span>
<span class="cm"> * So, this module will strip off the &lt;UUID&gt; for identification purposes</span>
<span class="cm"> * when communicating with userspace about a log; but will pass on everything</span>
<span class="cm"> * else.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">str_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ctr_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">rdata</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">devices_rdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">devices_rdata_size</span> <span class="o">=</span> <span class="n">DM_NAME_LEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Too few arguments to userspace dirty log&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Unable to allocate userspace log context.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The ptr value is sufficient for local unique id */</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lc</span><span class="p">;</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">DM_UUID_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;UUID argument too long.&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DM_UUID_LEN</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">mark_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">);</span>

	<span class="n">str_size</span> <span class="o">=</span> <span class="n">build_constructor_string</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">argv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctr_str</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">str_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">devices_rdata</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">devices_rdata_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devices_rdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory for device information&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send table string and get back any opened device.</span>
<span class="cm">	 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_CTR</span><span class="p">,</span>
				 <span class="n">ctr_str</span><span class="p">,</span> <span class="n">str_size</span><span class="p">,</span>
				 <span class="n">devices_rdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devices_rdata_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">)</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Userspace log server not found&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Userspace log server failed to create log&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Since the region size does not change, get it now */</span>
	<span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_GET_REGION_SIZE</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to get region size of dirty log&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">rdata</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_count</span> <span class="o">=</span> <span class="n">dm_sector_div_up</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devices_rdata_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devices_rdata</span><span class="p">[</span><span class="n">devices_rdata_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;DM_ULOG_CTR device return string not properly terminated&quot;</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">devices_rdata</span><span class="p">,</span>
				  <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">log_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to register %s with device-mapper&quot;</span><span class="p">,</span>
			      <span class="n">devices_rdata</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devices_rdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctr_str</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argv_str</span> <span class="o">=</span> <span class="n">ctr_str</span><span class="p">;</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argc</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">lc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">userspace_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_DTR</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">log_dev</span><span class="p">)</span>
		<span class="n">dm_put_device</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">log_dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argv_str</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_presuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_PRESUSPEND</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_postsuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_POSTSUSPEND</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_sync_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_consult_userspace</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">luid</span><span class="p">,</span> <span class="n">DM_ULOG_RESUME</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">userspace_get_region_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_is_clean</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether a region is clean.  If there is any sort of</span>
<span class="cm"> * failure when consulting the server, we return not clean.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if clean, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_is_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">region_t</span> <span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">region64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">region</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">is_clean</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_clean</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_IS_CLEAN</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">region64</span><span class="p">),</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">is_clean</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">is_clean</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_in_sync</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the region is in-sync.  If there is any sort</span>
<span class="cm"> * of failure when consulting the server, we assume that</span>
<span class="cm"> * the region is not in sync.</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;can_block&#39; is set, return immediately</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if in-sync, 0 if not-in-sync, -EWOULDBLOCK</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_in_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">region_t</span> <span class="n">region</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">can_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">region64</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">in_sync</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can never respond directly - even if in_sync_hint is</span>
<span class="cm">	 * set.  This is because another machine could see a device</span>
<span class="cm">	 * failure and mark the region out-of-sync.  If we don&#39;t go</span>
<span class="cm">	 * to userspace to ask, we might think the region is in-sync</span>
<span class="cm">	 * and allow a read to pick up data that is stale.  (This is</span>
<span class="cm">	 * very unlikely if a device actually fails; but it is very</span>
<span class="cm">	 * likely if a connection to one device from one machine fails.)</span>
<span class="cm">	 *</span>
<span class="cm">	 * There still might be a problem if the mirror caches the region</span>
<span class="cm">	 * state as in-sync... but then this call would not be made.  So,</span>
<span class="cm">	 * that is a mirror problem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_block</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>

	<span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">in_sync</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_IN_SYNC</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">region64</span><span class="p">),</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">in_sync</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in_sync</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_one_by_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">flush_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flush_entry</span> <span class="o">*</span><span class="n">fe</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">flush_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">),</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_by_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">flush_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flush_entry</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_fe</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="kt">uint64_t</span> <span class="n">group</span><span class="p">[</span><span class="n">MAX_FLUSH_GROUP_COUNT</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Group process the requests</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">flush_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">tmp_fe</span><span class="p">,</span> <span class="n">flush_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">group</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>

			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>

			<span class="n">type</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">MAX_FLUSH_GROUP_COUNT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">group</span><span class="p">),</span>
					 <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">),</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Group send failed.  Attempt one-by-one. */</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">flush_list</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">flush_one_by_one</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">flush_list</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must collect flush_entrys that were successfully processed</span>
<span class="cm">	 * as a group so that they will be free&#39;d by the caller.</span>
<span class="cm">	 */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">flush_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_flush</span>
<span class="cm"> *</span>
<span class="cm"> * This function is ok to block.</span>
<span class="cm"> * The flush happens in two stages.  First, it sends all</span>
<span class="cm"> * clear/mark requests that are on the list.  Then it</span>
<span class="cm"> * tells the server to commit them.  This gives the</span>
<span class="cm"> * server a chance to optimise the commit, instead of</span>
<span class="cm"> * doing it for every request.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, we could implement another thread that</span>
<span class="cm"> * sends the requests up to the server - reducing the</span>
<span class="cm"> * load on flush.  Then the flush would have less in</span>
<span class="cm"> * the list and be responsible for the finishing commit.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success, &lt; 0 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">mark_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">flush_entry</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_fe</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">mark_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mark_list</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mark_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clear_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">flush_by_group</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mark_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">flush_by_group</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_FLUSH</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can safely remove these entries, even if failure.</span>
<span class="cm">	 * Calling code will receive an error and will know that</span>
<span class="cm">	 * the log facility has failed.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">tmp_fe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mark_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">flush_entry_pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">tmp_fe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clear_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">flush_entry_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">dm_table_event</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_mark_region</span>
<span class="cm"> *</span>
<span class="cm"> * This function should avoid blocking unless absolutely required.</span>
<span class="cm"> * (Memory allocation is valid for blocking.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">userspace_mark_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">region_t</span> <span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flush_entry</span> <span class="o">*</span><span class="n">fe</span><span class="p">;</span>

	<span class="cm">/* Wait for an allocation, but _never_ fail */</span>
	<span class="n">fe</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">flush_entry_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fe</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fe</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_ULOG_MARK_REGION</span><span class="p">;</span>
	<span class="n">fe</span><span class="o">-&gt;</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">mark_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_clear_region</span>
<span class="cm"> *</span>
<span class="cm"> * This function must not block.</span>
<span class="cm"> * So, the alloc can&#39;t block.  In the worst case, it is ok to</span>
<span class="cm"> * fail.  It would simply mean we can&#39;t clear the region.</span>
<span class="cm"> * Does nothing to current sync context, but does mean</span>
<span class="cm"> * the region will be re-sync&#39;ed on a reload of the mirror</span>
<span class="cm"> * even though it is in-sync.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">userspace_clear_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">region_t</span> <span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flush_entry</span> <span class="o">*</span><span class="n">fe</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we fail to allocate, we skip the clearing of</span>
<span class="cm">	 * the region.  This doesn&#39;t hurt us in any way, except</span>
<span class="cm">	 * to cause the region to be resync&#39;ed when the</span>
<span class="cm">	 * device is activated next time.</span>
<span class="cm">	 */</span>
	<span class="n">fe</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">flush_entry_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory to clear region.&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fe</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_ULOG_CLEAR_REGION</span><span class="p">;</span>
	<span class="n">fe</span><span class="o">-&gt;</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_get_resync_work</span>
<span class="cm"> *</span>
<span class="cm"> * Get a region that needs recovery.  It is valid to return</span>
<span class="cm"> * an error for this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if region filled, 0 if no work, &lt;0 on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_get_resync_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">region_t</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int64_t</span> <span class="n">i</span><span class="p">;</span> <span class="cm">/* 64-bit for mix arch compatibility */</span>
		<span class="n">region_t</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">pkg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_sync_hint</span> <span class="o">&gt;=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pkg</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_GET_RESYNC_WORK</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>

	<span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="n">pkg</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">?</span> <span class="n">r</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pkg</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_set_region_sync</span>
<span class="cm"> *</span>
<span class="cm"> * Set the sync status of a given region.  This function</span>
<span class="cm"> * must not fail.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">userspace_set_region_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span>
				      <span class="n">region_t</span> <span class="n">region</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">region_t</span> <span class="n">r</span><span class="p">;</span>
		<span class="kt">int64_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">pkg</span><span class="p">;</span>

	<span class="n">pkg</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
	<span class="n">pkg</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">in_sync</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_SET_REGION_SYNC</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pkg</span><span class="p">),</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It would be nice to be able to report failures.</span>
<span class="cm">	 * However, it is easy emough to detect and resolve.</span>
<span class="cm">	 */</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_get_sync_count</span>
<span class="cm"> *</span>
<span class="cm"> * If there is any sort of failure when consulting the server,</span>
<span class="cm"> * we assume that the sync count is zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: sync count on success, 0 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">region_t</span> <span class="nf">userspace_get_sync_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">sync_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sync_count</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_GET_SYNC_COUNT</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sync_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sync_count</span> <span class="o">&gt;=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_count</span><span class="p">)</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_sync_hint</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">region_count</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">region_t</span><span class="p">)</span><span class="n">sync_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_status</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: amount of space consumed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">status_type</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">table_args</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">maxlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_STATUS_INFO</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sz</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s 1 COM_FAILURE&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">table_args</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argv_str</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">table_args</span><span class="p">);</span> <span class="cm">/* There will always be a &#39; &#39; */</span>
		<span class="n">table_args</span><span class="o">++</span><span class="p">;</span>

		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s %u %s %s &quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">usr_argc</span><span class="p">,</span>
		       <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">table_args</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * userspace_is_remote_recovering</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if region recovering, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">userspace_is_remote_recovering</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span>
					  <span class="n">region_t</span> <span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">region64</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log_c</span> <span class="o">*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int64_t</span> <span class="n">is_recovering</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">in_sync_hint</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">pkg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pkg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once the mirror has been reported to be in-sync,</span>
<span class="cm">	 * it will never again ask for recovery work.  So,</span>
<span class="cm">	 * we can safely say there is not a remote machine</span>
<span class="cm">	 * recovering if the device is in-sync.  (in_sync_hint</span>
<span class="cm">	 * must be reset at resume time.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="o">&lt;</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_sync_hint</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">userspace_do_request</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">DM_ULOG_IS_REMOTE_RECOVERING</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">region64</span><span class="p">),</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_sync_hint</span> <span class="o">=</span> <span class="n">pkg</span><span class="p">.</span><span class="n">in_sync_hint</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pkg</span><span class="p">.</span><span class="n">is_recovering</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_dirty_log_type</span> <span class="n">_userspace_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;userspace&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">userspace_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span> <span class="o">=</span> <span class="n">userspace_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">presuspend</span> <span class="o">=</span> <span class="n">userspace_presuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postsuspend</span> <span class="o">=</span> <span class="n">userspace_postsuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">userspace_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_region_size</span> <span class="o">=</span> <span class="n">userspace_get_region_size</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_clean</span> <span class="o">=</span> <span class="n">userspace_is_clean</span><span class="p">,</span>
	<span class="p">.</span><span class="n">in_sync</span> <span class="o">=</span> <span class="n">userspace_in_sync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">userspace_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mark_region</span> <span class="o">=</span> <span class="n">userspace_mark_region</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_region</span> <span class="o">=</span> <span class="n">userspace_clear_region</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_resync_work</span> <span class="o">=</span> <span class="n">userspace_get_resync_work</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_region_sync</span> <span class="o">=</span> <span class="n">userspace_set_region_sync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sync_count</span> <span class="o">=</span> <span class="n">userspace_get_sync_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">userspace_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_remote_recovering</span> <span class="o">=</span> <span class="n">userspace_is_remote_recovering</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">userspace_dirty_log_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flush_entry_pool</span> <span class="o">=</span> <span class="n">mempool_create</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">flush_entry_alloc</span><span class="p">,</span>
					  <span class="n">flush_entry_free</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush_entry_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Unable to create flush_entry_pool:  No memory.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_ulog_tfr_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Unable to initialize userspace log communications&quot;</span><span class="p">);</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">flush_entry_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_dirty_log_type_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_userspace_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register userspace dirty log type&quot;</span><span class="p">);</span>
		<span class="n">dm_ulog_tfr_exit</span><span class="p">();</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">flush_entry_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DMINFO</span><span class="p">(</span><span class="s">&quot;version &quot;</span> <span class="n">DM_LOG_USERSPACE_VSN</span> <span class="s">&quot; loaded&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">userspace_dirty_log_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_dirty_log_type_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_userspace_type</span><span class="p">);</span>
	<span class="n">dm_ulog_tfr_exit</span><span class="p">();</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">flush_entry_pool</span><span class="p">);</span>

	<span class="n">DMINFO</span><span class="p">(</span><span class="s">&quot;version &quot;</span> <span class="n">DM_LOG_USERSPACE_VSN</span> <span class="s">&quot; unloaded&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">userspace_dirty_log_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">userspace_dirty_log_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DM_NAME</span> <span class="s">&quot; userspace dirty log link&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jonathan Brassow &lt;dm-devel@redhat.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
