<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-thin.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-thin.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2011 Red Hat UK.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;dm-thin-metadata.h&quot;</span>

<span class="cp">#include &lt;linux/device-mapper.h&gt;</span>
<span class="cp">#include &lt;linux/dm-io.h&gt;</span>
<span class="cp">#include &lt;linux/dm-kcopyd.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#define	DM_MSG_PREFIX	&quot;thin&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Tunable constants</span>
<span class="cm"> */</span>
<span class="cp">#define ENDIO_HOOK_POOL_SIZE 10240</span>
<span class="cp">#define DEFERRED_SET_SIZE 64</span>
<span class="cp">#define MAPPING_POOL_SIZE 1024</span>
<span class="cp">#define PRISON_CELLS 1024</span>
<span class="cp">#define COMMIT_PERIOD HZ</span>

<span class="cm">/*</span>
<span class="cm"> * The block size of the device holding pool data must be</span>
<span class="cm"> * between 64KB and 1GB.</span>
<span class="cm"> */</span>
<span class="cp">#define DATA_DEV_BLOCK_SIZE_MIN_SECTORS (64 * 1024 &gt;&gt; SECTOR_SHIFT)</span>
<span class="cp">#define DATA_DEV_BLOCK_SIZE_MAX_SECTORS (1024 * 1024 * 1024 &gt;&gt; SECTOR_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Device id is restricted to 24 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_DEV_ID ((1 &lt;&lt; 24) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * How do we handle breaking sharing of data blocks?</span>
<span class="cm"> * =================================================</span>
<span class="cm"> *</span>
<span class="cm"> * We use a standard copy-on-write btree to store the mappings for the</span>
<span class="cm"> * devices (note I&#39;m talking about copy-on-write of the metadata here, not</span>
<span class="cm"> * the data).  When you take an internal snapshot you clone the root node</span>
<span class="cm"> * of the origin btree.  After this there is no concept of an origin or a</span>
<span class="cm"> * snapshot.  They are just two device trees that happen to point to the</span>
<span class="cm"> * same data blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * When we get a write in we decide if it&#39;s to a shared data block using</span>
<span class="cm"> * some timestamp magic.  If it is, we have to break sharing.</span>
<span class="cm"> *</span>
<span class="cm"> * Let&#39;s say we write to a shared block in what was the origin.  The</span>
<span class="cm"> * steps are:</span>
<span class="cm"> *</span>
<span class="cm"> * i) plug io further to this physical block. (see bio_prison code).</span>
<span class="cm"> *</span>
<span class="cm"> * ii) quiesce any read io to that shared data block.  Obviously</span>
<span class="cm"> * including all devices that share this block.  (see deferred_set code)</span>
<span class="cm"> *</span>
<span class="cm"> * iii) copy the data block to a newly allocate block.  This step can be</span>
<span class="cm"> * missed out if the io covers the block. (schedule_copy).</span>
<span class="cm"> *</span>
<span class="cm"> * iv) insert the new mapping into the origin&#39;s btree</span>
<span class="cm"> * (process_prepared_mapping).  This act of inserting breaks some</span>
<span class="cm"> * sharing of btree nodes between the two devices.  Breaking sharing only</span>
<span class="cm"> * effects the btree of that specific device.  Btrees for the other</span>
<span class="cm"> * devices that share the block never change.  The btree for the origin</span>
<span class="cm"> * device as it was after the last commit is untouched, ie. we&#39;re using</span>
<span class="cm"> * persistent data structures in the functional programming sense.</span>
<span class="cm"> *</span>
<span class="cm"> * v) unplug io to this physical block, including the io that triggered</span>
<span class="cm"> * the breaking of sharing.</span>
<span class="cm"> *</span>
<span class="cm"> * Steps (ii) and (iii) occur in parallel.</span>
<span class="cm"> *</span>
<span class="cm"> * The metadata _doesn&#39;t_ need to be committed before the io continues.  We</span>
<span class="cm"> * get away with this because the io is always written to a _new_ block.</span>
<span class="cm"> * If there&#39;s a crash, then:</span>
<span class="cm"> *</span>
<span class="cm"> * - The origin mapping will point to the old origin block (the shared</span>
<span class="cm"> * one).  This will contain the data as it was before the io that triggered</span>
<span class="cm"> * the breaking of sharing came in.</span>
<span class="cm"> *</span>
<span class="cm"> * - The snap mapping still points to the old block.  As it would after</span>
<span class="cm"> * the commit.</span>
<span class="cm"> *</span>
<span class="cm"> * The downside of this scheme is the timestamp magic isn&#39;t perfect, and</span>
<span class="cm"> * will continue to think that data block in the snapshot device is shared</span>
<span class="cm"> * even after the write to the origin has broken sharing.  I suspect data</span>
<span class="cm"> * blocks will typically be shared by many different devices, so we&#39;re</span>
<span class="cm"> * breaking sharing n + 1 times, rather than n, where n is the number of</span>
<span class="cm"> * devices that reference this data block.  At the moment I think the</span>
<span class="cm"> * benefits far, far outweigh the disadvantages.</span>
<span class="cm"> */</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Sometimes we can&#39;t deal with a bio straight away.  We put them in prison</span>
<span class="cm"> * where they can&#39;t cause any mischief.  Bios are put in a cell identified</span>
<span class="cm"> * by a key, multiple bios can be in the same cell.  When the cell is</span>
<span class="cm"> * subsequently unlocked the bios become available.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_prison</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">cell_key</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="k">virtual</span><span class="p">;</span>
	<span class="n">dm_thin_id</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">block</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cell_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">holder</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bio_prison</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">cell_pool</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">nr_buckets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hash_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">cells</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">calc_nr_buckets</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr_cells</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

	<span class="n">nr_cells</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">nr_cells</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nr_cells</span><span class="p">,</span> <span class="mi">8192u</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">nr_cells</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">_cell_cache</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * @nr_cells should be the number of cells you want in use _concurrently_.</span>
<span class="cm"> * Don&#39;t confuse it with the number of distinct keys.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="nf">prison_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr_cells</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">nr_buckets</span> <span class="o">=</span> <span class="n">calc_nr_buckets</span><span class="p">(</span><span class="n">nr_cells</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_prison</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_buckets</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prison</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">nr_cells</span><span class="p">,</span> <span class="n">_cell_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prison</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prison</span><span class="o">-&gt;</span><span class="n">nr_buckets</span> <span class="o">=</span> <span class="n">nr_buckets</span><span class="p">;</span>
	<span class="n">prison</span><span class="o">-&gt;</span><span class="n">hash_mask</span> <span class="o">=</span> <span class="n">nr_buckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">prison</span><span class="o">-&gt;</span><span class="n">cells</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">prison</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_buckets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cells</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">prison</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prison_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">prison</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">hash_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">BIG_PRIME</span> <span class="o">=</span> <span class="mi">4294967291UL</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">*</span> <span class="n">BIG_PRIME</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">hash_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">keys_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	       <span class="k">return</span> <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="k">virtual</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="k">virtual</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="nf">__search_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">cell</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This may block if a new cell needs allocating.  You must ensure that</span>
<span class="cm"> * cells will be unlocked even if the calling thread is blocked.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the cell was already held, 0 if @inmate is the new holder.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bio_detain</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">inmate</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">**</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_key</span><span class="p">(</span><span class="n">prison</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="o">*</span><span class="n">cell2</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hash</span> <span class="o">&gt;</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">nr_buckets</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">cell</span> <span class="o">=</span> <span class="n">__search_bucket</span><span class="p">(</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cells</span> <span class="o">+</span> <span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">,</span> <span class="n">inmate</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a new cell</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cell2</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve been unlocked, so we have to double check that</span>
<span class="cm">	 * nobody else has inserted this cell in the meantime.</span>
<span class="cm">	 */</span>
	<span class="n">cell</span> <span class="o">=</span> <span class="n">__search_bucket</span><span class="p">(</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">cells</span> <span class="o">+</span> <span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">cell2</span><span class="p">,</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">);</span>
		<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">,</span> <span class="n">inmate</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use new cell.</span>
<span class="cm">	 */</span>
	<span class="n">cell</span> <span class="o">=</span> <span class="n">cell2</span><span class="p">;</span>

	<span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span> <span class="o">=</span> <span class="n">prison</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
	<span class="n">cell</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">=</span> <span class="n">inmate</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">cells</span> <span class="o">+</span> <span class="n">hash</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @inmates must have been initialised prior to this call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cell_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">inmates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>

	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inmates</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_list_add</span><span class="p">(</span><span class="n">inmates</span><span class="p">,</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">holder</span><span class="p">);</span>
		<span class="n">bio_list_merge</span><span class="p">(</span><span class="n">inmates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__cell_release</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are a couple of places where we put a bio into a cell briefly</span>
<span class="cm"> * before taking it out again.  In these situations we know that no other</span>
<span class="cm"> * bio may be in the cell.  This function releases the cell, and also does</span>
<span class="cm"> * a sanity check.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cell_release_singleton</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">!=</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">));</span>

	<span class="n">__cell_release</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_release_singleton</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sometimes we don&#39;t want the holder, just the additional bios.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cell_release_no_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">inmates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>

	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">bio_list_merge</span><span class="p">(</span><span class="n">inmates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">prison</span><span class="o">-&gt;</span><span class="n">cell_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_release_no_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">inmates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__cell_release_no_holder</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">inmates</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span> <span class="o">=</span> <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__cell_release</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prison</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * We use the deferred set to keep track of pending reads to shared blocks.</span>
<span class="cm"> * We do this to ensure the new mapping caused by a write isn&#39;t performed</span>
<span class="cm"> * until these prior reads have completed.  Otherwise the insertion of the</span>
<span class="cm"> * new mapping could free the old block that the read bios are mapped to.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">deferred_set</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">deferred_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">deferred_set</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work_items</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">deferred_set</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">current_entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sweeper</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_entry</span> <span class="n">entries</span><span class="p">[</span><span class="n">DEFERRED_SET_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_set</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEFERRED_SET_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="p">;</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">work_items</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">deferred_entry</span> <span class="o">*</span><span class="nf">ds_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_set</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">+</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ds_next</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">DEFERRED_SET_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sweep</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_set</span> <span class="o">*</span><span class="n">ds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span> <span class="o">!=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span><span class="p">].</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span><span class="p">].</span><span class="n">work_items</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span> <span class="o">=</span> <span class="n">ds_next</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span> <span class="o">==</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span><span class="p">].</span><span class="n">work_items</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ds_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="o">--</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">__sweep</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ds</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 1 if deferred or 0 if no pending items to delay job.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ds_add_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_set</span> <span class="o">*</span><span class="n">ds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">next_entry</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">sweeper</span> <span class="o">==</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">].</span><span class="n">work_items</span><span class="p">);</span>
		<span class="n">next_entry</span> <span class="o">=</span> <span class="n">ds_next</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">next_entry</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
			<span class="n">ds</span><span class="o">-&gt;</span><span class="n">current_entry</span> <span class="o">=</span> <span class="n">next_entry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Key building.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">build_data_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_thin_device</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
			   <span class="n">dm_block_t</span> <span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="k">virtual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dm_thin_dev_id</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">build_virtual_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_thin_device</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">b</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="k">virtual</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dm_thin_dev_id</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * A pool device ties together a metadata device and a data device.  It</span>
<span class="cm"> * also provides the interface for creating and destroying internal</span>
<span class="cm"> * devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pool_features</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">zero_new_blocks</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">discard_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">discard_passdown</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pool</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>	<span class="cm">/* Only set if a pool target is bound */</span>

	<span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">pool_md</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">md_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_pool_metadata</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">sectors_per_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_shift</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">offset_mask</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">low_water_blocks</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pool_features</span> <span class="n">pf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">low_water_triggered</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* A dm event has been sent */</span>
	<span class="kt">unsigned</span> <span class="n">no_free_space</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* A -ENOSPC warning has been issued */</span>

	<span class="k">struct</span> <span class="n">bio_prison</span> <span class="o">*</span><span class="n">prison</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_kcopyd_client</span> <span class="o">*</span><span class="n">copier</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">waker</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">ref_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_commit_jiffies</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">deferred_bios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">deferred_flush_bios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">prepared_mappings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">prepared_discards</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">retry_on_resume_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">deferred_set</span> <span class="n">shared_read_ds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_set</span> <span class="n">all_io_ds</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">next_mapping</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">mapping_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">endio_hook_pool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Target context for a pool.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pool_c</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">data_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">metadata_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target_callbacks</span> <span class="n">callbacks</span><span class="p">;</span>

	<span class="n">dm_block_t</span> <span class="n">low_water_blocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_features</span> <span class="n">pf</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Target context for a thin.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">thin_c</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">pool_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">origin_dev</span><span class="p">;</span>
	<span class="n">dm_thin_id</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_device</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * A global list of pools that uses a struct mapped_device as a key.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_thin_pool_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pools</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dm_thin_pool_table</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_table_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">pools</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pool_table_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">pools</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pool_table_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="nf">__pool_table_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">pools</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pool_md</span> <span class="o">==</span> <span class="n">md</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pool</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="nf">__pool_table_lookup_metadata_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">md_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">pools</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">md_dev</span> <span class="o">==</span> <span class="n">md_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pool</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_entry</span> <span class="o">*</span><span class="n">shared_read_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_entry</span> <span class="o">*</span><span class="n">all_io_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">overwrite_mapping</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__requeue_bio_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>
	<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">==</span> <span class="n">tc</span><span class="p">)</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">DM_ENDIO_REQUEUE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">requeue_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__requeue_bio_list</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">__requeue_bio_list</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This section of code contains the logic for processing a thin device&#39;s IO.</span>
<span class="cm"> * Much of the code depends on pool object resources (lists, workqueues, etc)</span>
<span class="cm"> * but most is exclusively called from the thin target rather than the thin-pool</span>
<span class="cm"> * target.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">dm_block_t</span> <span class="nf">get_bio_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&gt;&gt;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&amp;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">offset_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remap_to_origin</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Batch together any FUA/FLUSH bios we find and then issue</span>
<span class="cm">	 * a single commit for them in process_deferred_bios().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_flush_bios</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remap_to_origin_and_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remap_to_origin</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remap_and_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			    <span class="n">dm_block_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remap</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wake_worker() is used when new work is queued and when pool_resume is</span>
<span class="cm"> * ready to continue deferred IO processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Bio endio functions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">quiesced</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">prepared</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pass_discard</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">virt_block</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">data_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="o">*</span><span class="n">cell2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the bio covers the whole area of a block then we can avoid</span>
<span class="cm">	 * zeroing or copying.  Instead this bio is hooked.  The bio will</span>
<span class="cm">	 * still be in the cell, so care has to be taken to avoid issuing</span>
<span class="cm">	 * the bio twice.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="n">bio_end_io_t</span> <span class="o">*</span><span class="n">saved_bi_end_io</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__maybe_add_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">quiesced</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">prepared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_mappings</span><span class="p">);</span>
		<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_complete</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">read_err</span> <span class="o">||</span> <span class="n">write_err</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__maybe_add_mapping</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">overwrite_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">overwrite_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__maybe_add_mapping</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Workqueue.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Prepared mapping jobs.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This sends the bios in the cell back to the deferred_bios list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span>
		       <span class="n">dm_block_t</span> <span class="n">data_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cell_release</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Same as cell_defer above, except it omits one particular detainee,</span>
<span class="cm"> * a write bio that covers the block and has already been processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_defer_except</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cell_release_no_holder</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_prepared_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">saved_bi_end_io</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cell_error</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the prepared block into the mapping btree.</span>
<span class="cm">	 * Any I/O for this block arriving after this point will get</span>
<span class="cm">	 * remapped to it directly.</span>
<span class="cm">	 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_insert_block</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">virt_block</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;dm_thin_insert_block() failed&quot;</span><span class="p">);</span>
		<span class="n">cell_error</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release any bios held while the block was being provisioned.</span>
<span class="cm">	 * If we are processing a write bio that completely covers the block,</span>
<span class="cm">	 * we already processed it so can ignore it now when processing</span>
<span class="cm">	 * the bios in the cell.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cell_defer_except</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cell_defer</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_prepared_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_remove_block</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">virt_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;dm_thin_remove_block() failed&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pass the discard down to the underlying device?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">pass_discard</span><span class="p">)</span>
		<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cell_defer_except</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span><span class="p">);</span>
	<span class="n">cell_defer_except</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cell2</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_prepared</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">maps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">maps</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maps</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maps</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">fn</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deferred bio jobs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_overlaps_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&amp;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">offset_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">==</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">));</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_overwrites_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">io_overlaps_block</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_and_set_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">bio_end_io_t</span> <span class="o">**</span><span class="n">save</span><span class="p">,</span>
			       <span class="n">bio_end_io_t</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">save</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ensure_next_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="nf">get_next_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span><span class="p">);</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">virt_block</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">data_origin</span><span class="p">,</span>
			  <span class="n">dm_block_t</span> <span class="n">data_dest</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">get_next_mapping</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">quiesced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">virt_block</span> <span class="o">=</span> <span class="n">virt_block</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span> <span class="o">=</span> <span class="n">data_dest</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ds_add_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">shared_read_ds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">quiesced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * IO to pool_dev remaps to the pool target&#39;s data_dev.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the whole block of data is being overwritten, we can issue the</span>
<span class="cm">	 * bio immediately. Otherwise we use kcopyd to clone the data first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_overwrites_block</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">h</span><span class="o">-&gt;</span><span class="n">overwrite_mapping</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="n">save_and_set_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">saved_bi_end_io</span><span class="p">,</span> <span class="n">overwrite_endio</span><span class="p">);</span>
		<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">data_dest</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>

		<span class="n">from</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">origin</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">from</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">data_origin</span> <span class="o">*</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>
		<span class="n">from</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>

		<span class="n">to</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">to</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">data_dest</span> <span class="o">*</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>
		<span class="n">to</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_kcopyd_copy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="n">copy_complete</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;dm_kcopyd_copy() failed&quot;</span><span class="p">);</span>
			<span class="n">cell_error</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_internal_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">virt_block</span><span class="p">,</span>
				   <span class="n">dm_block_t</span> <span class="n">data_origin</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">data_dest</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule_copy</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">virt_block</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="p">,</span>
		      <span class="n">data_origin</span><span class="p">,</span> <span class="n">data_dest</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_external_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">virt_block</span><span class="p">,</span>
				   <span class="n">dm_block_t</span> <span class="n">data_dest</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule_copy</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">virt_block</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">,</span>
		      <span class="n">virt_block</span><span class="p">,</span> <span class="n">data_dest</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">virt_block</span><span class="p">,</span>
			  <span class="n">dm_block_t</span> <span class="n">data_block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">get_next_mapping</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">quiesced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">virt_block</span> <span class="o">=</span> <span class="n">virt_block</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the whole block of data is being overwritten or we are not</span>
<span class="cm">	 * zeroing pre-existing data, we can issue the bio immediately.</span>
<span class="cm">	 * Otherwise we use kcopyd to zero the data first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">zero_new_blocks</span><span class="p">)</span>
		<span class="n">process_prepared_mapping</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">io_overwrites_block</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">h</span><span class="o">-&gt;</span><span class="n">overwrite_mapping</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="n">save_and_set_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">saved_bi_end_io</span><span class="p">,</span> <span class="n">overwrite_endio</span><span class="p">);</span>
		<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">data_block</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">to</span><span class="p">;</span>

		<span class="n">to</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">to</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">data_block</span> <span class="o">*</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>
		<span class="n">to</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_kcopyd_zero</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy_complete</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;dm_kcopyd_zero() failed&quot;</span><span class="p">);</span>
			<span class="n">cell_error</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_data_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">free_blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_free_block_count</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_triggered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: reached low water mark, sending event.&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_md</span><span class="p">));</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_triggered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dm_table_event</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">no_free_space</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to commit to see if that will free up some</span>
<span class="cm">			 * more space.</span>
<span class="cm">			 */</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
				      <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_free_block_count</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_blocks</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we still have no space we set a flag to avoid</span>
<span class="cm">			 * doing all this checking and return -ENOSPC.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_blocks</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: no free space available.&quot;</span><span class="p">,</span>
				       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_md</span><span class="p">));</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">pool</span><span class="o">-&gt;</span><span class="n">no_free_space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_alloc_data_block</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we have run out of space, queue bios until the device is</span>
<span class="cm"> * resumed, presumably after having been reloaded with more space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retry_on_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">no_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>
	<span class="n">cell_release</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span>
		<span class="n">retry_on_resume</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="o">*</span><span class="n">cell2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cell_key</span> <span class="n">key</span><span class="p">,</span> <span class="n">key2</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">get_bio_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_thin_lookup_result</span> <span class="n">lookup_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="n">build_virtual_key</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_detain</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_find_block</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lookup_result</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Check nobody is fiddling with this pool block.  This can</span>
<span class="cm">		 * happen if someone&#39;s in the process of breaking sharing</span>
<span class="cm">		 * on this block.</span>
<span class="cm">		 */</span>
		<span class="n">build_data_key</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">lookup_result</span><span class="p">.</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_detain</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">io_overlaps_block</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * IO may still be going to the destination block.  We must</span>
<span class="cm">			 * quiesce before we can do the removal.</span>
<span class="cm">			 */</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">get_next_mapping</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">pass_discard</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">lookup_result</span><span class="p">.</span><span class="n">shared</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">virt_block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">data_block</span> <span class="o">=</span> <span class="n">lookup_result</span><span class="p">.</span><span class="n">block</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">cell2</span> <span class="o">=</span> <span class="n">cell2</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ds_add_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">all_io_ds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_discards</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This path is hit if people are ignoring</span>
<span class="cm">			 * limits-&gt;discard_granularity.  It ignores any</span>
<span class="cm">			 * part of the discard that is in a subsequent</span>
<span class="cm">			 * block.</span>
<span class="cm">			 */</span>
			<span class="n">sector_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">-</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="n">remaining</span> <span class="o">=</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">,</span> <span class="n">remaining</span><span class="p">);</span>

			<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell2</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">lookup_result</span><span class="p">.</span><span class="n">block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENODATA</span>:
		<span class="cm">/*</span>
<span class="cm">		 * It isn&#39;t provisioned, just forget it.</span>
<span class="cm">		 */</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;discard: find block unexpectedly returned %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">break_sharing</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">block</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">cell_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dm_thin_lookup_result</span> <span class="o">*</span><span class="n">lookup_result</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">data_block</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">alloc_data_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_block</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">schedule_internal_copy</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">lookup_result</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span>
				       <span class="n">data_block</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENOSPC</span>:
		<span class="n">no_space</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: alloc_data_block() failed, error = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">cell_error</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_shared_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			       <span class="n">dm_block_t</span> <span class="n">block</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dm_thin_lookup_result</span> <span class="o">*</span><span class="n">lookup_result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cell_key</span> <span class="n">key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If cell is already occupied, then sharing is already in the process</span>
<span class="cm">	 * of being broken so we have nothing further to do here.</span>
<span class="cm">	 */</span>
	<span class="n">build_data_key</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">lookup_result</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_detain</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">break_sharing</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lookup_result</span><span class="p">,</span> <span class="n">cell</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">h</span><span class="o">-&gt;</span><span class="n">shared_read_entry</span> <span class="o">=</span> <span class="n">ds_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">shared_read_ds</span><span class="p">);</span>

		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">lookup_result</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">provision_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">dm_block_t</span> <span class="n">block</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">data_block</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remap empty bios (flushes) immediately, without provisioning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill read bios with zeroes and complete them immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zero_fill_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">alloc_data_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_block</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">)</span>
			<span class="n">schedule_external_copy</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">data_block</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">schedule_zero</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">data_block</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENOSPC</span>:
		<span class="n">no_space</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: alloc_data_block() failed, error = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">cell_error</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">get_bio_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_bio_prison_cell</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cell_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_lookup_result</span> <span class="n">lookup_result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If cell is already occupied, then the block is already</span>
<span class="cm">	 * being provisioned so we have nothing further to do here.</span>
<span class="cm">	 */</span>
	<span class="n">build_virtual_key</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_detain</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_find_block</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lookup_result</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We can release this cell now.  This thread is the only</span>
<span class="cm">		 * one that puts bios into a cell, and we know there were</span>
<span class="cm">		 * no preceding bios.</span>
<span class="cm">		 */</span>
		<span class="cm">/*</span>
<span class="cm">		 * TODO: this will probably have to change when discard goes</span>
<span class="cm">		 * back in.</span>
<span class="cm">		 */</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lookup_result</span><span class="p">.</span><span class="n">shared</span><span class="p">)</span>
			<span class="n">process_shared_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lookup_result</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">remap_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">lookup_result</span><span class="p">.</span><span class="n">block</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENODATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">remap_to_origin_and_issue</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">provision_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">cell</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;dm_thin_find_block() failed, error = %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">cell_release_singleton</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">need_commit_due_to_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jiffies</span> <span class="o">&lt;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">last_commit_jiffies</span> <span class="o">||</span>
	       <span class="n">jiffies</span> <span class="o">&gt;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">last_commit_jiffies</span> <span class="o">+</span> <span class="n">COMMIT_PERIOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_deferred_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">dm_get_mapinfo</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;ve got no free new_mapping structs, and processing</span>
<span class="cm">		 * this bio might require one, we pause until there are some</span>
<span class="cm">		 * prepared mappings to process.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ensure_next_mapping</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span>
			<span class="n">process_discard</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">process_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are any deferred flush bios, we must commit</span>
<span class="cm">	 * the metadata before issuing them.</span>
<span class="cm">	 */</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_flush_bios</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_flush_bios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">need_commit_due_to_time</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span>
			<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">last_commit_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="p">)))</span>
		<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span><span class="p">,</span> <span class="n">worker</span><span class="p">);</span>

	<span class="n">process_prepared</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_mappings</span><span class="p">,</span> <span class="n">process_prepared_mapping</span><span class="p">);</span>
	<span class="n">process_prepared</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_discards</span><span class="p">,</span> <span class="n">process_prepared_discard</span><span class="p">);</span>
	<span class="n">process_deferred_bios</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We want to commit periodically so that not too much</span>
<span class="cm"> * unwritten data builds up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_waker</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">to_delayed_work</span><span class="p">(</span><span class="n">ws</span><span class="p">),</span> <span class="k">struct</span> <span class="n">pool</span><span class="p">,</span> <span class="n">waker</span><span class="p">);</span>
	<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">waker</span><span class="p">,</span> <span class="n">COMMIT_PERIOD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Mapping functions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Called only while mapping a thin bio to hand it over to the workqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">thin_defer_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="nf">thin_hook_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">endio_hook_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">shared_read_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">all_io_entry</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">ds_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">all_io_ds</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">overwrite_mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Non-blocking function called from the thin target&#39;s map function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_bio_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">get_bio_block</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_thin_device</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_lookup_result</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">thin_hook_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_DISCARD</span> <span class="o">|</span> <span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">thin_defer_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_find_block</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that we defer readahead too.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">shared</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have a race condition here between the</span>
<span class="cm">			 * result.shared value returned by the lookup and</span>
<span class="cm">			 * snapshot creation, which may cause new</span>
<span class="cm">			 * sharing.</span>
<span class="cm">			 *</span>
<span class="cm">			 * To avoid this always quiesce the origin before</span>
<span class="cm">			 * taking the snap.  You want to do this anyway to</span>
<span class="cm">			 * ensure a consistent application view</span>
<span class="cm">			 * (i.e. lockfs).</span>
<span class="cm">			 *</span>
<span class="cm">			 * More distant ancestors are irrelevant. The</span>
<span class="cm">			 * shared flag will be set in their case.</span>
<span class="cm">			 */</span>
			<span class="n">thin_defer_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">remap</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">block</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENODATA</span>:
		<span class="cm">/*</span>
<span class="cm">		 * In future, the failed dm_thin_find_block above could</span>
<span class="cm">		 * provide the hint to load the metadata into cache.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span>:
		<span class="n">thin_defer_bio</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_is_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target_callbacks</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bdi_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool_c</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">!</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">bdi_congested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">bdi_bits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__requeue_bios</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * Binding of control targets to a pool object</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bind_control_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If discard_passdown was enabled verify that the data device</span>
<span class="cm">	 * supports discards.  Disable discard_passdown if not; otherwise</span>
<span class="cm">	 * -EOPNOTSUPP will be returned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span> <span class="o">||</span> <span class="o">!</span><span class="n">blk_queue_discard</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
			<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Discard unsupported by data device (%s): Disabling discard passdown.&quot;</span><span class="p">,</span>
			       <span class="n">bdevname</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
			<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unbind_control_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">==</span> <span class="n">ti</span><span class="p">)</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * Pool creation</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="cm">/* Initialize pool features. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_features_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool_features</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">zero_new_blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">discard_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">discard_passdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pool_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__pool_table_remove</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_pool_metadata_close</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_metadata_close() failed.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">prison_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">);</span>
	<span class="n">dm_kcopyd_client_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">endio_hook_pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">_new_mapping_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">_endio_hook_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="nf">pool_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">pool_md</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">metadata_dev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">err_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_pool_metadata</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">dm_pool_metadata_open</span><span class="p">(</span><span class="n">metadata_dev</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating metadata object&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pool</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error allocating memory for pool&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">offset_mask</span> <span class="o">=</span> <span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pool_features_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span> <span class="o">=</span> <span class="n">prison_create</span><span class="p">(</span><span class="n">PRISON_CELLS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating pool&#39;s bio prison&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_prison</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span> <span class="o">=</span> <span class="n">dm_kcopyd_client_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">);</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating pool&#39;s kcopyd client&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_kcopyd_client</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create singlethreaded workqueue that will service all devices</span>
<span class="cm">	 * that use this metadata.</span>
<span class="cm">	 */</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">alloc_ordered_workqueue</span><span class="p">(</span><span class="s">&quot;dm-&quot;</span> <span class="n">DM_MSG_PREFIX</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating pool&#39;s workqueue&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">,</span> <span class="n">do_worker</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">waker</span><span class="p">,</span> <span class="n">do_waker</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_bios</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">deferred_flush_bios</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_mappings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_discards</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_triggered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">no_free_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">retry_on_resume_list</span><span class="p">);</span>
	<span class="n">ds_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">shared_read_ds</span><span class="p">);</span>
	<span class="n">ds_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">all_io_ds</span><span class="p">);</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">next_mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">MAPPING_POOL_SIZE</span><span class="p">,</span>
						      <span class="n">_new_mapping_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating pool&#39;s mapping mempool&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_mapping_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">endio_hook_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">ENDIO_HOOK_POOL_SIZE</span><span class="p">,</span>
							 <span class="n">_endio_hook_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">endio_hook_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating pool&#39;s endio_hook mempool&quot;</span><span class="p">;</span>
		<span class="n">err_p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_endio_hook_pool</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">last_commit_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_md</span> <span class="o">=</span> <span class="n">pool_md</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">md_dev</span> <span class="o">=</span> <span class="n">metadata_dev</span><span class="p">;</span>
	<span class="n">__pool_table_insert</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>

<span class="nl">bad_endio_hook_pool:</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">mapping_pool</span><span class="p">);</span>
<span class="nl">bad_mapping_pool:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="nl">bad_wq:</span>
	<span class="n">dm_kcopyd_client_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">copier</span><span class="p">);</span>
<span class="nl">bad_kcopyd_client:</span>
	<span class="n">prison_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prison</span><span class="p">);</span>
<span class="nl">bad_prison:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="nl">bad_pool:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm_pool_metadata_close</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_metadata_close() failed.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err_p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pool_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pool_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">)</span>
		<span class="n">__pool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="nf">__pool_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">pool_md</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">metadata_dev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">error</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">created</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">__pool_table_lookup_metadata_dev</span><span class="p">(</span><span class="n">metadata_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_md</span> <span class="o">!=</span> <span class="n">pool_md</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="n">__pool_inc</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">__pool_table_lookup</span><span class="p">(</span><span class="n">pool_md</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">md_dev</span> <span class="o">!=</span> <span class="n">metadata_dev</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="n">__pool_inc</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pool</span> <span class="o">=</span> <span class="n">pool_create</span><span class="p">(</span><span class="n">pool_md</span><span class="p">,</span> <span class="n">metadata_dev</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="o">*</span><span class="n">created</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * Pool target methods</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">unbind_control_target</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
	<span class="n">__pool_dec</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">metadata_dev</span><span class="p">);</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_pool_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool_features</span> <span class="o">*</span><span class="n">pf</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">argc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>

	<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_arg</span> <span class="n">_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Invalid number of pool feature arguments&quot;</span><span class="p">},</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * No feature arguments supplied.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_read_arg_group</span><span class="p">(</span><span class="n">_args</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arg_name</span> <span class="o">=</span> <span class="n">dm_shift_arg</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
		<span class="n">argc</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="s">&quot;skip_block_zeroing&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">zero_new_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="s">&quot;ignore_discard&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">discard_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="s">&quot;no_discard_passdown&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">discard_passdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Unrecognised pool feature requested&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * thin-pool &lt;metadata dev&gt; &lt;data dev&gt;</span>
<span class="cm"> *	     &lt;data block size (sectors)&gt;</span>
<span class="cm"> *	     &lt;low water mark (blocks)&gt;</span>
<span class="cm"> *	     [&lt;#feature args&gt; [&lt;arg&gt;]*]</span>
<span class="cm"> *</span>
<span class="cm"> * Optional feature arguments are:</span>
<span class="cm"> *	     skip_block_zeroing: skips the zeroing of newly-provisioned blocks.</span>
<span class="cm"> *	     ignore_discard: disable discard</span>
<span class="cm"> *	     no_discard_passdown: don&#39;t pass discards down to the data device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">pool_created</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_features</span> <span class="n">pf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="n">as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">data_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">low_water_blocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">metadata_dev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">metadata_dev_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME Remove validation from scope of lock.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid argument count&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">as</span><span class="p">.</span><span class="n">argc</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
	<span class="n">as</span><span class="p">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metadata_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error opening metadata block device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">metadata_dev_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">metadata_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">metadata_dev_size</span> <span class="o">&gt;</span> <span class="n">THIN_METADATA_MAX_SECTORS_WARNING</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Metadata device %s is larger than %u sectors: excess space will not be used.&quot;</span><span class="p">,</span>
		       <span class="n">bdevname</span><span class="p">(</span><span class="n">metadata_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">THIN_METADATA_MAX_SECTORS</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error getting data device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_metadata</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_size</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_size</span> <span class="o">||</span>
	    <span class="n">block_size</span> <span class="o">&lt;</span> <span class="n">DATA_DEV_BLOCK_SIZE_MIN_SECTORS</span> <span class="o">||</span>
	    <span class="n">block_size</span> <span class="o">&gt;</span> <span class="n">DATA_DEV_BLOCK_SIZE_MAX_SECTORS</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">block_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid block size&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">low_water_blocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid low water mark&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set default pool features.</span>
<span class="cm">	 */</span>
	<span class="n">pool_features_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="p">);</span>

	<span class="n">dm_consume_args</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">parse_pool_features</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool</span> <span class="o">=</span> <span class="n">__pool_find</span><span class="p">(</span><span class="n">dm_table_get_md</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="n">metadata_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
			   <span class="n">block_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool_created</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_pt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * &#39;pool_created&#39; reflects whether this is the first table load.</span>
<span class="cm">	 * Top level discard support is not allowed to be changed after</span>
<span class="cm">	 * initial load.  This would require a pool reload to trigger thin</span>
<span class="cm">	 * device changes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool_created</span> <span class="o">&amp;&amp;</span> <span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span> <span class="o">!=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Discard support cannot be disabled once enabled&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_flags_changed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">metadata_dev</span> <span class="o">=</span> <span class="n">metadata_dev</span><span class="p">;</span>
	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span> <span class="o">=</span> <span class="n">data_dev</span><span class="p">;</span>
	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span> <span class="o">=</span> <span class="n">low_water_blocks</span><span class="p">;</span>
	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">pf</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only need to enable discards if the pool should pass</span>
<span class="cm">	 * them down to the data device.  The thin device&#39;s discard</span>
<span class="cm">	 * processing will cause mappings to be removed from the btree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Setting &#39;discards_supported&#39; circumvents the normal</span>
<span class="cm">		 * stacking of discard limits (this keeps the pool and</span>
<span class="cm">		 * thin devices&#39; discard limits consistent).</span>
<span class="cm">		 */</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">discards_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">pt</span><span class="p">;</span>

	<span class="n">pt</span><span class="o">-&gt;</span><span class="n">callbacks</span><span class="p">.</span><span class="n">congested_fn</span> <span class="o">=</span> <span class="n">pool_is_congested</span><span class="p">;</span>
	<span class="n">dm_table_add_target_callbacks</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">callbacks</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_flags_changed:</span>
	<span class="n">__pool_dec</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="nl">out_free_pt:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">data_dev</span><span class="p">);</span>
<span class="nl">out_metadata:</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">metadata_dev</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		    <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As this is a singleton target, ti-&gt;begin is always zero.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieves the number of blocks of the data device from</span>
<span class="cm"> * the superblock and compares it to the actual device size,</span>
<span class="cm"> * thus resizing the data device in case it has grown.</span>
<span class="cm"> *</span>
<span class="cm"> * This both copes with opening preallocated data devices in the ctr</span>
<span class="cm"> * being followed by a resume</span>
<span class="cm"> * -and-</span>
<span class="cm"> * calling the resume method individually after userspace has</span>
<span class="cm"> * grown the data device in reaction to a table event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_preresume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">sb_data_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take control of the pool object.</span>
<span class="cm">	 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">bind_control_target</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">data_size</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_data_dev_size</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb_data_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;failed to retrieve data device size&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&lt;</span> <span class="n">sb_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;pool target too small, is %llu blocks (expected %llu)&quot;</span><span class="p">,</span>
		      <span class="n">data_size</span><span class="p">,</span> <span class="n">sb_data_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="n">sb_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_resize_data_dev</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;failed to resize data device&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
			      <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">low_water_triggered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">no_free_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__requeue_bios</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">do_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">waker</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_postsuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">waker</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="cm">/* FIXME: invalidate device? error the next FUA or FLUSH bio ?*/</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_arg_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">args_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="n">args_required</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Message received with %u arguments instead of %u.&quot;</span><span class="p">,</span>
		       <span class="n">argc</span><span class="p">,</span> <span class="n">args_required</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_dev_id</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">dm_thin_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">warning</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kstrtoull</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">*</span><span class="n">dev_id</span> <span class="o">&lt;=</span> <span class="n">MAX_DEV_ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">warning</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Message received with invalid device id: %s&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_create_thin_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_thin_id</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">read_dev_id</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_create_thin</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Creation of new thinly-provisioned device with id %s failed.&quot;</span><span class="p">,</span>
		       <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_create_snap_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_thin_id</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">dm_thin_id</span> <span class="n">origin_dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">read_dev_id</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">read_dev_id</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">origin_dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_create_snap</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="n">origin_dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Creation of new snapshot %s of device %s failed.&quot;</span><span class="p">,</span>
		       <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_delete_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_thin_id</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">read_dev_id</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_delete_thin_device</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Deletion of thin device %s failed.&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_set_transaction_id_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_thin_id</span> <span class="n">old_id</span><span class="p">,</span> <span class="n">new_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">old_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;set_transaction_id message: Unrecognised id %s.&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">new_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;set_transaction_id message: Unrecognised new id %s.&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_set_metadata_transaction_id</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">old_id</span><span class="p">,</span> <span class="n">new_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Failed to change transaction id from %s to %s.&quot;</span><span class="p">,</span>
		       <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_reserve_metadata_snap_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_reserve_metadata_snap</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;reserve_metadata_snap message failed.&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_release_metadata_snap_mesg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">check_arg_count</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_release_metadata_snap</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;release_metadata_snap message failed.&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Messages supported:</span>
<span class="cm"> *   create_thin	&lt;dev_id&gt;</span>
<span class="cm"> *   create_snap	&lt;dev_id&gt; &lt;origin_id&gt;</span>
<span class="cm"> *   delete		&lt;dev_id&gt;</span>
<span class="cm"> *   trim		&lt;dev_id&gt; &lt;new_size_in_sectors&gt;</span>
<span class="cm"> *   set_transaction_id &lt;current_trans_id&gt; &lt;new_trans_id&gt;</span>
<span class="cm"> *   reserve_metadata_snap</span>
<span class="cm"> *   release_metadata_snap</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;create_thin&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_create_thin_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;create_snap&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_create_snap_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;delete&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_delete_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;set_transaction_id&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_set_transaction_id_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;reserve_metadata_snap&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_reserve_metadata_snap_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;release_metadata_snap&quot;</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process_release_metadata_snap_mesg</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>

	<span class="k">else</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Unrecognised thin pool target message received: %s&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_commit_metadata</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s message: dm_pool_commit_metadata() failed, error = %d&quot;</span><span class="p">,</span>
			      <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Status line is:</span>
<span class="cm"> *    &lt;transaction id&gt; &lt;used metadata sectors&gt;/&lt;total metadata sectors&gt;</span>
<span class="cm"> *    &lt;used data sectors&gt;/&lt;total data sectors&gt; &lt;held metadata root&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">transaction_id</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">nr_free_blocks_data</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">nr_free_blocks_metadata</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">nr_blocks_data</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">nr_blocks_metadata</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">held_root</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">buf2</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_metadata_transaction_id</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">transaction_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_free_metadata_block_count</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">nr_free_blocks_metadata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_metadata_dev_size</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_blocks_metadata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_free_block_count</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">nr_free_blocks_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_data_dev_size</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_blocks_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_get_metadata_snap</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">held_root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu %llu/%llu %llu/%llu &quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">transaction_id</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nr_blocks_metadata</span> <span class="o">-</span> <span class="n">nr_free_blocks_metadata</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nr_blocks_metadata</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nr_blocks_data</span> <span class="o">-</span> <span class="n">nr_free_blocks_data</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nr_blocks_data</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">held_root</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="n">held_root</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s %s %lu %llu &quot;</span><span class="p">,</span>
		       <span class="n">format_dev_t</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">metadata_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">),</span>
		       <span class="n">format_dev_t</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">low_water_blocks</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">=</span> <span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">zero_new_blocks</span> <span class="o">+</span> <span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span> <span class="o">+</span>
			<span class="o">!</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span><span class="p">;</span>
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%u &quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">zero_new_blocks</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;skip_block_zeroing &quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;ignore_discard &quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_passdown</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;no_discard_passdown &quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				<span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pool_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="o">*</span><span class="n">bvm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">biovec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max_size</span><span class="p">;</span>

	<span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">data_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bvm</span><span class="p">,</span> <span class="n">biovec</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_discard_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: these limits may be incompatible with the pool&#39;s data device</span>
<span class="cm">	 */</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is just a hint, and not enforced.  We have to cope with</span>
<span class="cm">	 * bios that overlap 2 blocks.</span>
<span class="cm">	 */</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">zero_new_blocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_io_hints</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pool_c</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">blk_limits_io_min</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">blk_limits_io_opt</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span><span class="p">)</span>
		<span class="n">set_discard_limits</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">limits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">pool_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;thin-pool&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">DM_TARGET_SINGLETON</span> <span class="o">|</span> <span class="n">DM_TARGET_ALWAYS_WRITEABLE</span> <span class="o">|</span>
		    <span class="n">DM_TARGET_IMMUTABLE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">pool_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span> <span class="o">=</span> <span class="n">pool_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">pool_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postsuspend</span> <span class="o">=</span> <span class="n">pool_postsuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">preresume</span> <span class="o">=</span> <span class="n">pool_preresume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pool_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">pool_message</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">pool_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">merge</span> <span class="o">=</span> <span class="n">pool_merge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">pool_iterate_devices</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_hints</span> <span class="o">=</span> <span class="n">pool_io_hints</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * Thin target methods</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">thin_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">__pool_dec</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">dm_pool_close_thin_device</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">);</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">)</span>
		<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Thin target parameters:</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;pool_dev&gt; &lt;dev_id&gt; [origin_dev]</span>
<span class="cm"> *</span>
<span class="cm"> * pool_dev: the path to the pool (eg, /dev/mapper/my_pool)</span>
<span class="cm"> * dev_id: the internal device identifier</span>
<span class="cm"> * origin_dev: a device external to the pool that should act as the origin</span>
<span class="cm"> *</span>
<span class="cm"> * If the pool device has discards disabled, they get disabled for the thin</span>
<span class="cm"> * device as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">pool_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">origin_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">pool_md</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid argument count&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Out of memory&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">FMODE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">origin_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error opening origin device&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_origin_dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span> <span class="o">=</span> <span class="n">origin_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">pool_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error opening pool device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_pool_dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span> <span class="o">=</span> <span class="n">pool_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_dev_id</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid device id&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_common</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pool_md</span> <span class="o">=</span> <span class="n">dm_get_md</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool_md</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t get pool mapped device&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_common</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">__pool_table_lookup</span><span class="p">(</span><span class="n">pool_md</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t find pool object&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_pool_lookup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__pool_inc</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_pool_open_thin_device</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t open thin internal device&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_thin_open</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* In case the pool supports discards, pass them on. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">discard_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">discards_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dm_put</span><span class="p">(</span><span class="n">pool_md</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_thin_open:</span>
	<span class="n">__pool_dec</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>
<span class="nl">bad_pool_lookup:</span>
	<span class="n">dm_put</span><span class="p">(</span><span class="n">pool_md</span><span class="p">);</span>
<span class="nl">bad_common:</span>
	<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="p">);</span>
<span class="nl">bad_pool_dev:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">)</span>
		<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">);</span>
<span class="nl">bad_origin_dev:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dm_thin_pool_table</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		    <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">dm_target_offset</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">thin_bio_map</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">map_context</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span>
		      <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_endio_hook</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_thin_new_mapping</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">shared_read_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">ds_dec</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">shared_read_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">quiesced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">__maybe_add_mapping</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">all_io_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">ds_dec</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">all_io_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">prepared_discards</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">endio_hook_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">thin_postsuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm_noflush_suspending</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span>
		<span class="n">requeue_io</span><span class="p">((</span><span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="p">)</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &lt;nr mapped sectors&gt; &lt;highest mapped sector&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dm_block_t</span> <span class="n">mapped</span><span class="p">,</span> <span class="n">highest</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">)</span>
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
			<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_get_mapped_count</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapped</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

			<span class="n">r</span> <span class="o">=</span> <span class="n">dm_thin_get_highest_mapped_block</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">highest</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu &quot;</span><span class="p">,</span> <span class="n">mapped</span> <span class="o">*</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">highest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
						<span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s %lu&quot;</span><span class="p">,</span>
			       <span class="n">format_dev_t</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="p">)</span>
				<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">format_dev_t</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">origin_dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">thin_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				<span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_block_t</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t call dm_pool_get_data_dev_size() since that blocks.  So</span>
<span class="cm">	 * we follow a more convoluted path through to the pool&#39;s target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* nothing is bound */</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">*</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">thin_io_hints</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thin_c</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">blk_limits_io_min</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">blk_limits_io_opt</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sectors_per_block</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">);</span>
	<span class="n">set_discard_limits</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">limits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">thin_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;thin&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">thin_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span> <span class="o">=</span> <span class="n">thin_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">thin_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end_io</span> <span class="o">=</span> <span class="n">thin_endio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postsuspend</span> <span class="o">=</span> <span class="n">thin_postsuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">thin_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">thin_iterate_devices</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_hints</span> <span class="o">=</span> <span class="n">thin_io_hints</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dm_thin_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pool_table_init</span><span class="p">();</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thin_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_pool_target</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">_cell_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_bio_prison_cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_cell_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_cell_cache</span><span class="p">;</span>

	<span class="n">_new_mapping_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_thin_new_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_new_mapping_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_new_mapping_cache</span><span class="p">;</span>

	<span class="n">_endio_hook_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_thin_endio_hook</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_endio_hook_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_endio_hook_cache</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_endio_hook_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_new_mapping_cache</span><span class="p">);</span>
<span class="nl">bad_new_mapping_cache:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_cell_cache</span><span class="p">);</span>
<span class="nl">bad_cell_cache:</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_target</span><span class="p">);</span>
<span class="nl">bad_pool_target:</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thin_target</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_thin_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thin_target</span><span class="p">);</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_target</span><span class="p">);</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_cell_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_new_mapping_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_endio_hook_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dm_thin_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dm_thin_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DM_NAME</span> <span class="s">&quot; thin provisioning target&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Joe Thornber &lt;dm-devel@redhat.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
