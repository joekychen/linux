<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-raid1.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-raid1.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003 Sistina Software Limited.</span>
<span class="cm"> * Copyright (C) 2005-2008 Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;dm-bio-record.h&quot;</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/device-mapper.h&gt;</span>
<span class="cp">#include &lt;linux/dm-io.h&gt;</span>
<span class="cp">#include &lt;linux/dm-dirty-log.h&gt;</span>
<span class="cp">#include &lt;linux/dm-kcopyd.h&gt;</span>
<span class="cp">#include &lt;linux/dm-region-hash.h&gt;</span>

<span class="cp">#define DM_MSG_PREFIX &quot;raid1&quot;</span>

<span class="cp">#define MAX_RECOVERY 1	</span><span class="cm">/* Maximum number of regions recovered in parallel. */</span><span class="cp"></span>

<span class="cp">#define DM_RAID1_HANDLE_ERRORS 0x01</span>
<span class="cp">#define errors_handled(p)	((p)-&gt;features &amp; DM_RAID1_HANDLE_ERRORS)</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">_kmirrord_recovery_stopped</span><span class="p">);</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Mirror set structures.</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">enum</span> <span class="n">dm_raid1_error</span> <span class="p">{</span>
	<span class="n">DM_RAID1_WRITE_ERROR</span><span class="p">,</span>
	<span class="n">DM_RAID1_FLUSH_ERROR</span><span class="p">,</span>
	<span class="n">DM_RAID1_SYNC_ERROR</span><span class="p">,</span>
	<span class="n">DM_RAID1_READ_ERROR</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mirror</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">error_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mirror_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="kt">uint64_t</span> <span class="n">features</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* protects the lists */</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">reads</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">writes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">failures</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">holds</span><span class="p">;</span>	<span class="cm">/* bios are waiting until suspend */</span>

	<span class="k">struct</span> <span class="n">dm_region_hash</span> <span class="o">*</span><span class="n">rh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_kcopyd_client</span> <span class="o">*</span><span class="n">kcopyd_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_client</span> <span class="o">*</span><span class="n">io_client</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">read_record_pool</span><span class="p">;</span>

	<span class="cm">/* recovery */</span>
	<span class="n">region_t</span> <span class="n">nr_regions</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in_sync</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">log_failure</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leg_failure</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">suspend</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">default_mirror</span><span class="p">;</span>	<span class="cm">/* Default mirror */</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">kmirrord_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">kmirrord_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_pending</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">trigger_event</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">nr_mirrors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="n">mirror</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_mirrord</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delayed_wake_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer_pending</span><span class="p">);</span>
	<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delayed_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer_pending</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ms</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">delayed_wake_fn</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_all_recovery_waiters</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_kmirrord_recovery_stopped</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">should_wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">;</span>

	<span class="n">bl</span> <span class="o">=</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">writes</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">reads</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">should_wake</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="n">bl</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_wake</span><span class="p">)</span>
		<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dispatch_bios</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bio_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="n">bio_list</span><span class="p">)))</span>
		<span class="n">queue_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MIN_READ_RECORDS 20</span>
<span class="k">struct</span> <span class="n">dm_raid1_read_record</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_bio_details</span> <span class="n">details</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">_dm_raid1_read_record_cache</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Every mirror should look like this one.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_MIRROR 0</span>

<span class="cm">/*</span>
<span class="cm"> * This is yucky.  We squirrel the mirror struct away inside</span>
<span class="cm"> * bi_next for read/write buffers.  This is safe since the bh</span>
<span class="cm"> * doesn&#39;t get submitted to the lower levels of block layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="nf">bio_get_m</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="p">)</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_set_m</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">)</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="nf">get_default_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">default_mirror</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_default_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">default_mirror</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">m0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="nf">get_valid_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span> <span class="o">+</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fail_mirror</span>
<span class="cm"> * @m: mirror device to fail</span>
<span class="cm"> * @error_type: one of the enum&#39;s, DM_RAID1_*_ERROR</span>
<span class="cm"> *</span>
<span class="cm"> * If errors are being handled, record the type of</span>
<span class="cm"> * error encountered for this device.  If this type</span>
<span class="cm"> * of error has already been recorded, we can return;</span>
<span class="cm"> * otherwise, we must signal userspace by triggering</span>
<span class="cm"> * an event.  Additionally, if the device is the</span>
<span class="cm"> * primary device, we must choose a new primary, but</span>
<span class="cm"> * only if the mirror is in-sync.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must not block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fail_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dm_raid1_error</span> <span class="n">error_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">leg_failure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * error_count is used for nothing more than a</span>
<span class="cm">	 * simple way to tell if a device has encountered</span>
<span class="cm">	 * errors.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">error_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">in_sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Better to issue requests to same failing device</span>
<span class="cm">		 * than to risk returning corrupt data.</span>
<span class="cm">		 */</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Primary mirror (%s) failed while out-of-sync: &quot;</span>
		      <span class="s">&quot;Reads may fail.&quot;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">get_valid_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">set_default_mirror</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;All sides of mirror have failed.&quot;</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">trigger_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_bits</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">io</span><span class="p">[</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_request</span> <span class="n">io_req</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">WRITE_FLUSH</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_IO_KMEM</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error_bits</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dm_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_req</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_bits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_bits</span><span class="p">))</span>
				<span class="n">fail_mirror</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					    <span class="n">DM_RAID1_FLUSH_ERROR</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Recovery.</span>
<span class="cm"> *</span>
<span class="cm"> * When a mirror is first activated we may find that some regions</span>
<span class="cm"> * are in the no-sync state.  We have to recover these by</span>
<span class="cm"> * recopying from the default mirror to all the others.</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">recovery_complete</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_err</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_region</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">dm_rh_region_context</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read error means the failure of default mirror. */</span>
		<span class="n">DMERR_LIMIT</span><span class="p">(</span><span class="s">&quot;Unable to read primary mirror during recovery&quot;</span><span class="p">);</span>
		<span class="n">fail_mirror</span><span class="p">(</span><span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">),</span> <span class="n">DM_RAID1_SYNC_ERROR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR_LIMIT</span><span class="p">(</span><span class="s">&quot;Write error during recovery (error = 0x%lx)&quot;</span><span class="p">,</span>
			    <span class="n">write_err</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bits correspond to devices (excluding default mirror).</span>
<span class="cm">		 * The default mirror cannot change during recovery.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_err</span><span class="p">))</span>
				<span class="n">fail_mirror</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span>
					    <span class="n">DM_RAID1_SYNC_ERROR</span><span class="p">);</span>
			<span class="n">bit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dm_rh_recovery_end</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">read_err</span> <span class="o">||</span> <span class="n">write_err</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">[</span><span class="n">DM_KCOPYD_MAX_REGIONS</span><span class="p">],</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">region_t</span> <span class="n">key</span> <span class="o">=</span> <span class="n">dm_rh_get_region_key</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">region_size</span> <span class="o">=</span> <span class="n">dm_rh_get_region_size</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="cm">/* fill in the source */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="n">from</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">from</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dm_rh_region_to_sector</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_regions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The final region may be smaller than</span>
<span class="cm">		 * region_size.</span>
<span class="cm">		 */</span>
		<span class="n">from</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">region_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">from</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
			<span class="n">from</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">region_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">from</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">region_size</span><span class="p">;</span>

	<span class="cm">/* fill in the destinations */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">m</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dm_rh_region_to_sector</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">from</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* hand to kcopyd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">DM_KCOPYD_IGNORE_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_kcopyd_copy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span>
			   <span class="n">flags</span><span class="p">,</span> <span class="n">recovery_complete</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start quiescing some regions.</span>
<span class="cm">	 */</span>
	<span class="n">dm_rh_recovery_prepare</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy any already quiesced regions.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">reg</span> <span class="o">=</span> <span class="n">dm_rh_recovery_start</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">recover</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">dm_rh_recovery_end</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the in sync flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">get_sync_count</span><span class="p">(</span><span class="n">log</span><span class="p">)</span> <span class="o">==</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_regions</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* the sync is complete */</span>
		<span class="n">dm_table_event</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
		<span class="n">ms</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Reads</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="nf">choose_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">m</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span> <span class="o">==</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">+=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">));</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">default_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">default_mirror</span> <span class="o">=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_mirror</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="n">region_t</span> <span class="n">region</span> <span class="o">=</span> <span class="n">dm_rh_bio_to_region</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">in_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">choose_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span>  <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remap a buffer to a particular mirror.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">map_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dm_target_offset</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">map_sector</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_io_region</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">=</span> <span class="n">map_sector</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hold_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lock is required to avoid race condition during suspend</span>
<span class="cm">	 * process.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If device is suspended, complete the bio.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_noflush_suspending</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">))</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">DM_ENDIO_REQUEUE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hold bio until the suspend is complete.</span>
<span class="cm">	 */</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">holds</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Reads</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_callback</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">bio_get_m</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">bio_set_m</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fail_mirror</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">DM_RAID1_READ_ERROR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">default_ok</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">||</span> <span class="n">mirror_available</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN_LIMIT</span><span class="p">(</span><span class="s">&quot;Read failure on mirror device %s.  &quot;</span>
			     <span class="s">&quot;Trying alternative device.&quot;</span><span class="p">,</span>
			     <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">queue_bio</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DMERR_LIMIT</span><span class="p">(</span><span class="s">&quot;Read failure on mirror device %s.  Failing I/O.&quot;</span><span class="p">,</span>
		    <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Asynchronous read. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_async_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">io</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_request</span> <span class="n">io_req</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">READ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_IO_BVEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span><span class="p">,</span>
		<span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">read_callback</span><span class="p">,</span>
		<span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">bio</span><span class="p">,</span>
		<span class="p">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">map_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">bio_set_m</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dm_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_req</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">region_in_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="n">region_t</span> <span class="n">region</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">may_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">dm_rh_get_state</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">may_block</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">state</span> <span class="o">==</span> <span class="n">DM_RH_CLEAN</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">DM_RH_DIRTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_reads</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">reads</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">region_t</span> <span class="n">region</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="n">reads</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">dm_rh_bio_to_region</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can only read balance if the region is in sync.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">region_in_sync</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">choose_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">))</span>
			<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="n">read_async_bio</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Writes.</span>
<span class="cm"> *</span>
<span class="cm"> * We do different things with the write io depending on the</span>
<span class="cm"> * state of the region that it&#39;s in:</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC: 	increment pending, use kcopyd to write to *all* mirrors</span>
<span class="cm"> * RECOVERING:	delay the io until recovery completes</span>
<span class="cm"> * NOSYNC:	increment pending, just write to the default mirror</span>
<span class="cm"> *---------------------------------------------------------------*/</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_callback</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">)</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">should_wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ms</span> <span class="o">=</span> <span class="n">bio_get_m</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">;</span>
	<span class="n">bio_set_m</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: We don&#39;t decrement the pending count here,</span>
<span class="cm">	 * instead it is done by the targets endio function.</span>
<span class="cm">	 * This way we handle both writes to SYNC and NOSYNC</span>
<span class="cm">	 * regions with the same code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">))</span>
			<span class="n">fail_mirror</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">DM_RAID1_WRITE_ERROR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to raise event.  Since raising</span>
<span class="cm">	 * events can block, we need to do it in</span>
<span class="cm">	 * the main thread.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="n">should_wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_wake</span><span class="p">)</span>
		<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_region</span> <span class="n">io</span><span class="p">[</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">],</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_io_request</span> <span class="n">io_req</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">WRITE_FLUSH_FUA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_IO_BVEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span><span class="p">,</span>
		<span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">write_callback</span><span class="p">,</span>
		<span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">bio</span><span class="p">,</span>
		<span class="p">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="p">.</span><span class="n">bi_rw</span> <span class="o">|=</span> <span class="n">REQ_DISCARD</span><span class="p">;</span>
		<span class="n">io_req</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_IO_KMEM</span><span class="p">;</span>
		<span class="n">io_req</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span>
		<span class="n">map_region</span><span class="p">(</span><span class="n">dest</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use default mirror because we only need it to retrieve the reference</span>
<span class="cm">	 * to the mirror set in write_callback().</span>
<span class="cm">	 */</span>
	<span class="n">bio_set_m</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">));</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dm_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_req</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">writes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">sync</span><span class="p">,</span> <span class="n">nosync</span><span class="p">,</span> <span class="n">recover</span><span class="p">,</span> <span class="o">*</span><span class="n">this_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">requeue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="n">region_t</span> <span class="n">region</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writes</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Classify each write.</span>
<span class="cm">	 */</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nosync</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recover</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">requeue</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="n">writes</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">region</span> <span class="o">=</span> <span class="n">dm_rh_bio_to_region</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">is_remote_recovering</span> <span class="o">&amp;&amp;</span>
		    <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">is_remote_recovering</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">region</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">requeue</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">state</span> <span class="o">=</span> <span class="n">dm_rh_get_state</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DM_RH_CLEAN</span>:
		<span class="k">case</span> <span class="n">DM_RH_DIRTY</span>:
			<span class="n">this_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sync</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DM_RH_NOSYNC</span>:
			<span class="n">this_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nosync</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DM_RH_RECOVERING</span>:
			<span class="n">this_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">recover</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bio_list_add</span><span class="p">(</span><span class="n">this_list</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add bios that are delayed due to remote recovery</span>
<span class="cm">	 * back on to the write queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">requeue</span><span class="p">.</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">writes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">requeue</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">delayed_wake</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Increment the pending counts for any regions that will</span>
<span class="cm">	 * be written to (writes to recover regions are going to</span>
<span class="cm">	 * be delayed).</span>
<span class="cm">	 */</span>
	<span class="n">dm_rh_inc_pending</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sync</span><span class="p">);</span>
	<span class="n">dm_rh_inc_pending</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nosync</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the flush fails on a previous call and succeeds here,</span>
<span class="cm">	 * we must not reset the log_failure variable.  We need</span>
<span class="cm">	 * userspace interaction to do that.</span>
<span class="cm">	 */</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">log_failure</span> <span class="o">=</span> <span class="n">dm_rh_flush</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">log_failure</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dispatch io.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">log_failure</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">bio_list_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sync</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="p">)))</span>
			<span class="n">do_write</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recover</span><span class="p">)))</span>
		<span class="n">dm_rh_delay</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nosync</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">leg_failure</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">map_bio</span><span class="p">(</span><span class="n">get_default_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">),</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_failures</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">failures</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">failures</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the log has failed, unattempted writes are being</span>
<span class="cm">	 * put on the holds list.  We can&#39;t issue those writes</span>
<span class="cm">	 * until a log has been marked, so we must store them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a &#39;noflush&#39; suspend is in progress, we can requeue</span>
<span class="cm">	 * the I/O&#39;s to the core.  This give userspace a chance</span>
<span class="cm">	 * to reconfigure the mirror, at which point the core</span>
<span class="cm">	 * will reissue the writes.  If the &#39;noflush&#39; flag is</span>
<span class="cm">	 * not set, we have no choice but to return errors.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some writes on the failures list may have been</span>
<span class="cm">	 * submitted before the log failure and represent a</span>
<span class="cm">	 * failure to write to one of the devices.  It is ok</span>
<span class="cm">	 * for us to treat them the same and requeue them</span>
<span class="cm">	 * as well.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="n">failures</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">log_failure</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ms</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dm_rh_mark_nosync</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If all the legs are dead, fail the I/O.</span>
<span class="cm">		 * If we have been told to handle errors, hold the bio</span>
<span class="cm">		 * and wait for userspace to deal with the problem.</span>
<span class="cm">		 * Otherwise pretend that the I/O succeeded. (This would</span>
<span class="cm">		 * be wrong if the failed leg returned after reboot and</span>
<span class="cm">		 * got replicated back to the good legs.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_valid_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">))</span>
			<span class="n">hold_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trigger_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mirror_set</span><span class="p">,</span> <span class="n">trigger_event</span><span class="p">);</span>

	<span class="n">dm_table_event</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * kmirrord</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mirror_set</span><span class="p">,</span>
					     <span class="n">kmirrord_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">reads</span><span class="p">,</span> <span class="n">writes</span><span class="p">,</span> <span class="n">failures</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reads</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">reads</span><span class="p">;</span>
	<span class="n">writes</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">writes</span><span class="p">;</span>
	<span class="n">failures</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">writes</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dm_rh_update_states</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">errors_handled</span><span class="p">(</span><span class="n">ms</span><span class="p">));</span>
	<span class="n">do_recovery</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="n">do_reads</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">do_writes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writes</span><span class="p">);</span>
	<span class="n">do_failures</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">failures</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Target functions</span>
<span class="cm"> *---------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="nf">alloc_context</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_mirrors</span><span class="p">,</span>
					<span class="kt">uint32_t</span> <span class="n">region_size</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">dl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ms</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">nr_mirrors</span><span class="p">);</span>

	<span class="n">ms</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate mirror context&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">writes</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">failures</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">holds</span><span class="p">);</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span> <span class="o">=</span> <span class="n">nr_mirrors</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_regions</span> <span class="o">=</span> <span class="n">dm_sector_div_up</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">region_size</span><span class="p">);</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">log_failure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">leg_failure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">default_mirror</span><span class="p">,</span> <span class="n">DEFAULT_MIRROR</span><span class="p">);</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">MIN_READ_RECORDS</span><span class="p">,</span>
						<span class="n">_dm_raid1_read_record_cache</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating mirror read_record_pool&quot;</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span> <span class="o">=</span> <span class="n">dm_io_client_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating dm_io client&quot;</span><span class="p">;</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
 		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span> <span class="o">=</span> <span class="n">dm_region_hash_create</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">dispatch_bios</span><span class="p">,</span> <span class="n">wakeup_mirrord</span><span class="p">,</span>
				       <span class="n">wakeup_all_recovery_waiters</span><span class="p">,</span>
				       <span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">,</span> <span class="n">MAX_RECOVERY</span><span class="p">,</span>
				       <span class="n">dl</span><span class="p">,</span> <span class="n">region_size</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_regions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating dirty region hash&quot;</span><span class="p">;</span>
		<span class="n">dm_io_client_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">);</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ms</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span>
		<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dm_io_client_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">io_client</span><span class="p">);</span>
	<span class="n">dm_region_hash_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mirror</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;%llu%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid offset&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span>
			  <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">mirror</span><span class="p">].</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Device lookup failure&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">mirror</span><span class="p">].</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ms</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">mirror</span><span class="p">].</span><span class="n">error_count</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">mirror</span><span class="p">].</span><span class="n">error_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">mirror</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create dirty log: log_type #log_params &lt;log_params&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="nf">create_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="o">*</span><span class="n">args_used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">param_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">dl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Insufficient mirror log arguments&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;%u%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid mirror log argument count&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">args_used</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">param_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">args_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Insufficient mirror log arguments&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dl</span> <span class="o">=</span> <span class="n">dm_dirty_log_create</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ti</span><span class="p">,</span> <span class="n">mirror_flush</span><span class="p">,</span> <span class="n">param_count</span><span class="p">,</span>
				 <span class="n">argv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating mirror dirty log&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="o">*</span><span class="n">args_used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">num_features</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="o">*</span><span class="n">args_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;%u%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_features</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid number of features&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">argc</span><span class="o">--</span><span class="p">;</span>
	<span class="n">argv</span><span class="o">++</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">args_used</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_features</span> <span class="o">&gt;</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Not enough arguments to support feature count&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;handle_errors&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">ms</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">DM_RAID1_HANDLE_ERRORS</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Unrecognised feature requested&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">args_used</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct a mirror mapping:</span>
<span class="cm"> *</span>
<span class="cm"> * log_type #log_params &lt;log_params&gt;</span>
<span class="cm"> * #mirrors [mirror_path offset]{2,}</span>
<span class="cm"> * [#features &lt;features&gt;]</span>
<span class="cm"> *</span>
<span class="cm"> * log_type is &quot;core&quot; or &quot;disk&quot;</span>
<span class="cm"> * #log_params is between 1 and 3</span>
<span class="cm"> *</span>
<span class="cm"> * If present, features must be &quot;handle_errors&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_mirrors</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">args_used</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">dl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">dl</span> <span class="o">=</span> <span class="n">create_dirty_log</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args_used</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">argv</span> <span class="o">+=</span> <span class="n">args_used</span><span class="p">;</span>
	<span class="n">argc</span> <span class="o">-=</span> <span class="n">args_used</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argc</span> <span class="o">||</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;%u%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_mirrors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">nr_mirrors</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">nr_mirrors</span> <span class="o">&gt;</span> <span class="n">DM_KCOPYD_MAX_REGIONS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid number of mirrors&quot;</span><span class="p">;</span>
		<span class="n">dm_dirty_log_destroy</span><span class="p">(</span><span class="n">dl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">argv</span><span class="o">++</span><span class="p">,</span> <span class="n">argc</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="n">nr_mirrors</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Too few mirror arguments&quot;</span><span class="p">;</span>
		<span class="n">dm_dirty_log_destroy</span><span class="p">(</span><span class="n">dl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span> <span class="o">=</span> <span class="n">alloc_context</span><span class="p">(</span><span class="n">nr_mirrors</span><span class="p">,</span> <span class="n">dl</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">get_region_size</span><span class="p">(</span><span class="n">dl</span><span class="p">),</span> <span class="n">ti</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dm_dirty_log_destroy</span><span class="p">(</span><span class="n">dl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the mirror parameter sets */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">get_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_context</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">argv</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">argc</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">ms</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">split_io</span> <span class="o">=</span> <span class="n">dm_rh_get_region_size</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;kmirrord&quot;</span><span class="p">,</span>
					  <span class="n">WQ_NON_REENTRANT</span> <span class="o">|</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;couldn&#39;t start kmirrord&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_context</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_work</span><span class="p">,</span> <span class="n">do_mirror</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">trigger_event</span><span class="p">,</span> <span class="n">trigger_event</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">parse_features</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args_used</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_destroy_wq</span><span class="p">;</span>

	<span class="n">argv</span> <span class="o">+=</span> <span class="n">args_used</span><span class="p">;</span>
	<span class="n">argc</span> <span class="o">-=</span> <span class="n">args_used</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any read-balancing addition depends on the</span>
<span class="cm">	 * DM_RAID1_HANDLE_ERRORS flag being present.</span>
<span class="cm">	 * This is because the decision to balance depends</span>
<span class="cm">	 * on the sync state of a region.  If the above</span>
<span class="cm">	 * flag is not present, we ignore errors; and</span>
<span class="cm">	 * the sync state may be inaccurate.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Too many mirror arguments&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_destroy_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span> <span class="o">=</span> <span class="n">dm_kcopyd_client_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_destroy_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wakeup_mirrord</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_destroy_wq:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">);</span>
<span class="nl">err_free_context:</span>
	<span class="n">free_context</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mirror_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">);</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">trigger_event</span><span class="p">);</span>
	<span class="n">dm_kcopyd_client_destroy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kcopyd_client</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">);</span>
	<span class="n">free_context</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mirror mapping function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		      <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_raid1_read_record</span> <span class="o">*</span><span class="n">read_record</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save region for mirror_end_io() handler */</span>
		<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ll</span> <span class="o">=</span> <span class="n">dm_rh_bio_to_region</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">queue_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">in_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">dm_rh_bio_to_region</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">bio</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If region is not in-sync queue the bio.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">||</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READA</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>

		<span class="n">queue_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The region is in-sync and we can perform reads directly.</span>
<span class="cm">	 * Store enough information so we can retry if it fails.</span>
<span class="cm">	 */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">choose_mirror</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">read_record</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">read_record</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dm_bio_record</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_record</span><span class="o">-&gt;</span><span class="n">details</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">read_record</span><span class="p">;</span>
		<span class="n">read_record</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_bio</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_bio_details</span> <span class="o">*</span><span class="n">bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_raid1_read_record</span> <span class="o">*</span><span class="n">read_record</span> <span class="o">=</span> <span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to dec pending if this was a write.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">))</span>
			<span class="n">dm_rh_dec</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">,</span> <span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ll</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_RAHEAD</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_record</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * There wasn&#39;t enough memory to record necessary</span>
<span class="cm">			 * information for a retry or there was no other</span>
<span class="cm">			 * mirror in-sync.</span>
<span class="cm">			 */</span>
			<span class="n">DMERR_LIMIT</span><span class="p">(</span><span class="s">&quot;Mirror read failed.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">m</span> <span class="o">=</span> <span class="n">read_record</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>

		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Mirror read failed from %s. Trying alternative device.&quot;</span><span class="p">,</span>
		      <span class="n">m</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">fail_mirror</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">DM_RAID1_READ_ERROR</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * A failed read is requeued for another attempt using an intact</span>
<span class="cm">		 * mirror.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">default_ok</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">||</span> <span class="n">mirror_available</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">read_record</span><span class="o">-&gt;</span><span class="n">details</span><span class="p">;</span>

			<span class="n">dm_bio_restore</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">read_record</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">);</span>
			<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">queue_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;All replicated volumes dead, failing I/O&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">read_record</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">read_record_pool</span><span class="p">);</span>
		<span class="n">map_context</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mirror_presuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">holds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process bios in the hold list to start recovery waiting</span>
<span class="cm">	 * for bios in the hold list. After the process, no bio has</span>
<span class="cm">	 * a chance to be added in the hold list because ms-&gt;suspend</span>
<span class="cm">	 * is set.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">holds</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">holds</span><span class="p">;</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">holds</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">holds</span><span class="p">)))</span>
		<span class="n">hold_bio</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must finish up all the work that we&#39;ve</span>
<span class="cm">	 * generated (i.e. recovery work).</span>
<span class="cm">	 */</span>
	<span class="n">dm_rh_stop_recovery</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">_kmirrord_recovery_stopped</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">dm_rh_recovery_in_flight</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">presuspend</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">presuspend</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="cm">/* FIXME: need better error handling */</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;log presuspend failed&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that recovery is complete/stopped and the</span>
<span class="cm">	 * delayed bios are queued, we need to wait for</span>
<span class="cm">	 * the worker thread to complete.  This way,</span>
<span class="cm">	 * we know that all of our I/O has been pushed.</span>
<span class="cm">	 */</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">kmirrord_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mirror_postsuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">postsuspend</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">postsuspend</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="cm">/* FIXME: need better error handling */</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;log postsuspend failed&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mirror_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">resume</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="cm">/* FIXME: need better error handling */</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;log resume failed&quot;</span><span class="p">);</span>
	<span class="n">dm_rh_start_recovery</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * device_status_char</span>
<span class="cm"> * @m: mirror device/leg we want the status of</span>
<span class="cm"> *</span>
<span class="cm"> * We return one character representing the most severe error</span>
<span class="cm"> * we have encountered.</span>
<span class="cm"> *    A =&gt; Alive - No failures</span>
<span class="cm"> *    D =&gt; Dead - A write failure occurred leaving mirror out-of-sync</span>
<span class="cm"> *    S =&gt; Sync - A sychronization failure occurred, mirror out-of-sync</span>
<span class="cm"> *    R =&gt; Read - A read failure occurred, mirror data unaffected</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: &lt;char&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="nf">device_status_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">mirror</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">)))</span>
		<span class="k">return</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_RAID1_FLUSH_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">)))</span> <span class="o">?</span> <span class="sc">&#39;F&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_RAID1_WRITE_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">)))</span> <span class="o">?</span> <span class="sc">&#39;D&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_RAID1_SYNC_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">)))</span> <span class="o">?</span> <span class="sc">&#39;S&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_RAID1_READ_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">)))</span> <span class="o">?</span> <span class="sc">&#39;R&#39;</span> <span class="o">:</span> <span class="sc">&#39;U&#39;</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dirty_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">dm_rh_dirty_log</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">rh</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">device_status_char</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%llu/%llu 1 %s &quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">get_sync_count</span><span class="p">(</span><span class="n">log</span><span class="p">),</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_regions</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

		<span class="n">sz</span> <span class="o">+=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">result</span><span class="o">+</span><span class="n">sz</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">-</span><span class="n">sz</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="n">sz</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">);</span>

		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot; %s %llu&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DM_RAID1_HANDLE_ERRORS</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot; 1 handle_errors&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mirror_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				  <span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mirror_set</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">nr_mirrors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">,</span>
			 <span class="n">ms</span><span class="o">-&gt;</span><span class="n">mirror</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">mirror_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	 <span class="o">=</span> <span class="s">&quot;mirror&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span>	 <span class="o">=</span> <span class="n">mirror_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>	 <span class="o">=</span> <span class="n">mirror_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>	 <span class="o">=</span> <span class="n">mirror_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end_io</span>	 <span class="o">=</span> <span class="n">mirror_end_io</span><span class="p">,</span>
	<span class="p">.</span><span class="n">presuspend</span> <span class="o">=</span> <span class="n">mirror_presuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postsuspend</span> <span class="o">=</span> <span class="n">mirror_postsuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>	 <span class="o">=</span> <span class="n">mirror_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span>	 <span class="o">=</span> <span class="n">mirror_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">mirror_iterate_devices</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dm_mirror_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">_dm_raid1_read_record_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_raid1_read_record</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dm_raid1_read_record_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t allocate dm_raid1_read_record cache&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mirror_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;Failed to register mirror target&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_target:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_dm_raid1_read_record_cache</span><span class="p">);</span>
<span class="nl">bad_cache:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">dm_mirror_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mirror_target</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_dm_raid1_read_record_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Module hooks */</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">dm_mirror_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dm_mirror_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DM_NAME</span> <span class="s">&quot; mirror target&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Joe Thornber&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
