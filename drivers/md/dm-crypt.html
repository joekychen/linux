<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-crypt.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-crypt.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003 Christophe Saout &lt;christophe@saout.de&gt;</span>
<span class="cm"> * Copyright (C) 2004 Clemens Fruhwirth &lt;clemens@endorphin.org&gt;</span>
<span class="cm"> * Copyright (C) 2006-2009 Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;crypto/hash.h&gt;</span>
<span class="cp">#include &lt;crypto/md5.h&gt;</span>
<span class="cp">#include &lt;crypto/algapi.h&gt;</span>

<span class="cp">#include &lt;linux/device-mapper.h&gt;</span>

<span class="cp">#define DM_MSG_PREFIX &quot;crypt&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * context holding the current state of a multi-part conversion</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">convert_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset_in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset_out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx_in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx_out</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pending</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * per bio private data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">base_bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">convert_context</span> <span class="n">ctx</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">pending</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">base_io</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg_in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg_out</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">iv_sector</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">crypt_config</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ctr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dtr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wipe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">generator</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">post</span><span class="p">)(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iv_essiv_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">hash_tfm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">salt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iv_benbi_private</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LMK_SEED_SIZE 64 </span><span class="cm">/* hash + 0 */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">hash_tfm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">seed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Crypt: maps a linear range of a block device</span>
<span class="cm"> * and encrypts / decrypts at the same time.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">flags</span> <span class="p">{</span> <span class="n">DM_CRYPT_SUSPENDED</span><span class="p">,</span> <span class="n">DM_CRYPT_KEY_VALID</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Duplicated per-CPU state for cipher.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="cm">/* ESSIV: struct crypto_cipher *essiv_tfm */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">iv_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfms</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The fields in here must be read only after initialization,</span>
<span class="cm"> * changing state should be in crypt_cpu.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">crypt_config</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pool for per bio private data, crypto requests and</span>
<span class="cm">	 * encryption requeusts/buffer pages</span>
<span class="cm">	 */</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">io_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">req_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">page_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">io_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">crypt_queue</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">cipher</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cipher_string</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="o">*</span><span class="n">iv_gen_ops</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iv_essiv_private</span> <span class="n">essiv</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iv_benbi_private</span> <span class="n">benbi</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="n">lmk</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">iv_gen_private</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">iv_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iv_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Duplicated per cpu state. Access through</span>
<span class="cm">	 * per_cpu_ptr() only.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tfms_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Layout of each crypto request:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   struct ablkcipher_request</span>
<span class="cm">	 *      context</span>
<span class="cm">	 *      padding</span>
<span class="cm">	 *   struct dm_crypt_request</span>
<span class="cm">	 *      padding</span>
<span class="cm">	 *   IV</span>
<span class="cm">	 *</span>
<span class="cm">	 * The padding is added so that dm_crypt_request and the IV are</span>
<span class="cm">	 * correctly aligned.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dmreq_start</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_parts</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define MIN_IOS        16</span>
<span class="cp">#define MIN_POOL_PAGES 32</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">_crypt_io_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">clone_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kcryptd_queue_crypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv_of_dmreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="nf">this_crypt_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use this to access cipher attributes that are the same for each CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="nf">any_tfm</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Different IV generation algorithms:</span>
<span class="cm"> *</span>
<span class="cm"> * plain: the initial vector is the 32-bit little-endian version of the sector</span>
<span class="cm"> *        number, padded with zeros if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * plain64: the initial vector is the 64-bit little-endian version of the sector</span>
<span class="cm"> *        number, padded with zeros if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * essiv: &quot;encrypted sector|salt initial vector&quot;, the sector number is</span>
<span class="cm"> *        encrypted with the bulk cipher using a salt as key. The salt</span>
<span class="cm"> *        should be derived from the bulk cipher&#39;s key via hashing.</span>
<span class="cm"> *</span>
<span class="cm"> * benbi: the 64-bit &quot;big-endian &#39;narrow block&#39;-count&quot;, starting at 1</span>
<span class="cm"> *        (needed for LRW-32-AES and possible other narrow block modes)</span>
<span class="cm"> *</span>
<span class="cm"> * null: the initial vector is always zero.  Provides compatibility with</span>
<span class="cm"> *       obsolete loop_fish2 devices.  Do not use for new devices.</span>
<span class="cm"> *</span>
<span class="cm"> * lmk:  Compatible implementation of the block chaining mode used</span>
<span class="cm"> *       by the Loop-AES block device encryption system</span>
<span class="cm"> *       designed by Jari Ruusu. See http://loop-aes.sourceforge.net/</span>
<span class="cm"> *       It operates on full 512 byte sectors and uses CBC</span>
<span class="cm"> *       with an IV derived from the sector number, the data and</span>
<span class="cm"> *       optionally extra IV seed.</span>
<span class="cm"> *       This means that after decryption the first block</span>
<span class="cm"> *       of sector must be tweaked according to decrypted data.</span>
<span class="cm"> *       Loop-AES can use three encryption schemes:</span>
<span class="cm"> *         version 1: is plain aes-cbc mode</span>
<span class="cm"> *         version 2: uses 64 multikey scheme with lmk IV generator</span>
<span class="cm"> *         version 3: the same as version 2 with additional IV seed</span>
<span class="cm"> *                   (it uses 65 keys, last key is used as IV seed)</span>
<span class="cm"> *</span>
<span class="cm"> * plumb: unimplemented, see:</span>
<span class="cm"> * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_plain_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">iv</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_plain64_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le64</span> <span class="o">*</span><span class="p">)</span><span class="n">iv</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialise ESSIV - compute salt but no local memory allocations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_essiv_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_essiv_private</span> <span class="o">*</span><span class="n">essiv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">essiv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hash_desc</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span><span class="p">);</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">essiv</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CRYPTO_TFM_REQ_MAY_SLEEP</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span><span class="p">,</span> <span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iv_private</span><span class="p">,</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_cipher_setkey</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">,</span> <span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span><span class="p">,</span>
				    <span class="n">crypto_hash_digestsize</span><span class="p">(</span><span class="n">essiv</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wipe salt and reset key derived from volume key */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_essiv_wipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_essiv_private</span> <span class="o">*</span><span class="n">essiv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">essiv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">salt_size</span> <span class="o">=</span> <span class="n">crypto_hash_digestsize</span><span class="p">(</span><span class="n">essiv</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">salt_size</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iv_private</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_cipher_setkey</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">,</span> <span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span><span class="p">,</span> <span class="n">salt_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up per cpu cipher state */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="nf">setup_essiv_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
					     <span class="n">u8</span> <span class="o">*</span><span class="n">salt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">saltsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Setup the essiv_tfm with the given salt */</span>
	<span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">crypto_alloc_cipher</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error allocating crypto tfm for ESSIV&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crypto_cipher_blocksize</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Block size of ESSIV cipher does &quot;</span>
			    <span class="s">&quot;not match IV size of block cipher&quot;</span><span class="p">;</span>
		<span class="n">crypto_free_cipher</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_cipher_setkey</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">,</span> <span class="n">salt</span><span class="p">,</span> <span class="n">saltsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Failed to set key for ESSIV cipher&quot;</span><span class="p">;</span>
		<span class="n">crypto_free_cipher</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">essiv_tfm</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_iv_essiv_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">cpu_cc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iv_essiv_private</span> <span class="o">*</span><span class="n">essiv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">essiv</span><span class="p">;</span>

	<span class="n">crypto_free_hash</span><span class="p">(</span><span class="n">essiv</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">);</span>
	<span class="n">essiv</span><span class="o">-&gt;</span><span class="n">hash_tfm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kzfree</span><span class="p">(</span><span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span><span class="p">);</span>
	<span class="n">essiv</span><span class="o">-&gt;</span><span class="n">salt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_cc</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">iv_private</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">essiv_tfm</span><span class="p">)</span>
			<span class="n">crypto_free_cipher</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">);</span>

		<span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">iv_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_essiv_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">hash_tfm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">salt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Digest algorithm missing for ESSIV mode&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate hash algorithm */</span>
	<span class="n">hash_tfm</span> <span class="o">=</span> <span class="n">crypto_alloc_hash</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error initializing ESSIV hash&quot;</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">salt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">crypto_hash_digestsize</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">salt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error kmallocing salt storage in ESSIV&quot;</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">essiv</span><span class="p">.</span><span class="n">salt</span> <span class="o">=</span> <span class="n">salt</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">essiv</span><span class="p">.</span><span class="n">hash_tfm</span> <span class="o">=</span> <span class="n">hash_tfm</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">setup_essiv_cpu</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">salt</span><span class="p">,</span>
					<span class="n">crypto_hash_digestsize</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">crypt_iv_essiv_dtr</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iv_private</span> <span class="o">=</span> <span class="n">essiv_tfm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_tfm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">))</span>
		<span class="n">crypto_free_hash</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">salt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_essiv_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">essiv_tfm</span> <span class="o">=</span> <span class="n">this_crypt_config</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iv_private</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le64</span> <span class="o">*</span><span class="p">)</span><span class="n">iv</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span><span class="p">);</span>
	<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">essiv_tfm</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_benbi_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">log</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>

	<span class="cm">/* we need to calculate how far we must shift the sector count</span>
<span class="cm">	 * to get the cipher block count, we use this shift in _gen */</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">log</span> <span class="o">!=</span> <span class="n">bs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;cypher blocksize is not a power of 2&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;cypher blocksize is &gt; 512&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">benbi</span><span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">-</span> <span class="n">log</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_iv_benbi_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_benbi_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span> <span class="cm">/* rest is cleared below */</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span> <span class="o">&lt;&lt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">benbi</span><span class="p">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">__be64</span> <span class="o">*</span><span class="p">)(</span><span class="n">iv</span> <span class="o">+</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_null_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_iv_lmk_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="o">*</span><span class="n">lmk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">lmk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">))</span>
		<span class="n">crypto_free_shash</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">);</span>
	<span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kzfree</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">);</span>
	<span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="o">*</span><span class="n">lmk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">lmk</span><span class="p">;</span>

	<span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span> <span class="o">=</span> <span class="n">crypto_alloc_shash</span><span class="p">(</span><span class="s">&quot;md5&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error initializing LMK hash&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* No seed in LMK version 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_parts</span> <span class="o">==</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">LMK_SEED_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crypt_iv_lmk_dtr</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error kmallocing seed storage in LMK&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="o">*</span><span class="n">lmk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">lmk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subkey_size</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">/</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_parts</span><span class="p">;</span>

	<span class="cm">/* LMK seed is on the position of LMK_KEYS + 1 key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span> <span class="o">*</span> <span class="n">subkey_size</span><span class="p">),</span>
		       <span class="n">crypto_shash_digestsize</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_wipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="o">*</span><span class="n">lmk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">lmk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LMK_SEED_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iv_lmk_private</span> <span class="o">*</span><span class="n">lmk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_private</span><span class="p">.</span><span class="n">lmk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">shash_desc</span> <span class="n">desc</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">ctx</span><span class="p">[</span><span class="n">crypto_shash_descsize</span><span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">)];</span>
	<span class="p">}</span> <span class="n">sdesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">md5_state</span> <span class="n">md5state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">lmk</span><span class="o">-&gt;</span><span class="n">hash_tfm</span><span class="p">;</span>
	<span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CRYPTO_TFM_REQ_MAY_SLEEP</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_shash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_shash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">lmk</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">,</span> <span class="n">LMK_SEED_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sector is always 512B, block size 16, add data of blocks 1-31 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_shash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">31</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* Sector is cropped to 56 bits here */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((((</span><span class="n">u64</span><span class="p">)</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00FFFFFF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">4024</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_shash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* No MD5 padding here */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_shash_export</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdesc</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md5state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MD5_HASH_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__cpu_to_le32s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md5state</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md5state</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_in</span><span class="p">));</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_iv_lmk_one</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_in</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iv_lmk_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dst</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">));</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_iv_lmk_one</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+</span> <span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* Tweak the first block of plaintext sector */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="n">crypto_xor</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_plain_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_plain_gen</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_plain64_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_plain64_gen</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_essiv_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ctr</span>       <span class="o">=</span> <span class="n">crypt_iv_essiv_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>       <span class="o">=</span> <span class="n">crypt_iv_essiv_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>      <span class="o">=</span> <span class="n">crypt_iv_essiv_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wipe</span>      <span class="o">=</span> <span class="n">crypt_iv_essiv_wipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_essiv_gen</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_benbi_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ctr</span>	   <span class="o">=</span> <span class="n">crypt_iv_benbi_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>	   <span class="o">=</span> <span class="n">crypt_iv_benbi_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_benbi_gen</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_null_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_null_gen</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypt_iv_operations</span> <span class="n">crypt_iv_lmk_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ctr</span>	   <span class="o">=</span> <span class="n">crypt_iv_lmk_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>	   <span class="o">=</span> <span class="n">crypt_iv_lmk_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>	   <span class="o">=</span> <span class="n">crypt_iv_lmk_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wipe</span>	   <span class="o">=</span> <span class="n">crypt_iv_lmk_wipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">crypt_iv_lmk_gen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post</span>	   <span class="o">=</span> <span class="n">crypt_iv_lmk_post</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_convert_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_out</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_in</span><span class="p">,</span>
			       <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span> <span class="o">=</span> <span class="n">bio_in</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_out</span> <span class="o">=</span> <span class="n">bio_out</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_in</span> <span class="o">=</span> <span class="n">bio_in</span> <span class="o">?</span> <span class="n">bio_in</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_out</span> <span class="o">=</span> <span class="n">bio_out</span> <span class="o">?</span> <span class="n">bio_out</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">=</span> <span class="n">sector</span> <span class="o">+</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_offset</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="nf">dmreq_of_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">req</span> <span class="o">+</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="nf">req_of_dmreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dmreq</span> <span class="o">-</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">iv_of_dmreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">dmreq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">crypto_ablkcipher_alignmask</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_convert_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv_in</span> <span class="o">=</span> <span class="n">bio_iovec_idx</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_in</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv_out</span> <span class="o">=</span> <span class="n">bio_iovec_idx</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_out</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_out</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dmreq</span> <span class="o">=</span> <span class="n">dmreq_of_req</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">iv</span> <span class="o">=</span> <span class="n">iv_of_dmreq</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">);</span>

	<span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">iv_sector</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">;</span>
	<span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_in</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_in</span><span class="p">,</span> <span class="n">bv_in</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">,</span>
		    <span class="n">bv_in</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_in</span><span class="p">);</span>

	<span class="n">sg_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">,</span> <span class="n">bv_out</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">,</span>
		    <span class="n">bv_out</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_out</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_in</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_in</span> <span class="o">&gt;=</span> <span class="n">bv_in</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_in</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_out</span> <span class="o">&gt;=</span> <span class="n">bv_out</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">offset_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_out</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">generator</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ablkcipher_request_set_crypt</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">sg_out</span><span class="p">,</span>
				     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_encrypt</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_decrypt</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kcryptd_async_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_async_request</span> <span class="o">*</span><span class="n">async_req</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_alloc_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">this_cc</span> <span class="o">=</span> <span class="n">this_crypt_config</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">key_index</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span>
		<span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>

	<span class="n">ablkcipher_request_set_tfm</span><span class="p">(</span><span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">key_index</span><span class="p">]);</span>
	<span class="n">ablkcipher_request_set_callback</span><span class="p">(</span><span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span>
	    <span class="n">CRYPTO_TFM_REQ_MAY_BACKLOG</span> <span class="o">|</span> <span class="n">CRYPTO_TFM_REQ_MAY_SLEEP</span><span class="p">,</span>
	    <span class="n">kcryptd_async_done</span><span class="p">,</span> <span class="n">dmreq_of_req</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Encrypt / decrypt data from one bio to another one (can be the same one)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">this_cc</span> <span class="o">=</span> <span class="n">this_crypt_config</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_in</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_in</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">&amp;&amp;</span>
	      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx_out</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">bio_out</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">crypt_alloc_req</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_convert_block</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* async */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">);</span>
			<span class="n">INIT_COMPLETION</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">);</span>
			<span class="cm">/* fall through*/</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
			<span class="n">this_cc</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sector</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* sync */</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sector</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* error */</span>
		<span class="nl">default:</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_crypt_bio_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">bio_free</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generate a new unfragmented bio with the given size</span>
<span class="cm"> * This should never violate the device limitations</span>
<span class="cm"> * May return a smaller bio when running out of pages, indicated by</span>
<span class="cm"> * *out_of_pages set to 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">crypt_alloc_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="o">*</span><span class="n">out_of_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_iovecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">GFP_NOIO</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">clone</span> <span class="o">=</span> <span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="n">nr_iovecs</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clone</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">clone_init</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">clone</span><span class="p">);</span>
	<span class="o">*</span><span class="n">out_of_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_iovecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">out_of_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If additional pages cannot be allocated without waiting,</span>
<span class="cm">		 * return a partially-allocated bio.  The caller will then try</span>
<span class="cm">		 * to allocate more bios while submitting this partial bio.</span>
<span class="cm">		 */</span>
		<span class="n">gfp_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_WAIT</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="n">PAGE_SIZE</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_add_page</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">clone</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_free_buffer_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bv</span> <span class="o">=</span> <span class="n">bio_iovec_idx</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">);</span>
		<span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="nf">crypt_io_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">;</span>

	<span class="n">io</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">base_io</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">io</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_inc_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * One of the bios was finished. Check for completion of</span>
<span class="cm"> * the whole request and correctly clean up the buffer.</span>
<span class="cm"> * If base_io is set, wait for the last fragment to complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_dec_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">base_bio</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">base_io</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">base_io</span><span class="p">))</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">base_bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">base_io</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
			<span class="n">base_io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">base_io</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kcryptd/kcryptd_io:</span>
<span class="cm"> *</span>
<span class="cm"> * Needed because it would be very unwise to do decryption in an</span>
<span class="cm"> * interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * kcryptd performs the actual encryption or decryption.</span>
<span class="cm"> *</span>
<span class="cm"> * kcryptd_io performs the IO submission.</span>
<span class="cm"> *</span>
<span class="cm"> * They must be separated as otherwise the final stages could be</span>
<span class="cm"> * starved by new requests which can block in the first stages due</span>
<span class="cm"> * to memory allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * The work is done per CPU global for all dm-crypt instances.</span>
<span class="cm"> * They should not depend on each other and do not block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">BIO_UPTODATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * free the processed pages</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">crypt_free_buffer_pages</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">clone</span><span class="p">);</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kcryptd_queue_crypt</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clone_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_end_io</span>  <span class="o">=</span> <span class="n">crypt_endio</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_bdev</span>    <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_rw</span>      <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_destructor</span> <span class="o">=</span> <span class="n">dm_crypt_bio_destructor</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kcryptd_io_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">base_bio</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The block layer might modify the bvec array, so always</span>
<span class="cm">	 * copy the required bvecs because we need the original</span>
<span class="cm">	 * one in order to decrypt the whole bio data *afterwards*.</span>
<span class="cm">	 */</span>
	<span class="n">clone</span> <span class="o">=</span> <span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">bio_segments</span><span class="p">(</span><span class="n">base_bio</span><span class="p">),</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clone</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>

	<span class="n">clone_init</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">clone</span><span class="p">);</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">=</span> <span class="n">bio_segments</span><span class="p">(</span><span class="n">base_bio</span><span class="p">);</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">base_bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span> <span class="n">bio_iovec</span><span class="p">(</span><span class="n">base_bio</span><span class="p">),</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">)</span> <span class="o">*</span> <span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">);</span>

	<span class="n">generic_make_request</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_io_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">bio_out</span><span class="p">;</span>
	<span class="n">generic_make_request</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_crypt_io</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kcryptd_io_read</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">))</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kcryptd_io_write</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_queue_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">kcryptd_io</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_crypt_write_io_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">bio_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">crypt_free_buffer_pages</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">clone</span><span class="p">);</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
		<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* crypt_convert should have filled the clone bio */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">idx_out</span> <span class="o">&lt;</span> <span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">);</span>

	<span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span>
		<span class="n">kcryptd_queue_io</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">generic_make_request</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_crypt_write_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">clone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">new_io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crypt_finished</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">out_of_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent io from disappearing until this function completes.</span>
<span class="cm">	 */</span>
	<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="n">crypt_convert_init</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The allocated buffers can be smaller than the whole bio,</span>
<span class="cm">	 * so repeat the whole process until all the data can be handled.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clone</span> <span class="o">=</span> <span class="n">crypt_alloc_buffer</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_of_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">clone</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">bio_out</span> <span class="o">=</span> <span class="n">clone</span><span class="p">;</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">idx_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">clone</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
		<span class="n">sector</span> <span class="o">+=</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>

		<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_convert</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">crypt_finished</span> <span class="o">=</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>

		<span class="cm">/* Encryption was already finished, submit io now */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crypt_finished</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kcryptd_crypt_write_io_submit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there was an error, do not try next fragments.</span>
<span class="cm">			 * For async, error is processed in async handler.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Out of memory -&gt; run queues</span>
<span class="cm">		 * But don&#39;t wait if split was due to the io size restriction</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">out_of_pages</span><span class="p">))</span>
			<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * With async crypto it is unsafe to share the crypto context</span>
<span class="cm">		 * between fragments, so switch to a new dm_crypt_io structure.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">crypt_finished</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_io</span> <span class="o">=</span> <span class="n">crypt_io_alloc</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">,</span>
						<span class="n">sector</span><span class="p">);</span>
			<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">new_io</span><span class="p">);</span>
			<span class="n">crypt_convert_init</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					   <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>
			<span class="n">new_io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">idx_in</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">idx_in</span><span class="p">;</span>
			<span class="n">new_io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">offset_in</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">offset_in</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Fragments after the first use the base_io</span>
<span class="cm">			 * pending count.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_io</span><span class="p">)</span>
				<span class="n">new_io</span><span class="o">-&gt;</span><span class="n">base_io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">new_io</span><span class="o">-&gt;</span><span class="n">base_io</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_io</span><span class="p">;</span>
				<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_io</span><span class="p">);</span>
				<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">io</span> <span class="o">=</span> <span class="n">new_io</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_crypt_read_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_crypt_read_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">crypt_inc_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>

	<span class="n">crypt_convert_init</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">,</span>
			   <span class="n">io</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_convert</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">))</span>
		<span class="n">kcryptd_crypt_read_done</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>

	<span class="n">crypt_dec_pending</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_async_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_async_request</span> <span class="o">*</span><span class="n">async_req</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_request</span> <span class="o">*</span><span class="n">dmreq</span> <span class="o">=</span> <span class="n">async_req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">convert_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">dmreq</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_crypt_io</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">iv_of_dmreq</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">),</span> <span class="n">dmreq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">req_of_dmreq</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dmreq</span><span class="p">),</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">kcryptd_crypt_read_done</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kcryptd_crypt_write_io_submit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_crypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_crypt_io</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">kcryptd_crypt_read_convert</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kcryptd_crypt_write_convert</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kcryptd_queue_crypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">kcryptd_crypt</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">crypt_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode key from its hex representation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_decode_key</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">hex</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">hex</span><span class="o">++</span><span class="p">;</span>

		<span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hex</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Encode key into its hex representation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_encode_key</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hex</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">hex</span><span class="p">,</span> <span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
		<span class="n">hex</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">key</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_free_tfms</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">cpu_cc</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">crypto_free_ablkcipher</span><span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_alloc_tfms</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ciphermode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">cpu_cc</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crypto_alloc_ablkcipher</span><span class="p">(</span><span class="n">ciphermode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">crypt_free_tfms</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_setkey_allcpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">subkey_size</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&gt;&gt;</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_setkey</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">subkey_size</span><span class="p">),</span> <span class="n">subkey_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_set_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_string_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* The key size may not be changed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">!=</span> <span class="p">(</span><span class="n">key_string_len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Hyphen (which gives a key_size of zero) means there is no key. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&amp;&amp;</span> <span class="n">crypt_decode_key</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">DM_CRYPT_KEY_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">crypt_setkey_allcpus</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* Hex key string not needed after here, so wipe it. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="n">key_string_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_wipe_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DM_CRYPT_KEY_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">crypt_setkey_allcpus</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_cpu</span> <span class="o">*</span><span class="n">cpu_cc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_queue</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">crypt_queue</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">crypt_queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_cc</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span>
				<span class="n">mempool_free</span><span class="p">(</span><span class="n">cpu_cc</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">);</span>
			<span class="n">crypt_free_tfms</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">)</span>
		<span class="n">bioset_free</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">dtr</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">dtr</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dm_put_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">kzfree</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">);</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher_string</span><span class="p">);</span>

	<span class="cm">/* Must zero key material before freeing */</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_ctr_cipher</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">cipher_in</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">cipher</span><span class="p">,</span> <span class="o">*</span><span class="n">chainmode</span><span class="p">,</span> <span class="o">*</span><span class="n">ivmode</span><span class="p">,</span> <span class="o">*</span><span class="n">ivopts</span><span class="p">,</span> <span class="o">*</span><span class="n">keycount</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cipher_api</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="cm">/* Convert to crypto api definition? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">cipher_in</span><span class="p">,</span> <span class="sc">&#39;(&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Bad cipher specification&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher_string</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">cipher_in</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher_string</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_mem</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Legacy dm-crypt cipher specification</span>
<span class="cm">	 * cipher[:keycount]-mode-iv:ivopts</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cipher_in</span><span class="p">;</span>
	<span class="n">keycount</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">);</span>
	<span class="n">cipher</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keycount</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keycount</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">keycount</span><span class="p">,</span> <span class="s">&quot;%u%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
		 <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Bad cipher key count specification&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_parts</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span><span class="p">;</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_mem</span><span class="p">;</span>

	<span class="n">chainmode</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">);</span>
	<span class="n">ivopts</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">);</span>
	<span class="n">ivmode</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ivopts</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Ignoring unexpected additional cipher options&quot;</span><span class="p">);</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">__alloc_percpu</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span> <span class="o">+</span>
				 <span class="n">cc</span><span class="o">-&gt;</span><span class="n">tfms_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tfms</span><span class="p">)),</span>
				 <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypt_cpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate per cpu state&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For compatibility with the original dm-crypt mapping format, if</span>
<span class="cm">	 * only the cipher name is supplied, use cbc-plain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chainmode</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chainmode</span><span class="p">,</span> <span class="s">&quot;plain&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ivmode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chainmode</span> <span class="o">=</span> <span class="s">&quot;cbc&quot;</span><span class="p">;</span>
		<span class="n">ivmode</span> <span class="o">=</span> <span class="s">&quot;plain&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chainmode</span><span class="p">,</span> <span class="s">&quot;ecb&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ivmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;IV mechanism required&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cipher_api</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">CRYPTO_MAX_ALG_NAME</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cipher_api</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_mem</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">cipher_api</span><span class="p">,</span> <span class="n">CRYPTO_MAX_ALG_NAME</span><span class="p">,</span>
		       <span class="s">&quot;%s(%s)&quot;</span><span class="p">,</span> <span class="n">chainmode</span><span class="p">,</span> <span class="n">cipher</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cipher_api</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate cipher */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">crypt_alloc_tfms</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cipher_api</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error allocating crypto tfm&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize and set key */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">crypt_set_key</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error decoding and setting key&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize IV */</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">)</span>
		<span class="cm">/* at least a 64 bit sector number should fit in our buffer */</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">)));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ivmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Selected cipher does not support IVs&quot;</span><span class="p">);</span>
		<span class="n">ivmode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Choose ivmode, see comments at iv code. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ivmode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;plain&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_plain_ops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;plain64&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_plain64_ops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;essiv&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_essiv_ops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;benbi&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_benbi_ops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;null&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_null_ops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ivmode</span><span class="p">,</span> <span class="s">&quot;lmk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crypt_iv_lmk_ops</span><span class="p">;</span>
		<span class="cm">/* Version 2 and 3 is recognised according</span>
<span class="cm">		 * to length of provided multi-key string.</span>
<span class="cm">		 * If present (version 3), last key is used as IV seed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">%</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_parts</span><span class="p">)</span>
			<span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_parts</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid IV mode&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate IV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">ctr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">ctr</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ivopts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error creating IV&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize IV (set keys for ESSIV etc) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Error initialising IV&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">bad:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cipher_api</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">bad_mem:</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate cipher strings&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct an encryption mapping:</span>
<span class="cm"> * &lt;cipher&gt; &lt;key&gt; &lt;iv_offset&gt; &lt;dev_path&gt; &lt;start&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_ctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_size</span><span class="p">,</span> <span class="n">opt_params</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tmpll</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="n">as</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opt_string</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_arg</span> <span class="n">_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid number of feature args&quot;</span><span class="p">},</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Not enough arguments&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cc</span><span class="p">)</span> <span class="o">+</span> <span class="n">key_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate encryption context&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">=</span> <span class="n">key_size</span><span class="p">;</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">cc</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">crypt_ctr_cipher</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">MIN_IOS</span><span class="p">,</span> <span class="n">_crypt_io_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate crypt io mempool&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span><span class="p">);</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span> <span class="o">+=</span> <span class="n">crypto_ablkcipher_reqsize</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">));</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span><span class="p">,</span> <span class="n">crypto_tfm_ctx_alignment</span><span class="p">());</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span> <span class="o">+=</span> <span class="n">crypto_ablkcipher_alignmask</span><span class="p">(</span><span class="n">any_tfm</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span> <span class="o">&amp;</span>
			   <span class="o">~</span><span class="p">(</span><span class="n">crypto_tfm_ctx_alignment</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span> <span class="o">=</span> <span class="n">mempool_create_kmalloc_pool</span><span class="p">(</span><span class="n">MIN_IOS</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dmreq_start</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_crypt_request</span><span class="p">)</span> <span class="o">+</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">req_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate crypt request mempool&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span> <span class="o">=</span> <span class="n">mempool_create_page_pool</span><span class="p">(</span><span class="n">MIN_POOL_PAGES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate page mempool&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span> <span class="o">=</span> <span class="n">bioset_create</span><span class="p">(</span><span class="n">MIN_IOS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">bs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Cannot allocate crypt bioset&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;%llu%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid iv_offset sector&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_offset</span> <span class="o">=</span> <span class="n">tmpll</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_get_device</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dm_table_get_mode</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Device lookup failed&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="s">&quot;%llu%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid device sector&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">tmpll</span><span class="p">;</span>

	<span class="n">argv</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">argc</span> <span class="o">-=</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* Optional parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">as</span><span class="p">.</span><span class="n">argc</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
		<span class="n">as</span><span class="p">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dm_read_arg_group</span><span class="p">(</span><span class="n">_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt_params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

		<span class="n">opt_string</span> <span class="o">=</span> <span class="n">dm_shift_arg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">opt_params</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">opt_string</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">opt_string</span><span class="p">,</span> <span class="s">&quot;allow_discards&quot;</span><span class="p">))</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">opt_params</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Invalid feature arguments&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_queue</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;kcryptd_io&quot;</span><span class="p">,</span>
				       <span class="n">WQ_NON_REENTRANT</span><span class="o">|</span>
				       <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span>
				       <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">io_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t create kcryptd io queue&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">crypt_queue</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;kcryptd&quot;</span><span class="p">,</span>
					  <span class="n">WQ_NON_REENTRANT</span><span class="o">|</span>
					  <span class="n">WQ_CPU_INTENSIVE</span><span class="o">|</span>
					  <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span>
					  <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">crypt_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Couldn&#39;t create kcryptd queue&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data_unsupported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">crypt_dtr</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		     <span class="k">union</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_crypt_io</span> <span class="o">*</span><span class="n">io</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If bio is REQ_FLUSH or REQ_DISCARD, just bypass crypt queues.</span>
<span class="cm">	 * - for REQ_FLUSH device-mapper core ensures that no IO is in-flight</span>
<span class="cm">	 * - for REQ_DISCARD caller must use flush if IO ordering matters</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_DISCARD</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">dm_target_offset</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DM_MAPIO_REMAPPED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">io</span> <span class="o">=</span> <span class="n">crypt_io_alloc</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">dm_target_offset</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">base_bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kcryptd_io_read</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">))</span>
			<span class="n">kcryptd_queue_io</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kcryptd_queue_crypt</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DM_MAPIO_SUBMITTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="n">status_type_t</span> <span class="n">type</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUSTYPE_INFO</span>:
		<span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">STATUSTYPE_TABLE</span>:
		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">cipher_string</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">maxlen</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">crypt_encode_key</span><span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span><span class="p">);</span>
			<span class="n">sz</span> <span class="o">+=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">maxlen</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">result</span><span class="p">[</span><span class="n">sz</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot; %llu %s %llu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_offset</span><span class="p">,</span>
				<span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span><span class="p">)</span>
			<span class="n">DMEMIT</span><span class="p">(</span><span class="s">&quot; 1 allow_discards&quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_postsuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">DM_CRYPT_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_preresume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_CRYPT_KEY_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;aborting resume - crypt key is not set.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypt_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DM_CRYPT_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Message interface</span>
<span class="cm"> *	key set &lt;key&gt;</span>
<span class="cm"> *	key wipe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;key&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DM_CRYPT_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;not suspended during key manipulation.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;set&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">crypt_set_key</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;wipe&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">wipe</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">iv_gen_ops</span><span class="o">-&gt;</span><span class="n">wipe</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">crypt_wipe_key</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;unrecognised message received.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="o">*</span><span class="n">bvm</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">biovec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max_size</span><span class="p">;</span>

	<span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">dm_target_offset</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">bvm</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bvm</span><span class="p">,</span> <span class="n">biovec</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crypt_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				 <span class="n">iterate_devices_callout_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypt_config</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">target_type</span> <span class="n">crypt_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;crypt&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctr</span>    <span class="o">=</span> <span class="n">crypt_ctr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr</span>    <span class="o">=</span> <span class="n">crypt_dtr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>    <span class="o">=</span> <span class="n">crypt_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">crypt_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postsuspend</span> <span class="o">=</span> <span class="n">crypt_postsuspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">preresume</span> <span class="o">=</span> <span class="n">crypt_preresume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">crypt_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">crypt_message</span><span class="p">,</span>
	<span class="p">.</span><span class="n">merge</span>  <span class="o">=</span> <span class="n">crypt_merge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iterate_devices</span> <span class="o">=</span> <span class="n">crypt_iterate_devices</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dm_crypt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">_crypt_io_pool</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dm_crypt_io</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_crypt_io_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;register failed %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_crypt_io_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">dm_crypt_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt_target</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">_crypt_io_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dm_crypt_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dm_crypt_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Christophe Saout &lt;christophe@saout.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DM_NAME</span> <span class="s">&quot; target for transparent encryption / decryption&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
