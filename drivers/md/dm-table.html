<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › md › dm-table.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-table.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 Sistina Software (UK) Limited.</span>
<span class="cm"> * Copyright (C) 2004-2008 Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;dm.h&quot;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#define DM_MSG_PREFIX &quot;table&quot;</span>

<span class="cp">#define MAX_DEPTH 16</span>
<span class="cp">#define NODE_SIZE L1_CACHE_BYTES</span>
<span class="cp">#define KEYS_PER_NODE (NODE_SIZE / sizeof(sector_t))</span>
<span class="cp">#define CHILDREN_PER_NODE (KEYS_PER_NODE + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * The table has always exactly one reference from either mapped_device-&gt;map</span>
<span class="cm"> * or hash_cell-&gt;new_map. This reference is not counted in table-&gt;holders.</span>
<span class="cm"> * A pair of dm_create_table/dm_destroy_table functions is used for table</span>
<span class="cm"> * creation/destruction.</span>
<span class="cm"> *</span>
<span class="cm"> * Temporary references from the other code increase table-&gt;holders. A pair</span>
<span class="cm"> * of dm_table_get/dm_table_put functions is used to manipulate it.</span>
<span class="cm"> *</span>
<span class="cm"> * When the table is about to be destroyed, we wait for table-&gt;holders to</span>
<span class="cm"> * drop to zero.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dm_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">holders</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* btree table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counts</span><span class="p">[</span><span class="n">MAX_DEPTH</span><span class="p">];</span>	<span class="cm">/* in nodes */</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">index</span><span class="p">[</span><span class="n">MAX_DEPTH</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_targets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_allocated</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">highs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">targets</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">target_type</span> <span class="o">*</span><span class="n">immutable_target_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">integrity_supported</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">singleton</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Indicates the rw permissions for the new logical</span>
<span class="cm">	 * device.  This should be a combination of FMODE_READ</span>
<span class="cm">	 * and FMODE_WRITE.</span>
<span class="cm">	 */</span>
	<span class="n">fmode_t</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* a list of devices used by this table */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>

	<span class="cm">/* events get handed up using this callback */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">event_fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">event_context</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_md_mempools</span> <span class="o">*</span><span class="n">mempools</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">target_callbacks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to ceiling(log_size(n))</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">int_log</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">dm_div_up</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="n">result</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the index of the child node of the n&#39;th node k&#39;th key.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_child</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">CHILDREN_PER_NODE</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the n&#39;th node of level l from table t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="o">*</span><span class="nf">get_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">KEYS_PER_NODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the highest key that you could lookup from the n&#39;th</span>
<span class="cm"> * node on level l of the btree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">high</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">CHILDREN_PER_NODE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">get_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">KEYS_PER_NODE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fills in a level of the btree based on the highs of the level</span>
<span class="cm"> * below it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_btree_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">l</span><span class="p">];</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">KEYS_PER_NODE</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">get_child</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dm_vcalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elem_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that we&#39;re not going to overflow.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmemb</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ULONG_MAX</span> <span class="o">/</span> <span class="n">elem_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">nmemb</span> <span class="o">*</span> <span class="n">elem_size</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_vcalloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * highs, and targets are managed as dynamic arrays during a</span>
<span class="cm"> * table load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">n_highs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">n_targets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate both the target array and offset array at once.</span>
<span class="cm">	 * Append an empty entry to catch sectors beyond the end of</span>
<span class="cm">	 * the device.</span>
<span class="cm">	 */</span>
	<span class="n">n_highs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dm_vcalloc</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span><span class="p">)</span> <span class="o">+</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">sector_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_highs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">n_targets</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">n_highs</span> <span class="o">+</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">n_highs</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">n_highs</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">n_targets</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">n_targets</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">n_highs</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">n_highs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">n</span><span class="p">));</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">num_allocated</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span> <span class="o">=</span> <span class="n">n_highs</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">=</span> <span class="n">n_targets</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_table_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">**</span><span class="n">result</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="n">num_targets</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">target_callbacks</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">holders</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_targets</span><span class="p">)</span>
		<span class="n">num_targets</span> <span class="o">=</span> <span class="n">KEYS_PER_NODE</span><span class="p">;</span>

	<span class="n">num_targets</span> <span class="o">=</span> <span class="n">dm_round_up</span><span class="p">(</span><span class="n">num_targets</span><span class="p">,</span> <span class="n">KEYS_PER_NODE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_targets</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">num_targets</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span> <span class="o">=</span> <span class="n">md</span><span class="p">;</span>
	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">devices</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev_internal</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;dm_table_destroy: dm_put_device call missing for %s&quot;</span><span class="p">,</span>
		       <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">holders</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* free the indexes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* free the targets */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">tgt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">dtr</span><span class="p">)</span>
			<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">dtr</span><span class="p">(</span><span class="n">tgt</span><span class="p">);</span>

		<span class="n">dm_put_target_type</span><span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">);</span>

	<span class="cm">/* free the device list */</span>
	<span class="n">free_devices</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>

	<span class="n">dm_free_md_mempools</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">holders</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_get</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dm_table_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">holders</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Checks to see if we need to extend highs or targets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_allocated</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">alloc_targets</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_allocated</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if we&#39;ve already got a device in the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="nf">find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open a device so we can use it as a map destination.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">open_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_claim_ptr</span> <span class="o">=</span> <span class="s">&quot;I belong to device-mapper&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">bdev</span> <span class="o">=</span> <span class="n">blkdev_get_by_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">,</span> <span class="n">_claim_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">bd_link_disk_holder</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">dm_disk</span><span class="p">(</span><span class="n">md</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close a device that we&#39;ve been using.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">close_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bd_unlink_disk_holder</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">dm_disk</span><span class="p">(</span><span class="n">md</span><span class="p">));</span>
	<span class="n">blkdev_put</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If possible, this checks an area of a destination device is invalid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_area_is_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">dev_size</span> <span class="o">=</span>
		<span class="n">i_size_read</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">logical_block_size_sectors</span> <span class="o">=</span>
		<span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">&gt;&gt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices exist without request functions,</span>
<span class="cm">	 * such as loop devices not yet bound to backing files.</span>
<span class="cm">	 * Forbid the use of such devices.</span>
<span class="cm">	 */</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">make_request_fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: %s is not yet initialised: &quot;</span>
		       <span class="s">&quot;start=%llu, len=%llu, dev_size=%llu&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">dev_size</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">dev_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: %s too small for target: &quot;</span>
		       <span class="s">&quot;start=%llu, len=%llu, dev_size=%llu&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">logical_block_size_sectors</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">logical_block_size_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: start=%llu not aligned to h/w &quot;</span>
		       <span class="s">&quot;logical block size %u of %s&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
		       <span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">logical_block_size_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: len=%llu not aligned to h/w &quot;</span>
		       <span class="s">&quot;logical block size %u of %s&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">,</span>
		       <span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This upgrades the mode on an already open dm_dev, being</span>
<span class="cm"> * careful to leave things as they were if we fail to reopen the</span>
<span class="cm"> * device and not to touch the existing bdev field in case</span>
<span class="cm"> * it is accessed concurrently inside dm_table_any_congested().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">upgrade_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">new_mode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="n">dd_new</span><span class="p">,</span> <span class="n">dd_old</span><span class="p">;</span>

	<span class="n">dd_new</span> <span class="o">=</span> <span class="n">dd_old</span> <span class="o">=</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

	<span class="n">dd_new</span><span class="p">.</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">new_mode</span><span class="p">;</span>
	<span class="n">dd_new</span><span class="p">.</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">open_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd_new</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">,</span> <span class="n">md</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">new_mode</span><span class="p">;</span>
	<span class="n">close_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd_old</span><span class="p">,</span> <span class="n">md</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a device to the list, or just increment the usage count if</span>
<span class="cm"> * it&#39;s already present.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dm_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">**</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%u:%u%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">major</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">minor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Extract the major/minor numbers */</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">major</span> <span class="o">||</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">minor</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* convert the path to a device */</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">lookup_bdev</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bdev</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">;</span>
		<span class="n">bdput</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">open_dev</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">format_dev_t</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">|</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">upgrade_mode</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_get_device</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dm_set_device_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: Cannot set limits for nonexistent device %s&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdev_stack_limits</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: adding target device %s caused an alignment inconsistency: &quot;</span>
		       <span class="s">&quot;physical_block_size=%u, logical_block_size=%u, &quot;</span>
		       <span class="s">&quot;alignment_offset=%u, start=%llu&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">alignment_offset</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if merge fn is supported.</span>
<span class="cm">	 * If not we&#39;ll force DM to use PAGE_SIZE or</span>
<span class="cm">	 * smaller I/O, just to be safe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm_queue_merge_is_compulsory</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">merge</span><span class="p">)</span>
		<span class="n">blk_limits_max_hw_sectors</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dm_set_device_limits</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement a device&#39;s use count and remove it if necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dm_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev_internal</span><span class="p">,</span>
						  <span class="n">dm_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">close_dev</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_put_device</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Checks to see if the target joins onto the end of the table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">adjoin</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">[</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_targets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">==</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">+</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to dynamically allocate the arg array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span><span class="nf">realloc_argv</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">array_size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">old_argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">new_size</span><span class="p">;</span>

	<span class="n">new_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">array_size</span> <span class="o">?</span> <span class="o">*</span><span class="n">array_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">argv</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">new_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">old_argv</span><span class="p">,</span> <span class="o">*</span><span class="n">array_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">));</span>
		<span class="o">*</span><span class="n">array_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">old_argv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">argv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Destructively splits up the argument list to pass to ctr.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dm_split_args</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">***</span><span class="n">argvp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">input</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">argv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">array_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">argc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">argvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">argv</span> <span class="o">=</span> <span class="n">realloc_argv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Skip whitespace */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">start</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* success, we hit the end */</span>

		<span class="cm">/* &#39;out&#39; is used to remove any back-quotes */</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">out</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Everything apart from &#39;\0&#39; can be quoted */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">end</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* end of token */</span>

			<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">end</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* have we already filled the array ? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">array_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">argv</span> <span class="o">=</span> <span class="n">realloc_argv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argv</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we know this is whitespace */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span>
			<span class="n">end</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* terminate the string and put it in the array */</span>
		<span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">argc</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">argc</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">argvp</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Impose necessary and sufficient conditions on a devices&#39;s table such</span>
<span class="cm"> * that any incoming bio which respects its logical_block_size can be</span>
<span class="cm"> * processed successfully.  If it falls across the boundary between</span>
<span class="cm"> * two or more targets, the size of each piece it gets split into must</span>
<span class="cm"> * be compatible with the logical_block_size of the target processing it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_hardware_logical_block_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This function uses arithmetic modulo the logical_block_size</span>
<span class="cm">	 * (in units of 512-byte sectors).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">device_logical_block_size_sects</span> <span class="o">=</span>
		<span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">&gt;&gt;</span> <span class="n">SECTOR_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Offset of the start of the next table entry, mod logical_block_size.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">next_target_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Given an aligned bio that extends beyond the end of a</span>
<span class="cm">	 * target, how many sectors must the next target handle?</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">queue_limits</span> <span class="n">ti_limits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check each entry in the table in turn.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="n">blk_set_stacking_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">);</span>

		<span class="cm">/* combine all target devices&#39; limits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">)</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">dm_set_device_limits</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the remaining sectors fall entirely within this</span>
<span class="cm">		 * table entry are they compatible with its logical_block_size?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">remaining</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">ti_limits</span><span class="p">.</span><span class="n">logical_block_size</span> <span class="o">&gt;&gt;</span>
				  <span class="n">SECTOR_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* Error */</span>

		<span class="n">next_target_start</span> <span class="o">=</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="p">((</span><span class="n">next_target_start</span> <span class="o">+</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span>
				      <span class="p">(</span><span class="n">device_logical_block_size_sects</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="n">next_target_start</span> <span class="o">?</span>
		    <span class="n">device_logical_block_size_sects</span> <span class="o">-</span> <span class="n">next_target_start</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: table line %u (start sect %llu len %llu) &quot;</span>
		       <span class="s">&quot;not aligned to h/w logical block size %u&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
		       <span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_table_add_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">,</span> <span class="n">argc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">tgt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: target type %s must appear alone in table&quot;</span><span class="p">,</span>
		      <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">check_space</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">tgt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tgt</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: zero-length target&quot;</span><span class="p">,</span> <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">dm_get_target_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: %s: unknown target type&quot;</span><span class="p">,</span> <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
		      <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_needs_singleton</span><span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: target type %s must appear alone in table&quot;</span><span class="p">,</span>
			      <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">type</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">singleton</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_always_writeable</span><span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: target type %s may not be included in read-only tables&quot;</span><span class="p">,</span>
		      <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">immutable_target_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">immutable_target_type</span> <span class="o">!=</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: immutable target type %s cannot be mixed with other target types&quot;</span><span class="p">,</span>
			      <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">immutable_target_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dm_target_is_immutable</span><span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: immutable target type %s cannot be mixed with other target types&quot;</span><span class="p">,</span>
			      <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">immutable_target_type</span> <span class="o">=</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Unknown error&quot;</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does this target adjoin the previous one ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adjoin</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tgt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;Gap in table&quot;</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_split_args</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="s">&quot;couldn&#39;t split parameters (insufficient memory)&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ctr</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">+</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span> <span class="o">&amp;&amp;</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">discards_supported</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: %s: ignoring discards_supported because num_discard_requests is zero.&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">bad:</span>
	<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;%s: %s: %s&quot;</span><span class="p">,</span> <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span> <span class="n">type</span><span class="p">,</span> <span class="n">tgt</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
	<span class="n">dm_put_target_type</span><span class="p">(</span><span class="n">tgt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Target argument parsing helpers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_next_arg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">arg_set</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">error</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">grouped</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg_str</span> <span class="o">=</span> <span class="n">dm_shift_arg</span><span class="p">(</span><span class="n">arg_set</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg_str</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">arg_str</span><span class="p">,</span> <span class="s">&quot;%u%c&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">grouped</span> <span class="o">&amp;&amp;</span> <span class="n">arg_set</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_read_arg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">arg_set</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">validate_next_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg_set</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_read_arg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dm_read_arg_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">arg_set</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">validate_next_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg_set</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_read_arg_group</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dm_shift_arg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">as</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">--</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">argv</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_shift_arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dm_consume_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_arg_set</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num_args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="n">num_args</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">-=</span> <span class="n">num_args</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">argv</span> <span class="o">+=</span> <span class="n">num_args</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_consume_args</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_table_set_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bio_based</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">request_based</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">tgt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">devices</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tgt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_target_request_based</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span>
			<span class="n">request_based</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bio_based</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_based</span> <span class="o">&amp;&amp;</span> <span class="n">request_based</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Inconsistent table: different target types&quot;</span>
			       <span class="s">&quot; can&#39;t be mixed up&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_based</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must use this table as bio-based */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_TYPE_BIO_BASED</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">request_based</span><span class="p">);</span> <span class="cm">/* No targets in this table */</span>

	<span class="cm">/* Non-request-stackable devices can&#39;t be used for request-based dm */</span>
	<span class="n">devices</span> <span class="o">=</span> <span class="n">dm_table_get_devices</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_queue_stackable</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;table load rejected: including&quot;</span>
			       <span class="s">&quot; non-request-stackable devices&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request-based dm supports only tables that have a single target now.</span>
<span class="cm">	 * To support multiple targets, request splitting support is needed,</span>
<span class="cm">	 * and that needs lots of changes in the block-layer.</span>
<span class="cm">	 * (e.g. request completion process for partial completion.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;Request-based dm doesn&#39;t support multiple targets yet&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DM_TYPE_REQUEST_BASED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="nf">dm_table_get_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">target_type</span> <span class="o">*</span><span class="nf">dm_table_get_immutable_target_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">immutable_target_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">dm_table_request_based</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dm_table_get_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="n">DM_TYPE_REQUEST_BASED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_table_alloc_md_mempools</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">type</span> <span class="o">=</span> <span class="n">dm_table_get_type</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DM_TYPE_NONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;no table type is set, can&#39;t allocate mempools&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span> <span class="o">=</span> <span class="n">dm_alloc_md_mempools</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">integrity_supported</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_free_md_mempools</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dm_free_md_mempools</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dm_md_mempools</span> <span class="o">*</span><span class="nf">dm_table_get_md_mempools</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mempools</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_indexes</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">indexes</span><span class="p">;</span>

	<span class="cm">/* allocate the space for *all* the indexes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dm_div_up</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">CHILDREN_PER_NODE</span><span class="p">);</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dm_vcalloc</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">indexes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* set up internal nodes, bottom-up */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">;</span>
		<span class="n">indexes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">KEYS_PER_NODE</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">setup_btree_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Builds the btree to index the map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_table_build_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">leaf_nodes</span><span class="p">;</span>

	<span class="cm">/* how many indexes will the btree have ? */</span>
	<span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">dm_div_up</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">,</span> <span class="n">KEYS_PER_NODE</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">int_log</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">,</span> <span class="n">CHILDREN_PER_NODE</span><span class="p">);</span>

	<span class="cm">/* leaf layer has already been set up */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_nodes</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">setup_indexes</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a disk whose integrity profile reflects the table&#39;s profile.</span>
<span class="cm"> * If %match_all is true, all devices&#39; profiles must match.</span>
<span class="cm"> * If %match_all is false, all devices must at least have an</span>
<span class="cm"> * allocated integrity profile; but uninitialized is ok.</span>
<span class="cm"> * Returns NULL if integrity support was inconsistent or unavailable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span> <span class="nf">dm_table_get_integrity_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
						    <span class="n">bool</span> <span class="n">match_all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">devices</span> <span class="o">=</span> <span class="n">dm_table_get_devices</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">prev_disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">template_disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">template_disk</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_get_integrity</span><span class="p">(</span><span class="n">template_disk</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">no_integrity</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_all</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">blk_integrity_is_initialized</span><span class="p">(</span><span class="n">template_disk</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* skip uninitialized profiles */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_disk</span> <span class="o">&amp;&amp;</span>
			 <span class="n">blk_integrity_compare</span><span class="p">(</span><span class="n">prev_disk</span><span class="p">,</span> <span class="n">template_disk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_integrity</span><span class="p">;</span>
		<span class="n">prev_disk</span> <span class="o">=</span> <span class="n">template_disk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">template_disk</span><span class="p">;</span>

<span class="nl">no_integrity:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_disk</span><span class="p">)</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: integrity not set: %s and %s profile mismatch&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
		       <span class="n">prev_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span>
		       <span class="n">template_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register the mapped device for blk_integrity support if</span>
<span class="cm"> * the underlying devices have an integrity profile.  But all devices</span>
<span class="cm"> * may not have matching profiles (checking all devices isn&#39;t reliable</span>
<span class="cm"> * during table load because this table may use other DM device(s) which</span>
<span class="cm"> * must be resumed before they will have an initialized integity profile).</span>
<span class="cm"> * Stacked DM devices force a 2 stage integrity profile validation:</span>
<span class="cm"> * 1 - during load, validate all initialized integrity profiles match</span>
<span class="cm"> * 2 - during resume, validate all integrity profiles match</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_table_prealloc_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">template_disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">template_disk</span> <span class="o">=</span> <span class="n">dm_table_get_integrity_disk</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">template_disk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_integrity_is_initialized</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">md</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">integrity_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">blk_integrity_register</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">md</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If DM device already has an initalized integrity</span>
<span class="cm">	 * profile the new profile should not conflict.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_integrity_is_initialized</span><span class="p">(</span><span class="n">template_disk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">blk_integrity_compare</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">md</span><span class="p">),</span> <span class="n">template_disk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: conflict with existing integrity profile: &quot;</span>
		       <span class="s">&quot;%s profile mismatch&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
		       <span class="n">template_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Preserve existing initialized integrity profile */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">integrity_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepares the table for use by building the indices,</span>
<span class="cm"> * setting the type, and allocating mempools.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dm_table_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_table_set_type</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;unable to set table type&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_table_build_index</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;unable to build btrees&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_table_prealloc_integrity</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;could not register integrity profile.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">dm_table_alloc_md_mempools</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">DMERR</span><span class="p">(</span><span class="s">&quot;unable to allocate mempools&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">_event_lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">dm_table_event_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_event_lock</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">event_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">event_context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_event_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * You can no longer call dm_table_event() from interrupt</span>
<span class="cm">	 * context, use a bottom half instead.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_event_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">event_fn</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">event_fn</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">event_context</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_event_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_event</span><span class="p">);</span>

<span class="n">sector_t</span> <span class="nf">dm_table_get_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span> <span class="o">?</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">highs</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_get_size</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="nf">dm_table_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the btree for the correct target.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller should check returned pointer with dm_target_is_valid()</span>
<span class="cm"> * to trap I/O beyond end of device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="nf">dm_table_find_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">KEYS_PER_NODE</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sector</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">[(</span><span class="n">KEYS_PER_NODE</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Establish the new table&#39;s queue_limits and validate them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dm_calculate_queue_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">queue_limits</span> <span class="n">ti_limits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blk_set_stacking_limits</span><span class="p">(</span><span class="n">limits</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blk_set_stacking_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">);</span>

		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">combine_limits</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Combine queue limits of all the devices this target uses.</span>
<span class="cm">		 */</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">dm_set_device_limits</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">);</span>

		<span class="cm">/* Set I/O hints portion of queue limits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">io_hints</span><span class="p">)</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">io_hints</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check each device area is consistent with the target&#39;s</span>
<span class="cm">		 * overall queue limits.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">device_area_is_invalid</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">combine_limits:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Merge this target&#39;s queue limits into the overall limits</span>
<span class="cm">		 * for the table.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_stack_limits</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti_limits</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: adding target device &quot;</span>
			       <span class="s">&quot;(start sect %llu len %llu) &quot;</span>
			       <span class="s">&quot;caused an alignment inconsistency&quot;</span><span class="p">,</span>
			       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">validate_hardware_logical_block_alignment</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">limits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the integrity profile for this device if all devices used have</span>
<span class="cm"> * matching profiles.  We&#39;re quite deep in the resume path but still</span>
<span class="cm"> * don&#39;t know if all devices (particularly DM devices this device</span>
<span class="cm"> * may be stacked on) have matching profiles.  Even if the profiles</span>
<span class="cm"> * don&#39;t match we have no way to fail (to resume) at this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dm_table_set_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">template_disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_get_integrity</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">template_disk</span> <span class="o">=</span> <span class="n">dm_table_get_integrity_disk</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">template_disk</span><span class="p">)</span>
		<span class="n">blk_integrity_register</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
				       <span class="n">blk_get_integrity</span><span class="p">(</span><span class="n">template_disk</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk_integrity_is_initialized</span><span class="p">(</span><span class="n">dm_disk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">)))</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: device no longer has a valid integrity profile&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">DMWARN</span><span class="p">(</span><span class="s">&quot;%s: unable to establish an integrity profile&quot;</span><span class="p">,</span>
		       <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_flush_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">flush</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_flags</span> <span class="o">&amp;</span> <span class="n">flush</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">dm_table_supports_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Require at least one underlying device to support flushes.</span>
<span class="cm">	 * t-&gt;devices includes internal dm devices such as mirror logs</span>
<span class="cm">	 * so we need to use iterate_devices here, which targets</span>
<span class="cm">	 * supporting flushes must provide.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_flush_requests</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">device_flush_capable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">dm_table_discard_zeroes_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Ensure that all targets supports discard_zeroes_data. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data_unsupported</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_is_nonrot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="n">blk_queue_nonrot</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">dm_table_is_nonrot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Ensure that all underlying device are non-rotational. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">device_is_nonrot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_set_restrictions</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy table&#39;s limits to the DM device&#39;s request_queue</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span> <span class="o">=</span> <span class="o">*</span><span class="n">limits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dm_table_supports_discards</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="n">queue_flag_clear_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_table_supports_flush</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">REQ_FLUSH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flush</span> <span class="o">|=</span> <span class="n">REQ_FLUSH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_table_supports_flush</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">REQ_FUA</span><span class="p">))</span>
			<span class="n">flush</span> <span class="o">|=</span> <span class="n">REQ_FUA</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_queue_flush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dm_table_discard_zeroes_data</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm_table_is_nonrot</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">queue_flag_clear_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="n">dm_table_set_integrity</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * QUEUE_FLAG_STACKABLE must be set after all queue settings are</span>
<span class="cm">	 * visible to other CPUs because, once the flag is set, incoming bios</span>
<span class="cm">	 * are processed by request-based dm, which refers to the queue</span>
<span class="cm">	 * settings.</span>
<span class="cm">	 * Until the flag set, bios are passed to bio-based dm and queued to</span>
<span class="cm">	 * md-&gt;deferred where queue settings are not needed yet.</span>
<span class="cm">	 * Those bios are passed to request-based dm at the resume time.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm_table_request_based</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_STACKABLE</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dm_table_get_num_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">dm_table_get_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fmode_t</span> <span class="nf">dm_table_get_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_get_mode</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">suspend_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">postsuspend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">postsuspend</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">postsuspend</span><span class="p">)</span>
				<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">postsuspend</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">presuspend</span><span class="p">)</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">presuspend</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>

		<span class="n">ti</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_presuspend_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">suspend_targets</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_postsuspend_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">suspend_targets</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_table_resume_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">preresume</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">preresume</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
			<span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dm_table_add_target_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_target_callbacks</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">target_callbacks</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dm_table_add_target_callbacks</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dm_table_any_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bdi_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_dev_internal</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">devices</span> <span class="o">=</span> <span class="n">dm_table_get_devices</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dm_target_callbacks</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">);</span>
		<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">|=</span> <span class="n">bdi_congested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">bdi_bits</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">DMWARN_LIMIT</span><span class="p">(</span><span class="s">&quot;%s: any_congested: nonexistent device %s&quot;</span><span class="p">,</span>
				     <span class="n">dm_device_name</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">),</span>
				     <span class="n">bdevname</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dm_dev</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">target_callbacks</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">congested_fn</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">|=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">congested_fn</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">bdi_bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dm_table_any_busy_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">num_targets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">targets</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">(</span><span class="n">ti</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mapped_device</span> <span class="o">*</span><span class="nf">dm_table_get_md</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dm_table_get_md</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_discard_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="n">blk_queue_discard</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">dm_table_supports_discards</span><span class="p">(</span><span class="k">struct</span> <span class="n">dm_table</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dm_target</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unless any target used by the table set discards_supported,</span>
<span class="cm">	 * require at least one underlying device to support discards.</span>
<span class="cm">	 * t-&gt;devices includes internal dm devices such as mirror logs</span>
<span class="cm">	 * so we need to use iterate_devices here, which targets</span>
<span class="cm">	 * supporting discard selectively must provide.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dm_table_get_num_targets</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">dm_table_get_target</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_discard_requests</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">discards_supported</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">iterate_devices</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">device_discard_capable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
