<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parisc › pdc_stable.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pdc_stable.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* </span>
<span class="cm"> *    Interfaces to retrieve and set PDC Stable options (firmware)</span>
<span class="cm"> *</span>
<span class="cm"> *    Copyright (C) 2005-2006 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License, version 2, as</span>
<span class="cm"> *    published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *    DEV NOTE: the PDC Procedures reference states that:</span>
<span class="cm"> *    &quot;A minimum of 96 bytes of Stable Storage is required. Providing more than</span>
<span class="cm"> *    96 bytes of Stable Storage is optional [...]. Failure to provide the</span>
<span class="cm"> *    optional locations from 96 to 192 results in the loss of certain</span>
<span class="cm"> *    functionality during boot.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *    Since locations between 96 and 192 are the various paths, most (if not</span>
<span class="cm"> *    all) PA-RISC machines should have them. Anyway, for safety reasons, the</span>
<span class="cm"> *    following code can deal with just 96 bytes of Stable Storage, and all</span>
<span class="cm"> *    sizes between 96 and 192 bytes (provided they are multiple of struct</span>
<span class="cm"> *    device_path size, eg: 128, 160 and 192) to provide full information.</span>
<span class="cm"> *    One last word: there&#39;s one path we can always count on: the primary path.</span>
<span class="cm"> *    Anything above 224 bytes is used for &#39;osdep2&#39; OS-dependent storage area.</span>
<span class="cm"> *</span>
<span class="cm"> *    The first OS-dependent area should always be available. Obviously, this is</span>
<span class="cm"> *    not true for the other one. Also bear in mind that reading/writing from/to</span>
<span class="cm"> *    osdep2 is much more expensive than from/to osdep1.</span>
<span class="cm"> *    NOTE: We do not handle the 2 bytes OS-dep area at 0x5D, nor the first</span>
<span class="cm"> *    2 bytes of storage available right after OSID. That&#39;s a total of 4 bytes</span>
<span class="cm"> *    sacrificed: -ETOOLAZY :P</span>
<span class="cm"> *</span>
<span class="cm"> *    The current policy wrt file permissions is:</span>
<span class="cm"> *	- write: root only</span>
<span class="cm"> *	- read: (reading triggers PDC calls) ? root only : everyone</span>
<span class="cm"> *    The rationale is that PDC calls could hog (DoS) the machine.</span>
<span class="cm"> *</span>
<span class="cm"> *	TODO:</span>
<span class="cm"> *	- timer/fastsize write calls</span>
<span class="cm"> */</span>

<span class="cp">#undef PDCS_DEBUG</span>
<span class="cp">#ifdef PDCS_DEBUG</span>
<span class="cp">#define DPRINTK(fmt, args...)	printk(KERN_DEBUG fmt, ## args)</span>
<span class="cp">#else</span>
<span class="cp">#define DPRINTK(fmt, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;</span>

<span class="cp">#define PDCS_VERSION	&quot;0.30&quot;</span>
<span class="cp">#define PDCS_PREFIX	&quot;PDC Stable Storage&quot;</span>

<span class="cp">#define PDCS_ADDR_PPRI	0x00</span>
<span class="cp">#define PDCS_ADDR_OSID	0x40</span>
<span class="cp">#define PDCS_ADDR_OSD1	0x48</span>
<span class="cp">#define PDCS_ADDR_DIAG	0x58</span>
<span class="cp">#define PDCS_ADDR_FSIZ	0x5C</span>
<span class="cp">#define PDCS_ADDR_PCON	0x60</span>
<span class="cp">#define PDCS_ADDR_PALT	0x80</span>
<span class="cp">#define PDCS_ADDR_PKBD	0xA0</span>
<span class="cp">#define PDCS_ADDR_OSD2	0xE0</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Thibaut VARENE &lt;varenet@parisc-linux.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;sysfs interface to HP PDC Stable Storage data&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">PDCS_VERSION</span><span class="p">);</span>

<span class="cm">/* holds Stable Storage size. Initialized once and for all, no lock needed */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdcs_size</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* holds OS ID. Initialized once and for all, hopefully to 0x0006 */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">pdcs_osid</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* This struct defines what we need to deal with a parisc pdc path entry */</span>
<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="p">{</span>
	<span class="n">rwlock_t</span> <span class="n">rw_lock</span><span class="p">;</span>		<span class="cm">/* to protect path entry access */</span>
	<span class="kt">short</span> <span class="n">ready</span><span class="p">;</span>			<span class="cm">/* entry record is valid if != 0 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>		<span class="cm">/* entry address in stable storage */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>			<span class="cm">/* entry name */</span>
	<span class="k">struct</span> <span class="n">device_path</span> <span class="n">devpath</span><span class="p">;</span>	<span class="cm">/* device path in parisc representation */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* corresponding device */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pdcspath_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define PDCSPATH_ENTRY(_addr, _name) \</span>
<span class="cp">struct pdcspath_entry pdcspath_entry_##_name = { \</span>
<span class="cp">	.ready = 0, \</span>
<span class="cp">	.addr = _addr, \</span>
<span class="cp">	.name = __stringify(_name), \</span>
<span class="cp">};</span>

<span class="cp">#define PDCS_ATTR(_name, _mode, _show, _store) \</span>
<span class="cp">struct kobj_attribute pdcs_attr_##_name = { \</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode}, \</span>
<span class="cp">	.show = _show, \</span>
<span class="cp">	.store = _store, \</span>
<span class="cp">};</span>

<span class="cp">#define PATHS_ATTR(_name, _mode, _show, _store) \</span>
<span class="cp">struct pdcspath_attribute paths_attr_##_name = { \</span>
<span class="cp">	.attr = {.name = __stringify(_name), .mode = _mode}, \</span>
<span class="cp">	.show = _show, \</span>
<span class="cp">	.store = _store, \</span>
<span class="cp">};</span>

<span class="cp">#define to_pdcspath_attribute(_attr) container_of(_attr, struct pdcspath_attribute, attr)</span>
<span class="cp">#define to_pdcspath_entry(obj)  container_of(obj, struct pdcspath_entry, kobj)</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_fetch - This function populates the path entry structs.</span>
<span class="cm"> * @entry: A pointer to an allocated pdcspath_entry.</span>
<span class="cm"> * </span>
<span class="cm"> * The general idea is that you don&#39;t read from the Stable Storage every time</span>
<span class="cm"> * you access the files provided by the facilities. We store a copy of the</span>
<span class="cm"> * content of the stable storage WRT various paths in these structs. We read</span>
<span class="cm"> * these structs when reading the files, and we will write to these structs when</span>
<span class="cm"> * writing to the files, and only then write them back to the Stable Storage.</span>
<span class="cm"> *</span>
<span class="cm"> * This function expects to be called with @entry-&gt;rw_lock write-hold.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pdcspath_fetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_path</span> <span class="o">*</span><span class="n">devpath</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">devpath</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">;</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: fetch: 0x%p, 0x%p, addr: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">devpath</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* addr, devpath and count must be word aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">devpath</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">devpath</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		
	<span class="cm">/* Find the matching device.</span>
<span class="cm">	   NOTE: hardware_path overlays with device_path, so the nice cast can</span>
<span class="cm">	   be used */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hwpath_to_device</span><span class="p">((</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="p">)</span><span class="n">devpath</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: device: 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_store - This function writes a path to stable storage.</span>
<span class="cm"> * @entry: A pointer to an allocated pdcspath_entry.</span>
<span class="cm"> * </span>
<span class="cm"> * It can be used in two ways: either by passing it a preset devpath struct</span>
<span class="cm"> * containing an already computed hardware path, or by passing it a device</span>
<span class="cm"> * pointer, from which it&#39;ll find out the corresponding hardware path.</span>
<span class="cm"> * For now we do not handle the case where there&#39;s an error in writing to the</span>
<span class="cm"> * Stable Storage area, so you&#39;d better not mess up the data :P</span>
<span class="cm"> *</span>
<span class="cm"> * This function expects to be called with @entry-&gt;rw_lock write-hold.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pdcspath_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_path</span> <span class="o">*</span><span class="n">devpath</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">devpath</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">;</span>
	
	<span class="cm">/* We expect the caller to set the ready flag to 0 if the hardware</span>
<span class="cm">	   path struct provided is invalid, so that we know we have to fill it.</span>
<span class="cm">	   First case, we don&#39;t have a preset hwpath... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ...but we have a device, map it */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">device_to_hwpath</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="p">)</span><span class="n">devpath</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* else, we expect the provided hwpath to be valid. */</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: store: 0x%p, 0x%p, addr: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">devpath</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* addr, devpath and count must be word aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_write</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">devpath</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">devpath</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: an error occurred when writing to PDC.</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;It is likely that the Stable Storage data has been corrupted.</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;Please check it carefully upon next reboot.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
		
	<span class="cm">/* kobject is already registered */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: device: 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_hwpath_read - This function handles hardware path pretty printing.</span>
<span class="cm"> * @entry: An allocated and populated pdscpath_entry struct.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> * </span>
<span class="cm"> * We will call this function to format the output of the hwpath attribute file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_hwpath_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_path</span> <span class="o">*</span><span class="n">devpath</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">||</span> <span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">devpath</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>	<span class="cm">/* entry is not ready */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%u/&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">devpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">devpath</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_hwpath_write - This function handles hardware path modifying.</span>
<span class="cm"> * @entry: An allocated and populated pdscpath_entry struct.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> * </span>
<span class="cm"> * We will call this function to change the current hardware path.</span>
<span class="cm"> * Hardware paths are to be given &#39;/&#39;-delimited, without brackets.</span>
<span class="cm"> * We make sure that the provided path actually maps to an existing</span>
<span class="cm"> * device, BUT nothing would prevent some foolish user to set the path to some</span>
<span class="cm"> * PCI bridge or even a CPU...</span>
<span class="cm"> * A better work around would be to make sure we are at the end of a device tree</span>
<span class="cm"> * for instance, but it would be IMHO beyond the simple scope of that driver.</span>
<span class="cm"> * The aim is to provide a facility. Data correctness is left to userland.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_hwpath_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="n">hwpath</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">in</span><span class="p">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">||</span> <span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll use a local copy of buf */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	
	<span class="cm">/* Let&#39;s clean up the target. 0xff is a blank pattern */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwpath</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hwpath</span><span class="p">));</span>
	
	<span class="cm">/* First, pick the mod field (the last one of the input string) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			
	<span class="n">hwpath</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">temp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">in</span><span class="p">[</span><span class="n">temp</span><span class="o">-</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* truncate the remaining string. just precaution */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: mod: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hwpath</span><span class="p">.</span><span class="n">mod</span><span class="p">);</span>
	
	<span class="cm">/* Then, loop for each delimiter, making sure we don&#39;t have too many.</span>
<span class="cm">	   we write the bc fields in a down-top way. No matter what, we stop</span>
<span class="cm">	   before writing the last field. If there are too many fields anyway,</span>
<span class="cm">	   then the user is a moron and it&#39;ll be caught up later when we&#39;ll</span>
<span class="cm">	   check the consistency of the given hwpath. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span><span class="o">-</span><span class="n">in</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwpath</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">temp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">in</span><span class="p">[</span><span class="n">temp</span><span class="o">-</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: bc[%d]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">hwpath</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Store the final field */</span>		
	<span class="n">hwpath</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: bc[%d]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">hwpath</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	
	<span class="cm">/* Now we check that the user isn&#39;t trying to lure us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hwpath_to_device</span><span class="p">((</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hwpath</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: attempt to set invalid </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
			<span class="s">&quot;hardware path: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* So far so good, let&#39;s get in deep */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	
	<span class="cm">/* Now, dive in. Write back to the hardware */</span>
	<span class="n">pdcspath_store</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	
	<span class="cm">/* Update the symlink to the real device */</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;device&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;device&quot;</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PDCS_PREFIX</span> <span class="s">&quot;: changed </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> path to </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_layer_read - Extended layer (eg. SCSI ids) pretty printing.</span>
<span class="cm"> * @entry: An allocated and populated pdscpath_entry struct.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> * </span>
<span class="cm"> * We will call this function to format the output of the layer attribute file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_layer_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_path</span> <span class="o">*</span><span class="n">devpath</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">||</span> <span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">devpath</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>	<span class="cm">/* entry is not ready */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">devpath</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%u &quot;</span><span class="p">,</span> <span class="n">devpath</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_layer_write - This function handles extended layer modifying.</span>
<span class="cm"> * @entry: An allocated and populated pdscpath_entry struct.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> * </span>
<span class="cm"> * We will call this function to change the current layer value.</span>
<span class="cm"> * Layers are to be given &#39;.&#39;-delimited, without brackets.</span>
<span class="cm"> * XXX beware we are far less checky WRT input data provided than for hwpath.</span>
<span class="cm"> * Potential harm can be done, since there&#39;s no way to check the validity of</span>
<span class="cm"> * the layer fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_layer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">layers</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* device-specific info (ctlr#, unit#, ...) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">in</span><span class="p">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">||</span> <span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll use a local copy of buf */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	
	<span class="cm">/* Let&#39;s clean up the target. 0 is a blank pattern */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">layers</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">layers</span><span class="p">));</span>
	
	<span class="cm">/* First, pick the first layer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: layer[0]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	
	<span class="n">temp</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">temp</span><span class="p">))))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: layer[%d]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
		
	<span class="cm">/* So far so good, let&#39;s get in deep */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="cm">/* First, overwrite the current layers with the new ones, not touching</span>
<span class="cm">	   the hardware path. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">layers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">layers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">layers</span><span class="p">));</span>
	
	<span class="cm">/* Now, dive in. Write back to the hardware */</span>
	<span class="n">pdcspath_store</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PDCS_PREFIX</span> <span class="s">&quot;: changed </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> layers to </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_attr_show - Generic read function call wrapper.</span>
<span class="cm"> * @kobj: The kobject to get info from.</span>
<span class="cm"> * @attr: The attribute looked upon.</span>
<span class="cm"> * @buf: The output buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">to_pdcspath_entry</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pdcspath_attribute</span> <span class="o">*</span><span class="n">pdcs_attr</span> <span class="o">=</span> <span class="n">to_pdcspath_attribute</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdcs_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pdcs_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcspath_attr_store - Generic write function call wrapper.</span>
<span class="cm"> * @kobj: The kobject to write info to.</span>
<span class="cm"> * @attr: The attribute to be modified.</span>
<span class="cm"> * @buf: The input buffer.</span>
<span class="cm"> * @count: The size of the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pdcspath_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">to_pdcspath_entry</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pdcspath_attribute</span> <span class="o">*</span><span class="n">pdcs_attr</span> <span class="o">=</span> <span class="n">to_pdcspath_attribute</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdcs_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pdcs_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">pdcspath_attr_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">pdcspath_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">pdcspath_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* These are the two attributes of any PDC path. */</span>
<span class="k">static</span> <span class="n">PATHS_ATTR</span><span class="p">(</span><span class="n">hwpath</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pdcspath_hwpath_read</span><span class="p">,</span> <span class="n">pdcspath_hwpath_write</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PATHS_ATTR</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pdcspath_layer_read</span><span class="p">,</span> <span class="n">pdcspath_layer_write</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">paths_subsys_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">paths_attr_hwpath</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">paths_attr_layer</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Specific kobject type for our PDC paths */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">ktype_pdcspath</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdcspath_attr_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="n">paths_subsys_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* We hard define the 4 types of path we expect to find */</span>
<span class="k">static</span> <span class="n">PDCSPATH_ENTRY</span><span class="p">(</span><span class="n">PDCS_ADDR_PPRI</span><span class="p">,</span> <span class="n">primary</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCSPATH_ENTRY</span><span class="p">(</span><span class="n">PDCS_ADDR_PCON</span><span class="p">,</span> <span class="n">console</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCSPATH_ENTRY</span><span class="p">(</span><span class="n">PDCS_ADDR_PALT</span><span class="p">,</span> <span class="n">alternative</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCSPATH_ENTRY</span><span class="p">(</span><span class="n">PDCS_ADDR_PKBD</span><span class="p">,</span> <span class="n">keyboard</span><span class="p">);</span>

<span class="cm">/* An array containing all PDC paths we will deal with */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">pdcspath_entries</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">pdcspath_entry_primary</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcspath_entry_alternative</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcspath_entry_console</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcspath_entry_keyboard</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* For more insight of what&#39;s going on here, refer to PDC Procedures doc,</span>
<span class="cm"> * Section PDC_STABLE */</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_size_read - Stable Storage size output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_size_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* show the size of the stable storage */</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdcs_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_auto_read - Stable Storage autoboot/search flag output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_auto_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">knob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">pathentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Current flags are stored in primary boot path entry */</span>
	<span class="n">pathentry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdcspath_entry_primary</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">knob</span><span class="p">)</span> <span class="o">?</span>
					<span class="s">&quot;On&quot;</span> <span class="o">:</span> <span class="s">&quot;Off&quot;</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_autoboot_read - Stable Storage autoboot flag output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_autoboot_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdcs_auto_read</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PF_AUTOBOOT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_autosearch_read - Stable Storage autoboot flag output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_autosearch_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdcs_auto_read</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PF_AUTOSEARCH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_timer_read - Stable Storage timer count output (in seconds).</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> *</span>
<span class="cm"> * The value of the timer field correponds to a number of seconds in powers of 2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_timer_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">pathentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Current flags are stored in primary boot path entry */</span>
	<span class="n">pathentry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdcspath_entry_primary</span><span class="p">;</span>

	<span class="cm">/* print the timer value in seconds */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_TIMER</span><span class="p">)</span> <span class="o">?</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_TIMER</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_osid_read - Stable Storage OS ID register output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_osid_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%s dependent data (0x%.4x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">os_id_to_string</span><span class="p">(</span><span class="n">pdcs_osid</span><span class="p">),</span> <span class="n">pdcs_osid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_osdep1_read - Stable Storage OS-Dependent data area 1 output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> *</span>
<span class="cm"> * This can hold 16 bytes of OS-Dependent data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_osdep1_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">PDCS_ADDR_OSD1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_diagnostic_read - Stable Storage Diagnostic register output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> *</span>
<span class="cm"> * I have NFC how to interpret the content of that register ;-).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_diagnostic_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* get diagnostic */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">PDCS_ADDR_DIAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_fastsize_read - Stable Storage FastSize register output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> *</span>
<span class="cm"> * This register holds the amount of system RAM to be tested during boot sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_fastsize_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* get fast-size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">PDCS_ADDR_FSIZ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x0E</span><span class="p">)</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;%d kB&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">))</span><span class="o">*</span><span class="mi">256</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;All&quot;</span><span class="p">);</span>
	<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_osdep2_read - Stable Storage OS-Dependent data area 2 output.</span>
<span class="cm"> * @buf: The output buffer to write to.</span>
<span class="cm"> *</span>
<span class="cm"> * This can hold pdcs_size - 224 bytes of OS-Dependent data, when available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_osdep2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdcs_size</span> <span class="o">&lt;=</span> <span class="mi">224</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">pdcs_size</span> <span class="o">-</span> <span class="mi">224</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">PDCS_ADDR_OSD2</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&quot;0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_auto_write - This function handles autoboot/search flag modifying.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag</span>
<span class="cm"> * </span>
<span class="cm"> * We will call this function to change the current autoboot flag.</span>
<span class="cm"> * We expect a precise syntax:</span>
<span class="cm"> *	\&quot;n\&quot; (n == 0 or 1) to toggle AutoBoot Off or On</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_auto_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">knob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">pathentry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">in</span><span class="p">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll use a local copy of buf */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/* Current flags are stored in primary boot path entry */</span>
	<span class="n">pathentry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdcspath_entry_primary</span><span class="p">;</span>
	
	<span class="cm">/* Be nice to the existing flag record */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: flags before: 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">temp</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">parse_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">knob</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">knob</span><span class="p">;</span>
	
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: flags after: 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		
	<span class="cm">/* So far so good, let&#39;s get in deep */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="cm">/* Change the path entry flags first */</span>
	<span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		
	<span class="cm">/* Now, dive in. Write back to the hardware */</span>
	<span class="n">pdcspath_store</span><span class="p">(</span><span class="n">pathentry</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pathentry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PDCS_PREFIX</span> <span class="s">&quot;: changed </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> to </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">knob</span> <span class="o">&amp;</span> <span class="n">PF_AUTOBOOT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;autoboot&quot;</span> <span class="o">:</span> <span class="s">&quot;autosearch&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">knob</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;On&quot;</span> <span class="o">:</span> <span class="s">&quot;Off&quot;</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">parse_error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Parse error: expect </span><span class="se">\&quot;</span><span class="s">n</span><span class="se">\&quot;</span><span class="s"> (n == 0 or 1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_autoboot_write - This function handles autoboot flag modifying.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> *</span>
<span class="cm"> * We will call this function to change the current boot flags.</span>
<span class="cm"> * We expect a precise syntax:</span>
<span class="cm"> *	\&quot;n\&quot; (n == 0 or 1) to toggle AutoSearch Off or On</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_autoboot_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdcs_auto_write</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PF_AUTOBOOT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_autosearch_write - This function handles autosearch flag modifying.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> *</span>
<span class="cm"> * We will call this function to change the current boot flags.</span>
<span class="cm"> * We expect a precise syntax:</span>
<span class="cm"> *	\&quot;n\&quot; (n == 0 or 1) to toggle AutoSearch Off or On</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_autosearch_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdcs_auto_write</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PF_AUTOSEARCH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_osdep1_write - Stable Storage OS-Dependent data area 1 input.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> *</span>
<span class="cm"> * This can store 16 bytes of OS-Dependent data. We use a byte-by-byte</span>
<span class="cm"> * write approach. It&#39;s up to userspace to deal with it when constructing</span>
<span class="cm"> * its input buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_osdep1_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">in</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdcs_osid</span> <span class="o">!=</span> <span class="n">OS_ID_LINUX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll use a local copy of buf */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_write</span><span class="p">(</span><span class="n">PDCS_ADDR_OSD1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_osdep2_write - Stable Storage OS-Dependent data area 2 input.</span>
<span class="cm"> * @buf: The input buffer to read from.</span>
<span class="cm"> * @count: The number of bytes to be read.</span>
<span class="cm"> *</span>
<span class="cm"> * This can store pdcs_size - 224 bytes of OS-Dependent data. We use a</span>
<span class="cm"> * byte-by-byte write approach. It&#39;s up to userspace to deal with it when</span>
<span class="cm"> * constructing its input buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pdcs_osdep2_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">in</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdcs_size</span> <span class="o">&lt;=</span> <span class="mi">224</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdcs_osid</span> <span class="o">!=</span> <span class="n">OS_ID_LINUX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">pdcs_size</span> <span class="o">-</span> <span class="mi">224</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll use a local copy of buf */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span><span class="o">-</span><span class="n">i</span> <span class="o">:</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdc_stable_write</span><span class="p">(</span><span class="n">PDCS_ADDR_OSD2</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The remaining attributes. */</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">pdcs_size_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">autoboot</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pdcs_autoboot_read</span><span class="p">,</span> <span class="n">pdcs_autoboot_write</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">autosearch</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pdcs_autosearch_read</span><span class="p">,</span> <span class="n">pdcs_autosearch_write</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">pdcs_timer_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">osid</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">pdcs_osid_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">osdep1</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">pdcs_osdep1_read</span><span class="p">,</span> <span class="n">pdcs_osdep1_write</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">diagnostic</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">pdcs_diagnostic_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">fastsize</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">pdcs_fastsize_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PDCS_ATTR</span><span class="p">(</span><span class="n">osdep2</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">pdcs_osdep2_read</span><span class="p">,</span> <span class="n">pdcs_osdep2_write</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">pdcs_subsys_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_size</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_autoboot</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_autosearch</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_timer</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_osid</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_osdep1</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_diagnostic</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_fastsize</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pdcs_attr_osdep2</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">pdcs_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">pdcs_subsys_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">stable_kobj</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">paths_kset</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.</span>
<span class="cm"> * </span>
<span class="cm"> * It creates kobjects corresponding to each path entry with nice sysfs</span>
<span class="cm"> * links to the real device. This is where the magic takes place: when</span>
<span class="cm"> * registering the subsystem attributes during module init, each kobject hereby</span>
<span class="cm"> * created will show in the sysfs tree as a folder containing files as defined</span>
<span class="cm"> * by path_subsys_attr[].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">pdcs_register_pathentries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	
	<span class="cm">/* Initialize the entries rw_lock before anything else */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="n">pdcspath_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="n">pdcspath_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pdcspath_fetch</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">paths_kset</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype_pdcspath</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					   <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/* kobject is now registered */</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		
		<span class="cm">/* Add a nice symlink to the real device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;device&quot;</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdcs_unregister_pathentries - Routine called when unregistering the module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pdcs_unregister_pathentries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdcspath_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="n">pdcspath_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rw_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For now we register the stable subsystem with the firmware subsystem</span>
<span class="cm"> * and the paths subsystem with the stable subsystem</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">pdc_stable_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* find the size of the stable storage */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdcs_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> 
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* make sure we have enough data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdcs_size</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PDCS_PREFIX</span> <span class="s">&quot; facility v%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PDCS_VERSION</span><span class="p">);</span>

	<span class="cm">/* get OSID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">(</span><span class="n">PDCS_ADDR_OSID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* the actual result is 16 bits away */</span>
	<span class="n">pdcs_osid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">result</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* For now we&#39;ll register the directory at /sys/firmware/stable */</span>
	<span class="n">stable_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;stable&quot;</span><span class="p">,</span> <span class="n">firmware_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_firmreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t forget the root entries */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">stable_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdcs_attr_group</span><span class="p">);</span>

	<span class="cm">/* register the paths kset as a child of the stable kset */</span>
	<span class="n">paths_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;paths&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">stable_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paths_kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_ksetreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* now we create all &quot;files&quot; for the paths kset */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">pdcs_register_pathentries</span><span class="p">()))</span>
		<span class="k">goto</span> <span class="n">fail_pdcsreg</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	
<span class="nl">fail_pdcsreg:</span>
	<span class="n">pdcs_unregister_pathentries</span><span class="p">();</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">paths_kset</span><span class="p">);</span>
	
<span class="nl">fail_ksetreg:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">stable_kobj</span><span class="p">);</span>
	
<span class="nl">fail_firmreg:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PDCS_PREFIX</span> <span class="s">&quot; bailing out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">pdc_stable_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pdcs_unregister_pathentries</span><span class="p">();</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">paths_kset</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">stable_kobj</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">pdc_stable_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pdc_stable_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
