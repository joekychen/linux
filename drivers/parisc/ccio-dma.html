<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parisc › ccio-dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ccio-dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** ccio-dma.c:</span>
<span class="cm">**	DMA management routines for first generation cache-coherent machines.</span>
<span class="cm">**	Program U2/Uturn in &quot;Virtual Mode&quot; and use the I/O MMU.</span>
<span class="cm">**</span>
<span class="cm">**	(c) Copyright 2000 Grant Grundler</span>
<span class="cm">**	(c) Copyright 2000 Ryan Bradetich</span>
<span class="cm">**	(c) Copyright 2000 Hewlett-Packard Company</span>
<span class="cm">**</span>
<span class="cm">** This program is free software; you can redistribute it and/or modify</span>
<span class="cm">** it under the terms of the GNU General Public License as published by</span>
<span class="cm">** the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">** (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">**  &quot;Real Mode&quot; operation refers to U2/Uturn chip operation.</span>
<span class="cm">**  U2/Uturn were designed to perform coherency checks w/o using</span>
<span class="cm">**  the I/O MMU - basically what x86 does.</span>
<span class="cm">**</span>
<span class="cm">**  Philipp Rumpf has a &quot;Real Mode&quot; driver for PCX-W machines at:</span>
<span class="cm">**      CVSROOT=:pserver:anonymous@198.186.203.37:/cvsroot/linux-parisc</span>
<span class="cm">**      cvs -z3 co linux/arch/parisc/kernel/dma-rm.c</span>
<span class="cm">**</span>
<span class="cm">**  I&#39;ve rewritten his code to work under TPG&#39;s tree. See ccio-rm-dma.c.</span>
<span class="cm">**</span>
<span class="cm">**  Drawbacks of using Real Mode are:</span>
<span class="cm">**	o outbound DMA is slower - U2 won&#39;t prefetch data (GSC+ XQL signal).</span>
<span class="cm">**      o Inbound DMA less efficient - U2 can&#39;t use DMA_FAST attribute.</span>
<span class="cm">**	o Ability to do scatter/gather in HW is lost.</span>
<span class="cm">**	o Doesn&#39;t work under PCX-U/U+ machines since they didn&#39;t follow</span>
<span class="cm">**        the coherency design originally worked out. Only PCX-W does.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/iommu-helper.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/cache.h&gt;		</span><span class="cm">/* for L1_CACHE_BYTES */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;       </span><span class="cm">/* for register_module() */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/parisc-device.h&gt;</span>

<span class="cm">/* </span>
<span class="cm">** Choose &quot;ccio&quot; since that&#39;s what HP-UX calls it.</span>
<span class="cm">** Make it easier for folks to migrate from one to the other :^)</span>
<span class="cm">*/</span>
<span class="cp">#define MODULE_NAME &quot;ccio&quot;</span>

<span class="cp">#undef DEBUG_CCIO_RES</span>
<span class="cp">#undef DEBUG_CCIO_RUN</span>
<span class="cp">#undef DEBUG_CCIO_INIT</span>
<span class="cp">#undef DEBUG_CCIO_RUN_SG</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* depends on proc fs support. But costs CPU performance. */</span>
<span class="cp">#undef CCIO_COLLECT_STATS</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/runway.h&gt;		</span><span class="cm">/* for proc_runway_root */</span><span class="cp"></span>

<span class="cp">#ifdef DEBUG_CCIO_INIT</span>
<span class="cp">#define DBG_INIT(x...)  printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_INIT(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_CCIO_RUN</span>
<span class="cp">#define DBG_RUN(x...)   printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_CCIO_RES</span>
<span class="cp">#define DBG_RES(x...)   printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RES(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_CCIO_RUN_SG</span>
<span class="cp">#define DBG_RUN_SG(x...) printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN_SG(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#define CCIO_INLINE	inline</span>
<span class="cp">#define WRITE_U32(value, addr) __raw_writel(value, addr)</span>
<span class="cp">#define READ_U32(addr) __raw_readl(addr)</span>

<span class="cp">#define U2_IOA_RUNWAY 0x580</span>
<span class="cp">#define U2_BC_GSC     0x501</span>
<span class="cp">#define UTURN_IOA_RUNWAY 0x581</span>
<span class="cp">#define UTURN_BC_GSC     0x502</span>

<span class="cp">#define IOA_NORMAL_MODE      0x00020080 </span><span class="cm">/* IO_CONTROL to turn on CCIO        */</span><span class="cp"></span>
<span class="cp">#define CMD_TLB_DIRECT_WRITE 35         </span><span class="cm">/* IO_COMMAND for I/O TLB Writes     */</span><span class="cp"></span>
<span class="cp">#define CMD_TLB_PURGE        33         </span><span class="cm">/* IO_COMMAND to Purge I/O TLB entry */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ioa_registers</span> <span class="p">{</span>
        <span class="cm">/* Runway Supervisory Set */</span>
        <span class="kt">int32_t</span>    <span class="n">unused1</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
        <span class="kt">uint32_t</span>   <span class="n">io_command</span><span class="p">;</span>             <span class="cm">/* Offset 12 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_status</span><span class="p">;</span>              <span class="cm">/* Offset 13 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_control</span><span class="p">;</span>             <span class="cm">/* Offset 14 */</span>
        <span class="kt">int32_t</span>    <span class="n">unused2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="cm">/* Runway Auxiliary Register Set */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_err_resp</span><span class="p">;</span>            <span class="cm">/* Offset  0 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_err_info</span><span class="p">;</span>            <span class="cm">/* Offset  1 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_err_req</span><span class="p">;</span>             <span class="cm">/* Offset  2 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_err_resp_hi</span><span class="p">;</span>         <span class="cm">/* Offset  3 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_tlb_entry_m</span><span class="p">;</span>         <span class="cm">/* Offset  4 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_tlb_entry_l</span><span class="p">;</span>         <span class="cm">/* Offset  5 */</span>
        <span class="kt">uint32_t</span>   <span class="n">unused3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">uint32_t</span>   <span class="n">io_pdir_base</span><span class="p">;</span>           <span class="cm">/* Offset  7 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_io_low_hv</span><span class="p">;</span>           <span class="cm">/* Offset  8 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_io_high_hv</span><span class="p">;</span>          <span class="cm">/* Offset  9 */</span>
        <span class="kt">uint32_t</span>   <span class="n">unused4</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">uint32_t</span>   <span class="n">io_chain_id_mask</span><span class="p">;</span>       <span class="cm">/* Offset 11 */</span>
        <span class="kt">uint32_t</span>   <span class="n">unused5</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">uint32_t</span>   <span class="n">io_io_low</span><span class="p">;</span>              <span class="cm">/* Offset 14 */</span>
        <span class="kt">uint32_t</span>   <span class="n">io_io_high</span><span class="p">;</span>             <span class="cm">/* Offset 15 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">** IOA Registers</span>
<span class="cm">** -------------</span>
<span class="cm">**</span>
<span class="cm">** Runway IO_CONTROL Register (+0x38)</span>
<span class="cm">** </span>
<span class="cm">** The Runway IO_CONTROL register controls the forwarding of transactions.</span>
<span class="cm">**</span>
<span class="cm">** | 0  ...  13  |  14 15 | 16 ... 21 | 22 | 23 24 |  25 ... 31 |</span>
<span class="cm">** |    HV       |   TLB  |  reserved | HV | mode  |  reserved  |</span>
<span class="cm">**</span>
<span class="cm">** o mode field indicates the address translation of transactions</span>
<span class="cm">**   forwarded from Runway to GSC+:</span>
<span class="cm">**       Mode Name     Value        Definition</span>
<span class="cm">**       Off (default)   0          Opaque to matching addresses.</span>
<span class="cm">**       Include         1          Transparent for matching addresses.</span>
<span class="cm">**       Peek            3          Map matching addresses.</span>
<span class="cm">**</span>
<span class="cm">**       + &quot;Off&quot; mode: Runway transactions which match the I/O range</span>
<span class="cm">**         specified by the IO_IO_LOW/IO_IO_HIGH registers will be ignored.</span>
<span class="cm">**       + &quot;Include&quot; mode: all addresses within the I/O range specified</span>
<span class="cm">**         by the IO_IO_LOW and IO_IO_HIGH registers are transparently</span>
<span class="cm">**         forwarded. This is the I/O Adapter&#39;s normal operating mode.</span>
<span class="cm">**       + &quot;Peek&quot; mode: used during system configuration to initialize the</span>
<span class="cm">**         GSC+ bus. Runway Write_Shorts in the address range specified by</span>
<span class="cm">**         IO_IO_LOW and IO_IO_HIGH are forwarded through the I/O Adapter</span>
<span class="cm">**         *AND* the GSC+ address is remapped to the Broadcast Physical</span>
<span class="cm">**         Address space by setting the 14 high order address bits of the</span>
<span class="cm">**         32 bit GSC+ address to ones.</span>
<span class="cm">**</span>
<span class="cm">** o TLB field affects transactions which are forwarded from GSC+ to Runway.</span>
<span class="cm">**   &quot;Real&quot; mode is the poweron default.</span>
<span class="cm">** </span>
<span class="cm">**   TLB Mode  Value  Description</span>
<span class="cm">**   Real        0    No TLB translation. Address is directly mapped and the</span>
<span class="cm">**                    virtual address is composed of selected physical bits.</span>
<span class="cm">**   Error       1    Software fills the TLB manually.</span>
<span class="cm">**   Normal      2    IOA fetches IO TLB misses from IO PDIR (in host memory).</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** IO_IO_LOW_HV	  +0x60 (HV dependent)</span>
<span class="cm">** IO_IO_HIGH_HV  +0x64 (HV dependent)</span>
<span class="cm">** IO_IO_LOW      +0x78	(Architected register)</span>
<span class="cm">** IO_IO_HIGH     +0x7c	(Architected register)</span>
<span class="cm">**</span>
<span class="cm">** IO_IO_LOW and IO_IO_HIGH set the lower and upper bounds of the</span>
<span class="cm">** I/O Adapter address space, respectively.</span>
<span class="cm">**</span>
<span class="cm">** 0  ... 7 | 8 ... 15 |  16   ...   31 |</span>
<span class="cm">** 11111111 | 11111111 |      address   |</span>
<span class="cm">**</span>
<span class="cm">** Each LOW/HIGH pair describes a disjoint address space region.</span>
<span class="cm">** (2 per GSC+ port). Each incoming Runway transaction address is compared</span>
<span class="cm">** with both sets of LOW/HIGH registers. If the address is in the range</span>
<span class="cm">** greater than or equal to IO_IO_LOW and less than IO_IO_HIGH the transaction</span>
<span class="cm">** for forwarded to the respective GSC+ bus.</span>
<span class="cm">** Specify IO_IO_LOW equal to or greater than IO_IO_HIGH to avoid specifying</span>
<span class="cm">** an address space region.</span>
<span class="cm">**</span>
<span class="cm">** In order for a Runway address to reside within GSC+ extended address space:</span>
<span class="cm">**	Runway Address [0:7]    must identically compare to 8&#39;b11111111</span>
<span class="cm">**	Runway Address [8:11]   must be equal to IO_IO_LOW(_HV)[16:19]</span>
<span class="cm">** 	Runway Address [12:23]  must be greater than or equal to</span>
<span class="cm">**	           IO_IO_LOW(_HV)[20:31] and less than IO_IO_HIGH(_HV)[20:31].</span>
<span class="cm">**	Runway Address [24:39]  is not used in the comparison.</span>
<span class="cm">**</span>
<span class="cm">** When the Runway transaction is forwarded to GSC+, the GSC+ address is</span>
<span class="cm">** as follows:</span>
<span class="cm">**	GSC+ Address[0:3]	4&#39;b1111</span>
<span class="cm">**	GSC+ Address[4:29]	Runway Address[12:37]</span>
<span class="cm">**	GSC+ Address[30:31]	2&#39;b00</span>
<span class="cm">**</span>
<span class="cm">** All 4 Low/High registers must be initialized (by PDC) once the lower bus</span>
<span class="cm">** is interrogated and address space is defined. The operating system will</span>
<span class="cm">** modify the architectural IO_IO_LOW and IO_IO_HIGH registers following</span>
<span class="cm">** the PDC initialization.  However, the hardware version dependent IO_IO_LOW</span>
<span class="cm">** and IO_IO_HIGH registers should not be subsequently altered by the OS.</span>
<span class="cm">** </span>
<span class="cm">** Writes to both sets of registers will take effect immediately, bypassing</span>
<span class="cm">** the queues, which ensures that subsequent Runway transactions are checked</span>
<span class="cm">** against the updated bounds values. However reads are queued, introducing</span>
<span class="cm">** the possibility of a read being bypassed by a subsequent write to the same</span>
<span class="cm">** register. This sequence can be avoided by having software wait for read</span>
<span class="cm">** returns before issuing subsequent writes.</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">ioc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioa_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioc_regs</span><span class="p">;</span>  <span class="cm">/* I/O MMU base address */</span>
	<span class="n">u8</span>  <span class="o">*</span><span class="n">res_map</span><span class="p">;</span>	                <span class="cm">/* resource map, bit == pdir entry */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdir_base</span><span class="p">;</span>	                <span class="cm">/* physical base address */</span>
	<span class="n">u32</span> <span class="n">pdir_size</span><span class="p">;</span> 			<span class="cm">/* bytes, function of IOV Space size */</span>
	<span class="n">u32</span> <span class="n">res_hint</span><span class="p">;</span>	                <span class="cm">/* next available IOVP - </span>
<span class="cm">					   circular search */</span>
	<span class="n">u32</span> <span class="n">res_size</span><span class="p">;</span>		    	<span class="cm">/* size of resource map in bytes */</span>
	<span class="n">spinlock_t</span> <span class="n">res_lock</span><span class="p">;</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
<span class="cp">#define CCIO_SEARCH_SAMPLE 0x100</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_search</span><span class="p">[</span><span class="n">CCIO_SEARCH_SAMPLE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_idx</span><span class="p">;</span>		  <span class="cm">/* current index into avg_search */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msingle_calls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msingle_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg_calls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usingle_calls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usingle_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usg_calls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usg_pages</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cujo20_bug</span><span class="p">;</span>

	<span class="cm">/* STUFF We don&#39;t need in performance path */</span>
	<span class="n">u32</span> <span class="n">chainid_shift</span><span class="p">;</span> 		<span class="cm">/* specify bit location of chain_id */</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* Linked list of discovered iocs */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* device name from firmware */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hw_path</span><span class="p">;</span>           <span class="cm">/* the hardware path this ioc is associatd with */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">fake_pci_dev</span><span class="p">;</span>   <span class="cm">/* the fake pci_dev for non-pci devs */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">mmio_region</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* The &quot;routed&quot; MMIO regions */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc_list</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ioc_count</span><span class="p">;</span>

<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   I/O Pdir Resource Management</span>
<span class="cm">*</span>
<span class="cm">*   Bits set in the resource map are in use.</span>
<span class="cm">*   Each bit can represent a number of pages.</span>
<span class="cm">*   LSbs represent lower addresses (IOVA&#39;s).</span>
<span class="cm">*</span>
<span class="cm">*   This was was copied from sba_iommu.c. Don&#39;t try to unify</span>
<span class="cm">*   the two resource managers unless a way to have different</span>
<span class="cm">*   allocation policies is also adjusted. We&#39;d like to avoid</span>
<span class="cm">*   I/O TLB thrashing by having resource allocation policy</span>
<span class="cm">*   match the I/O TLB replacement policy.</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>
<span class="cp">#define IOVP_SIZE PAGE_SIZE</span>
<span class="cp">#define IOVP_SHIFT PAGE_SHIFT</span>
<span class="cp">#define IOVP_MASK PAGE_MASK</span>

<span class="cm">/* Convert from IOVP to IOVA and vice versa. */</span>
<span class="cp">#define CCIO_IOVA(iovp,offset) ((iovp) | (offset))</span>
<span class="cp">#define CCIO_IOVP(iova) ((iova) &amp; IOVP_MASK)</span>

<span class="cp">#define PDIR_INDEX(iovp)    ((iovp)&gt;&gt;IOVP_SHIFT)</span>
<span class="cp">#define MKIOVP(pdir_idx)    ((long)(pdir_idx) &lt;&lt; IOVP_SHIFT)</span>
<span class="cp">#define MKIOVA(iovp,offset) (dma_addr_t)((long)iovp | (long)offset)</span>

<span class="cm">/*</span>
<span class="cm">** Don&#39;t worry about the 150% average search length on a miss.</span>
<span class="cm">** If the search wraps around, and passes the res_hint, it will</span>
<span class="cm">** cause the kernel to panic anyhow.</span>
<span class="cm">*/</span>
<span class="cp">#define CCIO_SEARCH_LOOP(ioc, res_idx, mask, size)  \</span>
<span class="cp">       for(; res_ptr &lt; res_end; ++res_ptr) { \</span>
<span class="cp">		int ret;\</span>
<span class="cp">		unsigned int idx;\</span>
<span class="cp">		idx = (unsigned int)((unsigned long)res_ptr - (unsigned long)ioc-&gt;res_map); \</span>
<span class="cp">		ret = iommu_is_span_boundary(idx &lt;&lt; 3, pages_needed, 0, boundary_size);\</span>
<span class="cp">		if ((0 == (*res_ptr &amp; mask)) &amp;&amp; !ret) { \</span>
<span class="cp">			*res_ptr |= mask; \</span>
<span class="cp">			res_idx = idx;\</span>
<span class="cp">			ioc-&gt;res_hint = res_idx + (size &gt;&gt; 3); \</span>
<span class="cp">			goto resource_found; \</span>
<span class="cp">		} \</span>
<span class="cp">	}</span>

<span class="cp">#define CCIO_FIND_FREE_MAPPING(ioa, res_idx, mask, size) \</span>
<span class="cp">       u##size *res_ptr = (u##size *)&amp;((ioc)-&gt;res_map[ioa-&gt;res_hint &amp; ~((size &gt;&gt; 3) - 1)]); \</span>
<span class="cp">       u##size *res_end = (u##size *)&amp;(ioc)-&gt;res_map[ioa-&gt;res_size]; \</span>
<span class="cp">       CCIO_SEARCH_LOOP(ioc, res_idx, mask, size); \</span>
<span class="cp">       res_ptr = (u##size *)&amp;(ioc)-&gt;res_map[0]; \</span>
<span class="cp">       CCIO_SEARCH_LOOP(ioa, res_idx, mask, size);</span>

<span class="cm">/*</span>
<span class="cm">** Find available bit in this ioa&#39;s resource map.</span>
<span class="cm">** Use a &quot;circular&quot; search:</span>
<span class="cm">**   o Most IOVA&#39;s are &quot;temporary&quot; - avg search time should be small.</span>
<span class="cm">** o keep a history of what happened for debugging</span>
<span class="cm">** o KISS.</span>
<span class="cm">**</span>
<span class="cm">** Perf optimizations:</span>
<span class="cm">** o search for log2(size) bits at a time.</span>
<span class="cm">** o search for available resource bits using byte/word/whatever.</span>
<span class="cm">** o use different search for &quot;large&quot; (eg &gt; 4 pages) or &quot;very large&quot;</span>
<span class="cm">**   (eg &gt; 16 pages) mappings.</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_alloc_range - Allocate pages in the ioc&#39;s resource map.</span>
<span class="cm"> * @ioc: The I/O Controller.</span>
<span class="cm"> * @pages_needed: The requested number of pages to be mapped into the</span>
<span class="cm"> * I/O Pdir...</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches the resource map of the ioc to locate a range</span>
<span class="cm"> * of available pages for the requested size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ccio_alloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boundary_size</span><span class="p">;</span>
<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr_start</span> <span class="o">=</span> <span class="n">mfctl</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="cp">#endif</span>
	
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages_needed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">pages_needed</span> <span class="o">*</span> <span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">);</span>
     
	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s() size: %d pages_needed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** &quot;seek and ye shall find&quot;...praying never hurts either...</span>
<span class="cm">	** ggg sacrifices another 710 to the computer gods.</span>
<span class="cm">	*/</span>

	<span class="n">boundary_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">IOVP_SHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * LAN traffic will not thrash the TLB IFF the same NIC</span>
<span class="cm">		 * uses 8 adjacent pages to map separate payload data.</span>
<span class="cm">		 * ie the same byte in the resource bit map.</span>
<span class="cm">		 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* FIXME: bit search should shift it&#39;s way through</span>
<span class="c">		 * an unsigned long - not byte at a time. As it is now,</span>
<span class="c">		 * we effectively allocate this byte to this mapping.</span>
<span class="c">		 */</span>
<span class="c">		unsigned long mask = ~(~0UL &gt;&gt; pages_needed);</span>
<span class="c">		CCIO_FIND_FREE_MAPPING(ioc, res_idx, mask, 8);</span>
<span class="cp">#else</span>
		<span class="n">CCIO_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#ifdef __LP64__</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: %s() Too many pages to map. pages_needed: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: %s() I/O MMU is out of mapping resources.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span>
	      <span class="n">__func__</span><span class="p">);</span>
	
<span class="nl">resource_found:</span>
	
	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s() res_idx %d res_hint: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr_end</span> <span class="o">=</span> <span class="n">mfctl</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cr_end</span> <span class="o">-</span> <span class="n">cr_start</span><span class="p">;</span>
		<span class="cm">/* check for roll over */</span>
		<span class="n">cr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">cr_end</span> <span class="o">&lt;</span> <span class="n">cr_start</span><span class="p">)</span> <span class="o">?</span>  <span class="o">-</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cr_start</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span> <span class="o">&amp;=</span> <span class="n">CCIO_SEARCH_SAMPLE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">+=</span> <span class="n">pages_needed</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* </span>
<span class="cm">	** return the bit address.</span>
<span class="cm">	*/</span>
	<span class="k">return</span> <span class="n">res_idx</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CCIO_FREE_MAPPINGS(ioc, res_idx, mask, size) \</span>
<span class="cp">        u##size *res_ptr = (u##size *)&amp;((ioc)-&gt;res_map[res_idx]); \</span>
<span class="cp">        BUG_ON((*res_ptr &amp; mask) != mask); \</span>
<span class="cp">        *res_ptr &amp;= ~(mask);</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_free_range - Free pages from the ioc&#39;s resource map.</span>
<span class="cm"> * @ioc: The I/O Controller.</span>
<span class="cm"> * @iova: The I/O Virtual Address.</span>
<span class="cm"> * @pages_mapped: The requested number of pages to be freed from the</span>
<span class="cm"> * I/O Pdir.</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the resouces allocated for the iova.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ccio_free_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_mapped</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp</span> <span class="o">=</span> <span class="n">CCIO_IOVP</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_idx</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">pages_mapped</span> <span class="o">*</span> <span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&gt;</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s():  res_idx: %d pages_mapped %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">__func__</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="n">pages_mapped</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">-=</span> <span class="n">pages_mapped</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* see matching comments in alloc_range */</span>
<span class="c">		unsigned long mask = ~(~0UL &gt;&gt; pages_mapped);</span>
<span class="c">		CCIO_FREE_MAPPINGS(ioc, res_idx, mask, 8);</span>
<span class="cp">#else</span>
		<span class="n">CCIO_FREE_MAPPINGS</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="mh">0xffUL</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FREE_MAPPINGS</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="mh">0xffffUL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FREE_MAPPINGS</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#ifdef __LP64__</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CCIO_FREE_MAPPINGS</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_idx</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s:%s() Too many pages to unmap.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/****************************************************************</span>
<span class="cm">**</span>
<span class="cm">**          CCIO dma_ops support routines</span>
<span class="cm">**</span>
<span class="cm">*****************************************************************/</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">space_t</span><span class="p">;</span>
<span class="cp">#define KERNEL_SPACE 0</span>

<span class="cm">/*</span>
<span class="cm">** DMA &quot;Page Type&quot; and Hints </span>
<span class="cm">** o if SAFE_DMA isn&#39;t set, mapping is for FAST_DMA. SAFE_DMA should be</span>
<span class="cm">**   set for subcacheline DMA transfers since we don&#39;t want to damage the</span>
<span class="cm">**   other part of a cacheline.</span>
<span class="cm">** o SAFE_DMA must be set for &quot;memory&quot; allocated via pci_alloc_consistent().</span>
<span class="cm">**   This bit tells U2 to do R/M/W for partial cachelines. &quot;Streaming&quot;</span>
<span class="cm">**   data can avoid this if the mapping covers full cache lines.</span>
<span class="cm">** o STOP_MOST is needed for atomicity across cachelines.</span>
<span class="cm">**   Apparently only &quot;some EISA devices&quot; need this.</span>
<span class="cm">**   Using CONFIG_ISA is hack. Only the IOA with EISA under it needs</span>
<span class="cm">**   to use this hint iff the EISA devices needs this feature.</span>
<span class="cm">**   According to the U2 ERS, STOP_MOST enabled pages hurt performance.</span>
<span class="cm">** o PREFETCH should *not* be set for cases like Multiple PCI devices</span>
<span class="cm">**   behind GSCtoPCI (dino) bus converter. Only one cacheline per GSC</span>
<span class="cm">**   device can be fetched and multiply DMA streams will thrash the</span>
<span class="cm">**   prefetch buffer and burn memory bandwidth. See 6.7.3 &quot;Prefetch Rules</span>
<span class="cm">**   and Invalidation of Prefetch Entries&quot;.</span>
<span class="cm">**</span>
<span class="cm">** FIXME: the default hints need to be per GSC device - not global.</span>
<span class="cm">** </span>
<span class="cm">** HP-UX dorks: linux device driver programming model is totally different</span>
<span class="cm">**    than HP-UX&#39;s. HP-UX always sets HINT_PREFETCH since it&#39;s drivers</span>
<span class="cm">**    do special things to work on non-coherent platforms...linux has to</span>
<span class="cm">**    be much more careful with this.</span>
<span class="cm">*/</span>
<span class="cp">#define IOPDIR_VALID    0x01UL</span>
<span class="cp">#define HINT_SAFE_DMA   0x02UL	</span><span class="cm">/* used for pci_alloc_consistent() pages */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_EISA</span>
<span class="cp">#define HINT_STOP_MOST  0x04UL	</span><span class="cm">/* LSL support */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define HINT_STOP_MOST  0x00UL	</span><span class="cm">/* only needed for &quot;some EISA devices&quot; */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define HINT_UDPATE_ENB 0x08UL  </span><span class="cm">/* not used/supported by U2 */</span><span class="cp"></span>
<span class="cp">#define HINT_PREFETCH   0x10UL	</span><span class="cm">/* for outbound pages which are not SAFE */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm">** Use direction (ie PCI_DMA_TODEVICE) to pick hint.</span>
<span class="cm">** ccio_alloc_consistent() depends on this to get SAFE_DMA</span>
<span class="cm">** when it passes in BIDIRECTIONAL flag.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">hint_lookup</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HINT_STOP_MOST</span> <span class="o">|</span> <span class="n">HINT_SAFE_DMA</span> <span class="o">|</span> <span class="n">IOPDIR_VALID</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PCI_DMA_TODEVICE</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HINT_STOP_MOST</span> <span class="o">|</span> <span class="n">HINT_PREFETCH</span> <span class="o">|</span> <span class="n">IOPDIR_VALID</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PCI_DMA_FROMDEVICE</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HINT_STOP_MOST</span> <span class="o">|</span> <span class="n">IOPDIR_VALID</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_io_pdir_entry - Initialize an I/O Pdir.</span>
<span class="cm"> * @pdir_ptr: A pointer into I/O Pdir.</span>
<span class="cm"> * @sid: The Space Identifier.</span>
<span class="cm"> * @vba: The virtual address.</span>
<span class="cm"> * @hints: The DMA Hint.</span>
<span class="cm"> *</span>
<span class="cm"> * Given a virtual address (vba, arg2) and space id, (sid, arg1),</span>
<span class="cm"> * load the I/O PDIR entry pointed to by pdir_ptr (arg0). Each IO Pdir</span>
<span class="cm"> * entry consists of 8 bytes as shown below (MSB == bit 0):</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * WORD 0:</span>
<span class="cm"> * +------+----------------+-----------------------------------------------+</span>
<span class="cm"> * | Phys | Virtual Index  |               Phys                            |</span>
<span class="cm"> * | 0:3  |     0:11       |               4:19                            |</span>
<span class="cm"> * |4 bits|   12 bits      |              16 bits                          |</span>
<span class="cm"> * +------+----------------+-----------------------------------------------+</span>
<span class="cm"> * WORD 1:</span>
<span class="cm"> * +-----------------------+-----------------------------------------------+</span>
<span class="cm"> * |      Phys    |  Rsvd  | Prefetch |Update |Rsvd  |Lock  |Safe  |Valid  |</span>
<span class="cm"> * |     20:39    |        | Enable   |Enable |      |Enable|DMA   |       |</span>
<span class="cm"> * |    20 bits   | 5 bits | 1 bit    |1 bit  |2 bits|1 bit |1 bit |1 bit  |</span>
<span class="cm"> * +-----------------------+-----------------------------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * The virtual index field is filled with the results of the LCI</span>
<span class="cm"> * (Load Coherence Index) instruction.  The 8 bits used for the virtual</span>
<span class="cm"> * index are bits 12:19 of the value returned by LCI.</span>
<span class="cm"> */</span> 
<span class="k">static</span> <span class="kt">void</span> <span class="n">CCIO_INLINE</span>
<span class="nf">ccio_io_pdir_entry</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">pdir_ptr</span><span class="p">,</span> <span class="n">space_t</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vba</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hints</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pa</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ci</span><span class="p">;</span> <span class="cm">/* coherent index */</span>

	<span class="cm">/* We currently only support kernel addresses */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sid</span> <span class="o">!=</span> <span class="n">KERNEL_SPACE</span><span class="p">);</span>

	<span class="n">mtsp</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** WORD 1 - low order word</span>
<span class="cm">	** &quot;hints&quot; parm includes the VALID bit!</span>
<span class="cm">	** &quot;dep&quot; clobbers the physical address offset bits as well.</span>
<span class="cm">	*/</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">vba</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;depw  %1,31,12,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">hints</span><span class="p">));</span>
	<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">pdir_ptr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pa</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** WORD 0 - high order word</span>
<span class="cm">	*/</span>

<span class="cp">#ifdef __LP64__</span>
	<span class="cm">/*</span>
<span class="cm">	** get bits 12:15 of physical address</span>
<span class="cm">	** shift bits 16:31 of physical address</span>
<span class="cm">	** and deposit them</span>
<span class="cm">	*/</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;extrd,u %1,15,4,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">));</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;extrd,u %1,31,16,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">));</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;depd  %1,35,4,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	** get CPU coherency index bits</span>
<span class="cm">	** Grab virtual index [0:11]</span>
<span class="cm">	** Deposit virt_idx bits into I/O PDIR word</span>
<span class="cm">	*/</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;lci %%r0(%%sr1, %1), %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">vba</span><span class="p">));</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;extru %1,19,12,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">));</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;depw  %1,15,12,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">));</span>

	<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">pdir_ptr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pa</span><span class="p">;</span>


	<span class="cm">/* FIXME: PCX_W platforms don&#39;t need FDC/SYNC. (eg C360)</span>
<span class="cm">	**        PCX-U/U+ do. (eg C200/C240)</span>
<span class="cm">	**        PCX-T&#39;? Don&#39;t know. (eg C110 or similar K-class)</span>
<span class="cm">	**</span>
<span class="cm">	** See PDC_MODEL/option 0/SW_CAP word for &quot;Non-coherent IO-PDIR bit&quot;.</span>
<span class="cm">	** Hopefully we can patch (NOP) these out at boot time somehow.</span>
<span class="cm">	**</span>
<span class="cm">	** &quot;Since PCX-U employs an offset hash that is incompatible with</span>
<span class="cm">	** the real mode coherence index generation of U2, the PDIR entry</span>
<span class="cm">	** must be flushed to memory to retain coherence.&quot;</span>
<span class="cm">	*/</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;fdc %%r0(%0)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pdir_ptr</span><span class="p">));</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_clear_io_tlb - Remove stale entries from the I/O TLB.</span>
<span class="cm"> * @ioc: The I/O Controller.</span>
<span class="cm"> * @iovp: The I/O Virtual Page.</span>
<span class="cm"> * @byte_cnt: The requested number of bytes to be freed from the I/O Pdir.</span>
<span class="cm"> *</span>
<span class="cm"> * Purge invalid I/O PDIR entries from the I/O TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Can we change the byte_cnt to pages_mapped?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">CCIO_INLINE</span> <span class="kt">void</span>
<span class="nf">ccio_clear_io_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iovp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">chain_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">chainid_shift</span><span class="p">;</span>

	<span class="n">iovp</span> <span class="o">&amp;=</span> <span class="n">IOVP_MASK</span><span class="p">;</span>	<span class="cm">/* clear offset bits, just want pagenum */</span>
	<span class="n">byte_cnt</span> <span class="o">+=</span> <span class="n">chain_size</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="n">chain_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WRITE_U32</span><span class="p">(</span><span class="n">CMD_TLB_PURGE</span> <span class="o">|</span> <span class="n">iovp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_command</span><span class="p">);</span>
		<span class="n">iovp</span> <span class="o">+=</span> <span class="n">chain_size</span><span class="p">;</span>
		<span class="n">byte_cnt</span> <span class="o">-=</span> <span class="n">chain_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_mark_invalid - Mark the I/O Pdir entries invalid.</span>
<span class="cm"> * @ioc: The I/O Controller.</span>
<span class="cm"> * @iova: The I/O Virtual Address.</span>
<span class="cm"> * @byte_cnt: The requested number of bytes to be freed from the I/O Pdir.</span>
<span class="cm"> *</span>
<span class="cm"> * Mark the I/O Pdir entries invalid and blow away the corresponding I/O</span>
<span class="cm"> * TLB entries.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: at some threshold it might be &quot;cheaper&quot; to just blow</span>
<span class="cm"> *        away the entire I/O TLB instead of individual entries.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Uturn has 256 TLB entries. We don&#39;t need to purge every</span>
<span class="cm"> *        PDIR entry - just once for each possible TLB entry.</span>
<span class="cm"> *        (We do need to maker I/O PDIR entries invalid regardless).</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Can we change byte_cnt to pages_mapped?</span>
<span class="cm"> */</span> 
<span class="k">static</span> <span class="n">CCIO_INLINE</span> <span class="kt">void</span>
<span class="nf">ccio_mark_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">CCIO_IOVP</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">saved_byte_cnt</span><span class="p">;</span>

	<span class="cm">/* round up to nearest page size */</span>
	<span class="n">saved_byte_cnt</span> <span class="o">=</span> <span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">byte_cnt</span><span class="p">,</span> <span class="n">IOVP_SIZE</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* invalidate one page at a time */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">pdir_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)));</span>
		<span class="n">pdir_ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* clear only VALID bit */</span> 
		<span class="cm">/*</span>
<span class="cm">		** FIXME: PCX_W platforms don&#39;t need FDC/SYNC. (eg C360)</span>
<span class="cm">		**   PCX-U/U+ do. (eg C200/C240)</span>
<span class="cm">		** See PDC_MODEL/option 0/SW_CAP for &quot;Non-coherent IO-PDIR bit&quot;.</span>
<span class="cm">		**</span>
<span class="cm">		** Hopefully someone figures out how to patch (NOP) the</span>
<span class="cm">		** FDC/SYNC out at boot time.</span>
<span class="cm">		*/</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;fdc %%r0(%0)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pdir_ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]));</span>

		<span class="n">iovp</span>     <span class="o">+=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
		<span class="n">byte_cnt</span> <span class="o">-=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span><span class="p">);</span>
	<span class="n">ccio_clear_io_tlb</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">CCIO_IOVP</span><span class="p">(</span><span class="n">iova</span><span class="p">),</span> <span class="n">saved_byte_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************</span>
<span class="cm">**</span>
<span class="cm">**          CCIO dma_ops</span>
<span class="cm">**</span>
<span class="cm">*****************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_dma_supported - Verify the IOMMU supports the DMA address range.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @mask: A bit mask describing the DMA address range of the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_dma_supported function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> 
<span class="nf">ccio_dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: EISA/ISA/et al not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* only support 32-bit devices (ie PCI/GSC) */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">mask</span> <span class="o">==</span> <span class="mh">0xffffffffUL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_map_single - Map an address range into the IOMMU.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @addr: The start address of the DMA region.</span>
<span class="cm"> * @size: The length of the DMA region.</span>
<span class="cm"> * @direction: The direction of the DMA transaction (to/from device).</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_map_single function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> 
<span class="nf">ccio_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iovp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdir_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hint</span> <span class="o">=</span> <span class="n">hint_lookup</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">direction</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* save offset bits */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">;</span>

	<span class="cm">/* round up to nearest IOVP_SIZE */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">IOVP_SIZE</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">ccio_alloc_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">MKIOVP</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

	<span class="n">pdir_start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() 0x%p -&gt; 0x%lx size: %0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">iovp</span> <span class="o">|</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* If not cacheline aligned, force SAFE_DMA on the whole mess */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">size</span> <span class="o">%</span> <span class="n">L1_CACHE_BYTES</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">%</span> <span class="n">L1_CACHE_BYTES</span><span class="p">))</span>
		<span class="n">hint</span> <span class="o">|=</span> <span class="n">HINT_SAFE_DMA</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ccio_io_pdir_entry</span><span class="p">(</span><span class="n">pdir_start</span><span class="p">,</span> <span class="n">KERNEL_SPACE</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">hint</span><span class="p">);</span>

		<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot; pdir %p %08x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pdir_start</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">1</span><span class="p">]));</span>
		<span class="o">++</span><span class="n">pdir_start</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* form complete address */</span>
	<span class="k">return</span> <span class="n">CCIO_IOVA</span><span class="p">(</span><span class="n">iovp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_unmap_single - Unmap an address range from the IOMMU.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @addr: The start address of the DMA region.</span>
<span class="cm"> * @size: The length of the DMA region.</span>
<span class="cm"> * @direction: The direction of the DMA transaction (to/from device).</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_unmap_single function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">ccio_unmap_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> 
		  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> 
	<span class="n">dma_addr_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">iova</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">;</span>
	
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() iovp 0x%lx/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">^=</span> <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* clear offset bits */</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">IOVP_SIZE</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_calls</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_pages</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ccio_mark_invalid</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ccio_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_alloc_consistent - Allocate a consistent DMA mapping.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @size: The length of the DMA region.</span>
<span class="cm"> * @dma_handle: The DMA address handed back to the device (not the cpu).</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_alloc_consistent function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> 
<span class="nf">ccio_alloc_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* GRANT Need to establish hierarchy for non-PCI devs as well</span>
<span class="c">** and then provide matching gsc_map_xxx() functions for them as well.</span>
<span class="c">*/</span>
<span class="c">	if(!hwdev) {</span>
<span class="c">		/* only support PCI */</span>
<span class="c">		*dma_handle = 0;</span>
<span class="c">		return 0;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">ccio_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_free_consistent - Free a consistent DMA mapping.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @size: The length of the DMA region.</span>
<span class="cm"> * @cpu_addr: The cpu address returned from the ccio_alloc_consistent.</span>
<span class="cm"> * @dma_handle: The device address returned from the ccio_alloc_consistent.</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_free_consistent function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">ccio_free_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> 
		     <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ccio_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Since 0 is a valid pdir_base index value, can&#39;t use that</span>
<span class="cm">** to determine if a value is valid or not. Use a flag to indicate</span>
<span class="cm">** the SG list entry contains a valid pdir index.</span>
<span class="cm">*/</span>
<span class="cp">#define PIDE_FLAG 0x80000000UL</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
<span class="cp">#define IOMMU_MAP_STATS</span>
<span class="cp">#endif</span>
<span class="cp">#include &quot;iommu-helpers.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_map_sg - Map the scatter/gather list into the IOMMU.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @sglist: The scatter/gather list to be mapped in the IOMMU.</span>
<span class="cm"> * @nents: The number of entries in the scatter/gather list.</span>
<span class="cm"> * @direction: The direction of the DMA transaction (to/from device).</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_map_sg function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ccio_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> 
	    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coalesced</span><span class="p">,</span> <span class="n">filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hint</span> <span class="o">=</span> <span class="n">hint_lookup</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">direction</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

	<span class="cm">/* Fast path single entry scatterlists. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">=</span> <span class="n">ccio_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				<span class="n">direction</span><span class="p">);</span>
		<span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">prev_len</span> <span class="o">+=</span> <span class="n">sglist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	** First coalesce the chunks and allocate I/O pdir space</span>
<span class="cm">	**</span>
<span class="cm">	** If this is one DMA stream, we can properly map using the</span>
<span class="cm">	** correct virtual address associated with each DMA page.</span>
<span class="cm">	** w/o this association, we wouldn&#39;t have coherent DMA!</span>
<span class="cm">	** Access to the virtual address is what forces a two pass algorithm.</span>
<span class="cm">	*/</span>
	<span class="n">coalesced</span> <span class="o">=</span> <span class="n">iommu_coalesce_chunks</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">ccio_alloc_range</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Program the I/O Pdir</span>
<span class="cm">	**</span>
<span class="cm">	** map the virtual addresses to the I/O Pdir</span>
<span class="cm">	** o dma_address will contain the pdir index</span>
<span class="cm">	** o dma_len will contain the number of bytes to map </span>
<span class="cm">	** o page/offset contain the virtual address.</span>
<span class="cm">	*/</span>
	<span class="n">filled</span> <span class="o">=</span> <span class="n">iommu_fill_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">ccio_io_pdir_entry</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">coalesced</span> <span class="o">!=</span> <span class="n">filled</span><span class="p">);</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE %d mappings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">filled</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">filled</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">current_len</span> <span class="o">+=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current_len</span> <span class="o">!=</span> <span class="n">prev_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">filled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_unmap_sg - Unmap the scatter/gather list from the IOMMU.</span>
<span class="cm"> * @dev: The PCI device.</span>
<span class="cm"> * @sglist: The scatter/gather list to be unmapped from the IOMMU.</span>
<span class="cm"> * @nents: The number of entries in the scatter/gather list.</span>
<span class="cm"> * @direction: The direction of the DMA transaction (to/from device).</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the pci_unmap_sg function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">ccio_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> 
	      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries,  %08lx,%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">while</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nents</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span> <span class="o">+=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">ccio_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span>
				  <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">direction</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sglist</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE (nents %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hppa_dma_ops</span> <span class="n">ccio_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_supported</span> <span class="o">=</span>	<span class="n">ccio_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_consistent</span> <span class="o">=</span>	<span class="n">ccio_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_noncoherent</span> <span class="o">=</span>	<span class="n">ccio_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_consistent</span> <span class="o">=</span>	<span class="n">ccio_free_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_single</span> <span class="o">=</span>		<span class="n">ccio_map_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_single</span> <span class="o">=</span>		<span class="n">ccio_unmap_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span> <span class="o">=</span> 		<span class="n">ccio_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span> <span class="o">=</span> 		<span class="n">ccio_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_cpu</span> <span class="o">=</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* NOP for U2/Uturn */</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_device</span> <span class="o">=</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* NOP for U2/Uturn */</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_cpu</span> <span class="o">=</span>		<span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* ditto */</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_device</span> <span class="o">=</span>		<span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* ditto */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ccio_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ioc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Cujo 2.0 bug    : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">cujo20_bug</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">));</span>
		
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;IO PDIR size    : %d bytes (%d entries)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">total_pages</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">total_pages</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;IO PDIR entries : %ld free  %ld used (%d%%)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">total_pages</span> <span class="o">-</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">total_pages</span><span class="p">));</span>
<span class="cp">#endif</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Resource bitmap : %d bytes (%d pages)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
				  <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">,</span> <span class="n">total_pages</span><span class="p">);</span>

<span class="cp">#ifdef CCIO_COLLECT_STATS</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CCIO_SEARCH_SAMPLE</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avg</span> <span class="o">+=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> 
				<span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> 
				<span class="n">min</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">avg</span> <span class="o">/=</span> <span class="n">CCIO_SEARCH_SAMPLE</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">min</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_map_single(): %8ld calls  %8ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="p">));</span>

		<span class="cm">/* KLUGE - unmap_sg calls unmap_single for each mapped page */</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_calls</span> <span class="o">-</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_pages</span> <span class="o">-</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_unmap_single: %8ld calls  %8ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">max</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">min</span><span class="p">));</span>
 
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_map_sg()    : %8ld calls  %8ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_pages</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="p">));</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_unmap_sg()  : %8ld calls  %8ld pages (avg %d/1000)</span><span class="se">\n\n\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="p">));</span>
<span class="cp">#endif	</span><span class="cm">/* CCIO_COLLECT_STATS */</span><span class="cp"></span>

		<span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ccio_proc_info_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ccio_proc_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ccio_proc_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ccio_proc_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ccio_proc_bitmap_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ioc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>
			<span class="n">res_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span> <span class="cm">/* XXX - remove me */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ccio_proc_bitmap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ccio_proc_bitmap_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ccio_proc_bitmap_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ccio_proc_bitmap_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ccio_find_ioc - Find the ioc in the ioc_list</span>
<span class="cm"> * @hw_path: The hardware path of the ioc.</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches the ioc_list for an ioc that matches</span>
<span class="cm"> * the provide hardware path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span> <span class="nf">ccio_find_ioc</span><span class="p">(</span><span class="kt">int</span> <span class="n">hw_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ioc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">==</span> <span class="n">hw_path</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ioc</span><span class="p">;</span>

		<span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_get_iommu - Find the iommu which controls this device</span>
<span class="cm"> * @dev: The parisc device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches through the registered IOMMU&#39;s and returns</span>
<span class="cm"> * the appropriate IOMMU for the device based on its hardware path.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">ccio_get_iommu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">find_pa_parent_type</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HPHW_IOA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ccio_find_ioc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CUJO_20_STEP       0x10000000	</span><span class="cm">/* inc upper nibble */</span><span class="cp"></span>

<span class="cm">/* Cujo 2.0 has a bug which will silently corrupt data being transferred</span>
<span class="cm"> * to/from certain pages.  To avoid this happening, we mark these pages</span>
<span class="cm"> * as `used&#39;, and ensure that nothing will try to allocate from them.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ccio_cujo20_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">cujo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">iovp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">parisc_parent</span><span class="p">(</span><span class="n">cujo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ccio_get_iommu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">cujo20_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">res_ptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">res_ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">+=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">CUJO_20_STEP</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* GRANT -  is this needed for U2 or not? */</span>

<span class="c">/*</span>
<span class="c">** Get the size of the I/O TLB for this I/O MMU.</span>
<span class="c">**</span>
<span class="c">** If spa_shift is non-zero (ie probably U2),</span>
<span class="c">** then calculate the I/O TLB size using spa_shift.</span>
<span class="c">**</span>
<span class="c">** Otherwise we are supposed to get the IODC entry point ENTRY TLB</span>
<span class="c">** and execute it. However, both U2 and Uturn firmware supplies spa_shift.</span>
<span class="c">** I think only Java (K/D/R-class too?) systems don&#39;t do this.</span>
<span class="c">*/</span>
<span class="c">static int</span>
<span class="c">ccio_get_iotlb_size(struct parisc_device *dev)</span>
<span class="c">{</span>
<span class="c">	if (dev-&gt;spa_shift == 0) {</span>
<span class="c">		panic(&quot;%s() : Can&#39;t determine I/O TLB size.\n&quot;, __func__);</span>
<span class="c">	}</span>
<span class="c">	return (1 &lt;&lt; dev-&gt;spa_shift);</span>
<span class="c">}</span>
<span class="cp">#else</span>

<span class="cm">/* Uturn supports 256 TLB entries */</span>
<span class="cp">#define CCIO_CHAINID_SHIFT	8</span>
<span class="cp">#define CCIO_CHAINID_MASK	0xff</span>
<span class="cp">#endif </span><span class="cm">/* 0 */</span><span class="cp"></span>

<span class="cm">/* We *can&#39;t* support JAVA (T600). Venture there at your own risk. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="n">ccio_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">HPHW_IOA</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">U2_IOA_RUNWAY</span><span class="p">,</span> <span class="mh">0xb</span> <span class="p">},</span> <span class="cm">/* U2 */</span>
	<span class="p">{</span> <span class="n">HPHW_IOA</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">UTURN_IOA_RUNWAY</span><span class="p">,</span> <span class="mh">0xb</span> <span class="p">},</span> <span class="cm">/* UTurn */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ccio_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_driver</span> <span class="n">ccio_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;ccio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">ccio_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">ccio_probe</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_ioc_init - Initialize the I/O Controller</span>
<span class="cm"> * @ioc: The I/O Controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the I/O Controller which includes setting up the</span>
<span class="cm"> * I/O Page Directory, the resource map, and initalizing the</span>
<span class="cm"> * U2/Uturn chip into virtual mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ccio_ioc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iov_order</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iova_space_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** Determine IOVA Space size from memory size.</span>
<span class="cm">	**</span>
<span class="cm">	** Ideally, PCI drivers would register the maximum number</span>
<span class="cm">	** of DMA they can have outstanding for each device they</span>
<span class="cm">	** own.  Next best thing would be to guess how much DMA</span>
<span class="cm">	** can be outstanding based on PCI Class/sub-class. Both</span>
<span class="cm">	** methods still require some &quot;extra&quot; to support PCI</span>
<span class="cm">	** Hot-Plug/Removal of PCI cards. (aka PCI OLARD).</span>
<span class="cm">	*/</span>

	<span class="n">iova_space_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">/</span> <span class="n">count_parisc_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ccio_driver</span><span class="p">));</span>

	<span class="cm">/* limit IOVA space size to 1MB-1GB */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iova_space_size</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#ifdef __LP64__</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iova_space_size</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** iova space must be log2() in size.</span>
<span class="cm">	** thus, pdir/res_map will also be log2().</span>
<span class="cm">	*/</span>

	<span class="cm">/* We could use larger page sizes in order to *decrease* the number</span>
<span class="cm">	** of mappings needed.  (ie 8k pages means 1/2 the mappings).</span>
<span class="cm">	**</span>
<span class="cm">	** Note: Grant Grunder says &quot;Using 8k I/O pages isn&#39;t trivial either</span>
<span class="cm">	**   since the pages must also be physically contiguous - typically</span>
<span class="cm">	**   this is the case under linux.&quot;</span>
<span class="cm">	*/</span>

	<span class="n">iov_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/* iova_space_size is now bytes, not pages */</span>
	<span class="n">iova_space_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">/</span> <span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>   <span class="cm">/* max pdir size &lt;= 8MB */</span>

	<span class="cm">/* Verify it&#39;s a power of two */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() hpa 0x%p mem %luMB IOV %dMB (%d bits)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">totalram_pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
			<span class="n">iova_space_size</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span>
			<span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> 
						 <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s() could not allocate I/O Page Table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">);</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot; base %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">);</span>

	<span class="cm">/* resource map size dictated by pdir_size */</span>
 	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() res_size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">);</span>
	
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> 
					      <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s() could not allocate resource map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">);</span>

	<span class="cm">/* Initialize the res_hint to 16 */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Initialize the spinlock */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Chainid is the upper most bits of an IOVP used to determine</span>
<span class="cm">	** which TLB entry an IOVP will use.</span>
<span class="cm">	*/</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">chainid_shift</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">iova_space_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">CCIO_CHAINID_SHIFT</span><span class="p">;</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot; chainid_shift 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">chainid_shift</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Initialize IOA hardware</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_U32</span><span class="p">(</span><span class="n">CCIO_CHAINID_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">chainid_shift</span><span class="p">,</span> 
		  <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_chain_id_mask</span><span class="p">);</span>

	<span class="n">WRITE_U32</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">),</span> 
		  <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_pdir_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Go to &quot;Virtual Mode&quot;</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_U32</span><span class="p">(</span><span class="n">IOA_NORMAL_MODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_control</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Initialize all I/O TLB entries to 0 (Valid bit off).</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_U32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_tlb_entry_m</span><span class="p">);</span>
	<span class="n">WRITE_U32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_tlb_entry_l</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CCIO_CHAINID_SHIFT</span><span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WRITE_U32</span><span class="p">((</span><span class="n">CMD_TLB_DIRECT_WRITE</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">chainid_shift</span><span class="p">)),</span>
			  <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_command</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ccio_init_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * bracing ((signed) ...) are required for 64bit kernel because</span>
<span class="cm">	 * we only want to sign extend the lower 16 bits of the register.</span>
<span class="cm">	 * The upper 16-bits of range registers are hardcoded to 0xffff.</span>
<span class="cm">	 */</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">signed</span><span class="p">)</span> <span class="n">READ_U32</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">signed</span><span class="p">)</span> <span class="p">(</span><span class="n">READ_U32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if this MMIO range is disable</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* On some platforms (e.g. K-Class), we have already registered</span>
<span class="cm">	 * resources for devices reported by firmware. Some are children</span>
<span class="cm">	 * of ccio.</span>
<span class="cm">	 * &quot;insert&quot; ccio ranges in the mmio hierarchy (/proc/iomem).</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s() failed to claim CCIO bus address space (%08lx,%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">ccio_init_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="s">&quot;GSC Bus [%d/]&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">);</span>

	<span class="n">ccio_init_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_low</span><span class="p">);</span>
	<span class="n">ccio_init_resource</span><span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_low_hv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">new_ioc_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;~</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	
	<span class="cm">/* We might be trying to expand the MMIO range to include</span>
<span class="cm">	 * a child device that has already registered it&#39;s MMIO space.</span>
<span class="cm">	 * Use &quot;insert&quot; instead of request_resource().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new_ioc_area</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span> <span class="o">-</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">expand_ioc_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">new_ioc_area</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span> <span class="n">size</span><span class="p">)</span> <span class="o">&amp;~</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adjust_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="n">align</span><span class="p">)</span> <span class="o">&amp;~</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adjust_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dino calls this function.  Beware that we may get called on systems</span>
<span class="cm"> * which have no IOC (725, B180, C160L, etc) but do have a Dino.</span>
<span class="cm"> * So it&#39;s legal to find no parent IOC.</span>
<span class="cm"> *</span>
<span class="cm"> * Some other issues: one of the resources in the ioc may be unassigned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ccio_allocate_resource</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ccio_get_iommu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">allocate_resource</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">parent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">allocate_resource</span><span class="p">(</span><span class="n">parent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expand_ioc_area</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xffff0000</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_low</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xffff0000</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_high</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expand_ioc_area</span><span class="p">(</span><span class="n">parent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parent</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__raw_writel</span><span class="p">(((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xffff0000</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_low_hv</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xffff0000</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span><span class="o">-&gt;</span><span class="n">io_io_high_hv</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">allocate_resource</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ccio_request_resource</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ccio_get_iommu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">mmio_region</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* &quot;transparent&quot; bus bridges need to register MMIO resources</span>
<span class="cm">	 * firmware assigned them. e.g. children of hppb.c (e.g. K-class)</span>
<span class="cm">	 * registered their resources in the PDC &quot;bus walk&quot; (See</span>
<span class="cm">	 * arch/parisc/kernel/inventory.c).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">insert_resource</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_probe - Determine if ccio should claim this device.</span>
<span class="cm"> * @dev: The device which has been found</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if ccio should claim this chip (return 0) or not (return 1).</span>
<span class="cm"> * If so, initialize the chip and tell other partners in crime they</span>
<span class="cm"> * have work to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ccio_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="o">**</span><span class="n">ioc_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioc_list</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: memory allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion</span> <span class="o">==</span> <span class="n">U2_IOA_RUNWAY</span> <span class="o">?</span> <span class="s">&quot;U2&quot;</span> <span class="o">:</span> <span class="s">&quot;UTurn&quot;</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Found %s at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ioc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioc_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">ioc_p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ioc_p</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_regs</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">ccio_ioc_init</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="n">ccio_init_resources</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="n">hppa_dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ccio_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_hba_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/* if this fails, no I/O cards will work, so may as well bug */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">HBA_DATA</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_create</span><span class="p">(</span><span class="n">MODULE_NAME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">proc_runway_root</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ccio_proc_info_fops</span><span class="p">);</span>
		<span class="n">proc_create</span><span class="p">(</span><span class="n">MODULE_NAME</span><span class="s">&quot;-bitmap&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">proc_runway_root</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ccio_proc_bitmap_fops</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ioc_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">parisc_has_iommu</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ccio_init - ccio initialization procedure.</span>
<span class="cm"> *</span>
<span class="cm"> * Register this driver.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">ccio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_parisc_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ccio_driver</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
