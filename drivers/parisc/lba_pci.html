<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parisc › lba_pci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lba_pci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">**</span>
<span class="cm">**  PCI Lower Bus Adapter (LBA) manager</span>
<span class="cm">**</span>
<span class="cm">**	(c) Copyright 1999,2000 Grant Grundler</span>
<span class="cm">**	(c) Copyright 1999,2000 Hewlett-Packard Company</span>
<span class="cm">**</span>
<span class="cm">**	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**	it under the terms of the GNU General Public License as published by</span>
<span class="cm">**      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**      (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** This module primarily provides access to PCI bus (config/IOport</span>
<span class="cm">** spaces) on platforms with an SBA/LBA chipset. A/B/C/J/L/N-class</span>
<span class="cm">** with 4 digit model numbers - eg C3000 (and A400...sigh).</span>
<span class="cm">**</span>
<span class="cm">** LBA driver isn&#39;t as simple as the Dino driver because:</span>
<span class="cm">**   (a) this chip has substantial bug fixes between revisions</span>
<span class="cm">**       (Only one Dino bug has a software workaround :^(  )</span>
<span class="cm">**   (b) has more options which we don&#39;t (yet) support (DMA hints, OLARD)</span>
<span class="cm">**   (c) IRQ support lives in the I/O SAPIC driver (not with PCI driver)</span>
<span class="cm">**   (d) play nicely with both PAT and &quot;Legacy&quot; PA-RISC firmware (PDC).</span>
<span class="cm">**       (dino only deals with &quot;Legacy&quot; PDC)</span>
<span class="cm">**</span>
<span class="cm">** LBA driver passes the I/O SAPIC HPA to the I/O SAPIC driver.</span>
<span class="cm">** (I/O SAPIC is integratd in the LBA chip).</span>
<span class="cm">**</span>
<span class="cm">** FIXME: Add support to SBA and LBA drivers for DMA hint sets</span>
<span class="cm">** FIXME: Add support for PCI card hot-plug (OLARD).</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;		</span><span class="cm">/* for __init and __devinit */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/pdcpat.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cp">#include &lt;asm/ropes.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;	</span><span class="cm">/* for register_parisc_driver() stuff */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/parisc-device.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;		</span><span class="cm">/* read/write stuff */</span><span class="cp"></span>

<span class="cp">#undef DEBUG_LBA	</span><span class="cm">/* general stuff */</span><span class="cp"></span>
<span class="cp">#undef DEBUG_LBA_PORT	</span><span class="cm">/* debug I/O Port access */</span><span class="cp"></span>
<span class="cp">#undef DEBUG_LBA_CFG	</span><span class="cm">/* debug Config Space Access (ie PCI Bus walk) */</span><span class="cp"></span>
<span class="cp">#undef DEBUG_LBA_PAT	</span><span class="cm">/* debug PCI Resource Mgt code - PDC PAT only */</span><span class="cp"></span>

<span class="cp">#undef FBB_SUPPORT	</span><span class="cm">/* Fast Back-Back xfers - NOT READY YET */</span><span class="cp"></span>


<span class="cp">#ifdef DEBUG_LBA</span>
<span class="cp">#define DBG(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_LBA_PORT</span>
<span class="cp">#define DBG_PORT(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_PORT(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_LBA_CFG</span>
<span class="cp">#define DBG_CFG(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_CFG(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_LBA_PAT</span>
<span class="cp">#define DBG_PAT(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_PAT(x...)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">** Config accessor functions only pass in the 8-bit bus number and not</span>
<span class="cm">** the 8-bit &quot;PCI Segment&quot; number. Each LBA will be assigned a PCI bus</span>
<span class="cm">** number based on what firmware wrote into the scratch register.</span>
<span class="cm">**</span>
<span class="cm">** The &quot;secondary&quot; bus number is set to this before calling</span>
<span class="cm">** pci_register_ops(). If any PPB&#39;s are present, the scan will</span>
<span class="cm">** discover them and update the &quot;secondary&quot; and &quot;subordinate&quot;</span>
<span class="cm">** fields in the pci_bus structure.</span>
<span class="cm">**</span>
<span class="cm">** Changes in the configuration *may* result in a different</span>
<span class="cm">** bus number for each LBA depending on what firmware does.</span>
<span class="cm">*/</span>

<span class="cp">#define MODULE_NAME &quot;LBA&quot;</span>

<span class="cm">/* non-postable I/O port space, densely packed */</span>
<span class="cp">#define LBA_PORT_BASE	(PCI_F_EXTEND | 0xfee00000UL)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">astro_iop_base</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">lba_t32</span><span class="p">;</span>

<span class="cm">/* lba flags */</span>
<span class="cp">#define LBA_FLAG_SKIP_PROBE	0x10</span>

<span class="cp">#define LBA_SKIP_PROBE(d) ((d)-&gt;flags &amp; LBA_FLAG_SKIP_PROBE)</span>


<span class="cm">/* Looks nice and keeps the compiler happy */</span>
<span class="cp">#define LBA_DEV(d) ((struct lba_device *) (d))</span>


<span class="cm">/*</span>
<span class="cm">** Only allow 8 subsidiary busses per LBA</span>
<span class="cm">** Problem is the PCI bus numbering is globally shared.</span>
<span class="cm">*/</span>
<span class="cp">#define LBA_MAX_NUM_BUSES 8</span>

<span class="cm">/************************************</span>
<span class="cm"> * LBA register read and write support</span>
<span class="cm"> *</span>
<span class="cm"> * BE WARNED: register writes are posted.</span>
<span class="cm"> *  (ie follow writes which must reach HW with a read)</span>
<span class="cm"> */</span>
<span class="cp">#define READ_U8(addr)  __raw_readb(addr)</span>
<span class="cp">#define READ_U16(addr) __raw_readw(addr)</span>
<span class="cp">#define READ_U32(addr) __raw_readl(addr)</span>
<span class="cp">#define WRITE_U8(value, addr)  __raw_writeb(value, addr)</span>
<span class="cp">#define WRITE_U16(value, addr) __raw_writew(value, addr)</span>
<span class="cp">#define WRITE_U32(value, addr) __raw_writel(value, addr)</span>

<span class="cp">#define READ_REG8(addr)  readb(addr)</span>
<span class="cp">#define READ_REG16(addr) readw(addr)</span>
<span class="cp">#define READ_REG32(addr) readl(addr)</span>
<span class="cp">#define READ_REG64(addr) readq(addr)</span>
<span class="cp">#define WRITE_REG8(value, addr)  writeb(value, addr)</span>
<span class="cp">#define WRITE_REG16(value, addr) writew(value, addr)</span>
<span class="cp">#define WRITE_REG32(value, addr) writel(value, addr)</span>


<span class="cp">#define LBA_CFG_TOK(bus,dfn) ((u32) ((bus)&lt;&lt;16 | (dfn)&lt;&lt;8))</span>
<span class="cp">#define LBA_CFG_BUS(tok)  ((u8) ((tok)&gt;&gt;16))</span>
<span class="cp">#define LBA_CFG_DEV(tok)  ((u8) ((tok)&gt;&gt;11) &amp; 0x1f)</span>
<span class="cp">#define LBA_CFG_FUNC(tok) ((u8) ((tok)&gt;&gt;8 ) &amp; 0x7)</span>


<span class="cm">/*</span>
<span class="cm">** Extract LBA (Rope) number from HPA</span>
<span class="cm">** REVISIT: 16 ropes for Stretch/Ike?</span>
<span class="cm">*/</span>
<span class="cp">#define ROPES_PER_IOC	8</span>
<span class="cp">#define LBA_NUM(x)    ((((unsigned long) x) &gt;&gt; 13) &amp; (ROPES_PER_IOC-1))</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_dump_res</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;(%p)&quot;</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%p [%lx,%lx]/%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lba_dump_res</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">lba_dump_res</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** LBA rev 2.0, 2.1, 2.2, and 3.0 bus walks require a complex</span>
<span class="cm">** workaround for cfg cycles:</span>
<span class="cm">**	-- preserve  LBA state</span>
<span class="cm">**	-- prevent any DMA from occurring</span>
<span class="cm">**	-- turn on smart mode</span>
<span class="cm">**	-- probe with config writes before doing config reads</span>
<span class="cm">**	-- check ERROR_STATUS</span>
<span class="cm">**	-- clear ERROR_STATUS</span>
<span class="cm">**	-- restore LBA state</span>
<span class="cm">**</span>
<span class="cm">** The workaround is only used for device discovery.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lba_device_present</span><span class="p">(</span><span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dfn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">first_bus</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">last_sub_bus</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_bus</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bus</span> <span class="o">&lt;</span> <span class="n">first_bus</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bus</span> <span class="o">&gt;</span> <span class="n">last_sub_bus</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">bus</span> <span class="o">-</span> <span class="n">first_bus</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LBA_MAX_NUM_BUSES</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#define LBA_CFG_SETUP(d, tok) {				\</span>
<span class="cp">    </span><span class="cm">/* Save contents of error config register.  */</span><span class="cp">			\</span>
<span class="cp">    error_config = READ_REG32(d-&gt;hba.base_addr + LBA_ERROR_CONFIG);		\</span>
<span class="cp">\</span>
<span class="cp">    </span><span class="cm">/* Save contents of status control register.  */</span><span class="cp">			\</span>
<span class="cp">    status_control = READ_REG32(d-&gt;hba.base_addr + LBA_STAT_CTL);		\</span>
<span class="cp">\</span>
<span class="cp">    </span><span class="cm">/* For LBA rev 2.0, 2.1, 2.2, and 3.0, we must disable DMA		\</span>
<span class="cm">    ** arbitration for full bus walks.					\</span>
<span class="cm">    */</span><span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Save contents of arb mask register. */</span><span class="cp">			\</span>
<span class="cp">	arb_mask = READ_REG32(d-&gt;hba.base_addr + LBA_ARB_MASK);		\</span>
<span class="cp">\</span>
<span class="cp">	</span><span class="cm">/*								\</span>
<span class="cm">	 * Turn off all device arbitration bits (i.e. everything	\</span>
<span class="cm">	 * except arbitration enable bit).				\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	WRITE_REG32(0x1, d-&gt;hba.base_addr + LBA_ARB_MASK);		\</span>
<span class="cp">\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Set the smart mode bit so that master aborts don&#39;t cause		\</span>
<span class="cm">     * LBA to go into PCI fatal mode (required).			\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(error_config | LBA_SMART_MODE, d-&gt;hba.base_addr + LBA_ERROR_CONFIG);	\</span>
<span class="cp">}</span>


<span class="cp">#define LBA_CFG_PROBE(d, tok) {				\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Setup Vendor ID write and read back the address register		\</span>
<span class="cm">     * to make sure that LBA is the bus master.				\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(tok | PCI_VENDOR_ID, (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Read address register to ensure that LBA is the bus master,	\</span>
<span class="cm">     * which implies that DMA traffic has stopped when DMA arb is off.	\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);	\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Generate a cfg write cycle (will have no affect on		\</span>
<span class="cm">     * Vendor ID register since read-only).				\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(~0, (d)-&gt;hba.base_addr + LBA_PCI_CFG_DATA);		\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Make sure write has completed before proceeding further,		\</span>
<span class="cm">     * i.e. before setting clear enable.				\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);	\</span>
<span class="cp">}</span>


<span class="cm">/*</span>
<span class="cm"> * HPREVISIT:</span>
<span class="cm"> *   -- Can&#39;t tell if config cycle got the error.</span>
<span class="cm"> *</span>
<span class="cm"> *		OV bit is broken until rev 4.0, so can&#39;t use OV bit and</span>
<span class="cm"> *		LBA_ERROR_LOG_ADDR to tell if error belongs to config cycle.</span>
<span class="cm"> *</span>
<span class="cm"> *		As of rev 4.0, no longer need the error check.</span>
<span class="cm"> *</span>
<span class="cm"> *   -- Even if we could tell, we still want to return -1</span>
<span class="cm"> *	for **ANY** error (not just master abort).</span>
<span class="cm"> *</span>
<span class="cm"> *   -- Only clear non-fatal errors (we don&#39;t want to bring</span>
<span class="cm"> *	LBA out of pci-fatal mode).</span>
<span class="cm"> *</span>
<span class="cm"> *		Actually, there is still a race in which</span>
<span class="cm"> *		we could be clearing a fatal error.  We will</span>
<span class="cm"> *		live with this during our initial bus walk</span>
<span class="cm"> *		until rev 4.0 (no driver activity during</span>
<span class="cm"> *		initial bus walk).  The initial bus walk</span>
<span class="cm"> *		has race conditions concerning the use of</span>
<span class="cm"> *		smart mode as well.</span>
<span class="cm"> */</span>

<span class="cp">#define LBA_MASTER_ABORT_ERROR 0xc</span>
<span class="cp">#define LBA_FATAL_ERROR 0x10</span>

<span class="cp">#define LBA_CFG_MASTER_ABORT_CHECK(d, base, tok, error) {		\</span>
<span class="cp">    u32 error_status = 0;						\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Set clear enable (CE) bit. Unset by HW when new			\</span>
<span class="cm">     * errors are logged -- LBA HW ERS section 14.3.3).		\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(status_control | CLEAR_ERRLOG_ENABLE, base + LBA_STAT_CTL); \</span>
<span class="cp">    error_status = READ_REG32(base + LBA_ERROR_STATUS);		\</span>
<span class="cp">    if ((error_status &amp; 0x1f) != 0) {					\</span>
<span class="cp">	</span><span class="cm">/*								\</span>
<span class="cm">	 * Fail the config read request.				\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	error = 1;							\</span>
<span class="cp">	if ((error_status &amp; LBA_FATAL_ERROR) == 0) {			\</span>
<span class="cp">	    </span><span class="cm">/*								\</span>
<span class="cm">	     * Clear error status (if fatal bit not set) by setting	\</span>
<span class="cm">	     * clear error log bit (CL).				\</span>
<span class="cm">	     */</span><span class="cp">								\</span>
<span class="cp">	    WRITE_REG32(status_control | CLEAR_ERRLOG, base + LBA_STAT_CTL); \</span>
<span class="cp">	}								\</span>
<span class="cp">    }									\</span>
<span class="cp">}</span>

<span class="cp">#define LBA_CFG_TR4_ADDR_SETUP(d, addr)					\</span>
<span class="cp">	WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);</span>

<span class="cp">#define LBA_CFG_ADDR_SETUP(d, addr) {					\</span>
<span class="cp">    WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);	\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Read address register to ensure that LBA is the bus master,	\</span>
<span class="cm">     * which implies that DMA traffic has stopped when DMA arb is off.	\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);	\</span>
<span class="cp">}</span>


<span class="cp">#define LBA_CFG_RESTORE(d, base) {					\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Restore status control register (turn off clear enable).		\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(status_control, base + LBA_STAT_CTL);			\</span>
<span class="cp">    </span><span class="cm">/*									\</span>
<span class="cm">     * Restore error config register (turn off smart mode).		\</span>
<span class="cm">     */</span><span class="cp">									\</span>
<span class="cp">    WRITE_REG32(error_config, base + LBA_ERROR_CONFIG);			\</span>
<span class="cp">	</span><span class="cm">/*								\</span>
<span class="cm">	 * Restore arb mask register (reenables DMA arbitration).	\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	WRITE_REG32(arb_mask, base + LBA_ARB_MASK);			\</span>
<span class="cp">}</span>



<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">lba_rd_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tok</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">arb_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* used by LBA_CFG_SETUP/RESTORE */</span>
	<span class="n">u32</span> <span class="n">error_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* used by LBA_CFG_SETUP/RESTORE */</span>
	<span class="n">u32</span> <span class="n">status_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* used by LBA_CFG_SETUP/RESTORE */</span>

	<span class="n">LBA_CFG_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
	<span class="n">LBA_CFG_PROBE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
	<span class="n">LBA_CFG_MASTER_ABORT_CHECK</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">;</span>

		<span class="n">LBA_CFG_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">READ_REG8</span><span class="p">(</span><span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">READ_REG16</span><span class="p">(</span><span class="n">data_reg</span><span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>: <span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">data_reg</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">LBA_CFG_RESTORE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">elroy_cfg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">LBA_DEV</span><span class="p">(</span><span class="n">parisc_walk_tree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">));</span>
	<span class="n">u32</span> <span class="n">local_bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">LBA_CFG_TOK</span><span class="p">(</span><span class="n">local_bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="cm">/* FIXME: B2K/C3600 workaround is always use old method... */</span>
	<span class="cm">/* if (!LBA_SKIP_PROBE(d)) */</span> <span class="p">{</span>
		<span class="cm">/* original - Generate config cycle on broken elroy</span>
<span class="cm">		  with risk we will miss PCI bus errors. */</span>
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">lba_rd_cfg</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) -&gt; 0x%x (a)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LBA_SKIP_PROBE</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lba_device_present</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) -&gt; -1 (b)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="cm">/* either don&#39;t want to look or know device isn&#39;t present. */</span>
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Basic Algorithm</span>
<span class="cm">	** Should only get here on fully working LBA rev.</span>
<span class="cm">	** This is how simple the code should have been.</span>
<span class="cm">	*/</span>
	<span class="n">LBA_CFG_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG8</span> <span class="p">(</span><span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG16</span><span class="p">(</span><span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">data_reg</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) -&gt; 0x%x (c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_wr_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tok</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">arb_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">;</span>

	<span class="n">LBA_CFG_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
	<span class="n">LBA_CFG_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">WRITE_REG8</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">WRITE_REG16</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="n">WRITE_REG32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">);</span>             <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">LBA_CFG_MASTER_ABORT_CHECK</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">LBA_CFG_RESTORE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * LBA 4.0 config write code implements non-postable semantics</span>
<span class="cm"> * by doing a read of CONFIG ADDR after the write.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">elroy_cfg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">LBA_DEV</span><span class="p">(</span><span class="n">parisc_walk_tree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">));</span>
	<span class="n">u32</span> <span class="n">local_bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">LBA_CFG_TOK</span><span class="p">(</span><span class="n">local_bus</span><span class="p">,</span><span class="n">devfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LBA_SKIP_PROBE</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Original Workaround */</span>
		<span class="n">lba_wr_cfg</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) = 0x%x (a)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LBA_SKIP_PROBE</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_device_present</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) = 0x%x (b)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* New Workaround */</span>
	<span class="p">}</span>

	<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) = 0x%x (c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Basic Algorithm */</span>
	<span class="n">LBA_CFG_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">WRITE_REG8</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
		   <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">WRITE_REG16</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span>
		   <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="n">WRITE_REG32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">);</span>
		   <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* flush posted write */</span>
	<span class="n">lba_t32</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_ADDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">elroy_cfg_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">elroy_cfg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">elroy_cfg_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The mercury_cfg_ops are slightly misnamed; they&#39;re also used for Elroy</span>
<span class="cm"> * TR4.0 as no additional bugs were found in this areea between Elroy and</span>
<span class="cm"> * Mercury</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mercury_cfg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">LBA_DEV</span><span class="p">(</span><span class="n">parisc_walk_tree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">));</span>
	<span class="n">u32</span> <span class="n">local_bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">LBA_CFG_TOK</span><span class="p">(</span><span class="n">local_bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">LBA_CFG_TR4_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG8</span><span class="p">(</span><span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG16</span><span class="p">(</span><span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">data_reg</span><span class="p">);</span>             <span class="k">break</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;mercury_cfg_read(%x+%2x) -&gt; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LBA 4.0 config write code implements non-postable semantics</span>
<span class="cm"> * by doing a read of CONFIG ADDR after the write.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mercury_cfg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">LBA_DEV</span><span class="p">(</span><span class="n">parisc_walk_tree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">));</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_DATA</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">local_bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">LBA_CFG_TOK</span><span class="p">(</span><span class="n">local_bus</span><span class="p">,</span><span class="n">devfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">DBG_CFG</span><span class="p">(</span><span class="s">&quot;%s(%x+%2x) &lt;- 0x%x (c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">LBA_CFG_TR4_ADDR_SETUP</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tok</span> <span class="o">|</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">WRITE_REG8</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">WRITE_REG16</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">WRITE_REG32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* flush posted write */</span>
	<span class="n">lba_t32</span> <span class="o">=</span> <span class="n">READ_U32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_PCI_CFG_ADDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">mercury_cfg_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">mercury_cfg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">mercury_cfg_write</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_bios_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">MODULE_NAME</span> <span class="s">&quot;: lba_bios_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_64BIT</span>

<span class="cm">/*</span>
<span class="cm"> * truncate_pat_collision:  Deal with overlaps or outright collisions</span>
<span class="cm"> *			between PAT PDC reported ranges.</span>
<span class="cm"> *</span>
<span class="cm"> *   Broken PA8800 firmware will report lmmio range that</span>
<span class="cm"> *   overlaps with CPU HPA. Just truncate the lmmio range.</span>
<span class="cm"> *</span>
<span class="cm"> *   BEWARE: conflicts with this lmmio range may be an</span>
<span class="cm"> *   elmmio range which is pointing down another rope.</span>
<span class="cm"> *</span>
<span class="cm"> *  FIXME: only deals with one collision per range...theoretically we</span>
<span class="cm"> *  could have several. Supporting more than one collision will get messy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">truncate_pat_collision</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">||</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">||</span> <span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* find first overlap */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">;</span>

	<span class="cm">/* no entries overlap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* found one that starts behind the new one</span>
<span class="cm">	** Don&#39;t need to do anything.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;front&quot; of new one overlaps */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* AACCKK! totally overlaps! drop this range. */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> 

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;end&quot; of new one overlaps */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;LBA: Truncating lmmio_space [%lx/%lx] &quot;</span>
					<span class="s">&quot;to [%lx,%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span> <span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* truncation successful */</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define truncate_pat_collision(r,n)  (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">** The algorithm is generic code.</span>
<span class="cm">** But it needs to access local data structures to get the IRQ base.</span>
<span class="cm">** Could make this a &quot;pci_fixup_irq(bus, region)&quot; but not sure</span>
<span class="cm">** it&#39;s worth it.</span>
<span class="cm">**</span>
<span class="cm">** Called by do_pci_scan_bus() immediately after each PCI bus is walked.</span>
<span class="cm">** Resources aren&#39;t allocated until recursive buswalk below HBA is completed.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_fixup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
<span class="cp">#ifdef FBB_SUPPORT</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">ldev</span> <span class="o">=</span> <span class="n">LBA_DEV</span><span class="p">(</span><span class="n">parisc_walk_tree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">));</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;lba_fixup_bus(0x%p) bus %d platform_data 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bus</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Properly Setup MMIO resources for this bus.</span>
<span class="cm">	** pci_alloc_primary_bus() mangles this.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* PCI-PCI Bridge */</span>
		<span class="n">pci_read_bridge_bases</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_claim_resource</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Host-PCI Bridge */</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;lba_fixup_bus() %s [%lx/%lx]/%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">.</span><span class="n">end</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;lba_fixup_bus() %s [%lx/%lx]/%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">end</span><span class="p">,</span>
			<span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioport_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lba_dump_res</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioport_resource</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FAILED: lba_fixup_bus() request for &quot;</span>
						<span class="s">&quot;elmmio_space [%lx/%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>

				<span class="cm">/* lba_dump_res(&amp;iomem_resource, 2); */</span>
				<span class="cm">/* BUG(); */</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FAILED: lba_fixup_bus() request for &quot;</span>
					<span class="s">&quot;lmmio_space [%lx/%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
		<span class="cm">/* GMMIO is  distributed range. Every LBA/Rope gets part it. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FAILED: lba_fixup_bus() request for &quot;</span>
					<span class="s">&quot;gmmio_space [%lx/%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
				<span class="n">lba_dump_res</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="p">}</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_dev_b</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;lba_fixup_bus() %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

		<span class="cm">/* Virtualize Device/Bridge Resources. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* If resource not allocated - skip it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			** FIXME: this will result in whinging for devices</span>
<span class="cm">			** that share expansion ROMs (think quad tulip), but</span>
<span class="cm">			** isn&#39;t harmful.</span>
<span class="cm">			*/</span>
			<span class="n">pci_claim_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#ifdef FBB_SUPPORT</span>
		<span class="cm">/*</span>
<span class="cm">		** If one device does not support FBB transfers,</span>
<span class="cm">		** No one on the bus can be allowed to use them.</span>
<span class="cm">		*/</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_FAST_BACK</span><span class="p">);</span>
<span class="cp">#endif</span>

                <span class="cm">/*</span>
<span class="cm">		** P2PB&#39;s have no IRQs. ignore them.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_BRIDGE_PCI</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Adjust INTERRUPT_LINE for this dev */</span>
		<span class="n">iosapic_fixup_irq</span><span class="p">(</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">iosapic_obj</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef FBB_SUPPORT</span>
<span class="cm">/* FIXME/REVISIT - finish figuring out to set FBB on both</span>
<span class="cm">** pci_setup_bridge() clobbers PCI_BRIDGE_CONTROL.</span>
<span class="cm">** Can&#39;t fixup here anyway....garr...</span>
<span class="cm">*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fbb_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">control</span><span class="p">;</span>
			<span class="cm">/* enable on PPB */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="n">control</span> <span class="o">|</span> <span class="n">PCI_STATUS_FAST_BACK</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* enable on LBA */</span>
		<span class="p">}</span>
		<span class="n">fbb_enable</span> <span class="o">=</span> <span class="n">PCI_COMMAND_FAST_BACK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Lastly enable FBB/PERR/SERR on all devices too */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_PARITY</span> <span class="o">|</span> <span class="n">PCI_COMMAND_SERR</span> <span class="o">|</span> <span class="n">fbb_enable</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_bios_ops</span> <span class="n">lba_bios_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span>		<span class="n">lba_bios_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_bus</span> <span class="o">=</span>	<span class="n">lba_fixup_bus</span><span class="p">,</span>
<span class="p">};</span>




<span class="cm">/*******************************************************</span>
<span class="cm">**</span>
<span class="cm">** LBA Sprockets &quot;I/O Port&quot; Space Accessor Functions</span>
<span class="cm">**</span>
<span class="cm">** This set of accessor functions is intended for use with</span>
<span class="cm">** &quot;legacy firmware&quot; (ie Sprockets on Allegro/Forte boxes).</span>
<span class="cm">**</span>
<span class="cm">** Many PCI devices don&#39;t require use of I/O port space (eg Tulip,</span>
<span class="cm">** NCR720) since they export the same registers to both MMIO and</span>
<span class="cm">** I/O port space. In general I/O port space is slower than</span>
<span class="cm">** MMIO since drivers are designed so PIO writes can be posted.</span>
<span class="cm">**</span>
<span class="cm">********************************************************/</span>

<span class="cp">#define LBA_PORT_IN(size, mask) \</span>
<span class="cp">static u##size lba_astro_in##size (struct pci_hba_data *d, u16 addr) \</span>
<span class="cp">{ \</span>
<span class="cp">	u##size t; \</span>
<span class="cp">	t = READ_REG##size(astro_iop_base + addr); \</span>
<span class="cp">	DBG_PORT(&quot; 0x%x\n&quot;, t); \</span>
<span class="cp">	return (t); \</span>
<span class="cp">}</span>

<span class="n">LBA_PORT_IN</span><span class="p">(</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">LBA_PORT_IN</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">LBA_PORT_IN</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>



<span class="cm">/*</span>
<span class="cm">** BUG X4107:  Ordering broken - DMA RD return can bypass PIO WR</span>
<span class="cm">**</span>
<span class="cm">** Fixed in Elroy 2.2. The READ_U32(..., LBA_FUNC_ID) below is</span>
<span class="cm">** guarantee non-postable completion semantics - not avoid X4107.</span>
<span class="cm">** The READ_U32 only guarantees the write data gets to elroy but</span>
<span class="cm">** out to the PCI bus. We can&#39;t read stuff from I/O port space</span>
<span class="cm">** since we don&#39;t know what has side-effects. Attempting to read</span>
<span class="cm">** from configuration space would be suicidal given the number of</span>
<span class="cm">** bugs in that elroy functionality.</span>
<span class="cm">**</span>
<span class="cm">**      Description:</span>
<span class="cm">**          DMA read results can improperly pass PIO writes (X4107).  The</span>
<span class="cm">**          result of this bug is that if a processor modifies a location in</span>
<span class="cm">**          memory after having issued PIO writes, the PIO writes are not</span>
<span class="cm">**          guaranteed to be completed before a PCI device is allowed to see</span>
<span class="cm">**          the modified data in a DMA read.</span>
<span class="cm">**</span>
<span class="cm">**          Note that IKE bug X3719 in TR1 IKEs will result in the same</span>
<span class="cm">**          symptom.</span>
<span class="cm">**</span>
<span class="cm">**      Workaround:</span>
<span class="cm">**          The workaround for this bug is to always follow a PIO write with</span>
<span class="cm">**          a PIO read to the same bus before starting DMA on that PCI bus.</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="cp">#define LBA_PORT_OUT(size, mask) \</span>
<span class="cp">static void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) \</span>
<span class="cp">{ \</span>
<span class="cp">	DBG_PORT(&quot;%s(0x%p, 0x%x, 0x%x)\n&quot;, __func__, d, addr, val); \</span>
<span class="cp">	WRITE_REG##size(val, astro_iop_base + addr); \</span>
<span class="cp">	if (LBA_DEV(d)-&gt;hw_rev &lt; 3) \</span>
<span class="cp">		lba_t32 = READ_U32(d-&gt;base_addr + LBA_FUNC_ID); \</span>
<span class="cp">}</span>

<span class="n">LBA_PORT_OUT</span><span class="p">(</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">LBA_PORT_OUT</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">LBA_PORT_OUT</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_port_ops</span> <span class="n">lba_astro_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inb</span> <span class="o">=</span>	<span class="n">lba_astro_in8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inw</span> <span class="o">=</span>	<span class="n">lba_astro_in16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inl</span> <span class="o">=</span>	<span class="n">lba_astro_in32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outb</span> <span class="o">=</span>	<span class="n">lba_astro_out8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outw</span> <span class="o">=</span>	<span class="n">lba_astro_out16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outl</span> <span class="o">=</span>	<span class="n">lba_astro_out32</span>
<span class="p">};</span>


<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define PIOP_TO_GMMIO(lba, addr) \</span>
<span class="cp">	((lba)-&gt;iop_base + (((addr)&amp;0xFFFC)&lt;&lt;10) + ((addr)&amp;3))</span>

<span class="cm">/*******************************************************</span>
<span class="cm">**</span>
<span class="cm">** LBA PAT &quot;I/O Port&quot; Space Accessor Functions</span>
<span class="cm">**</span>
<span class="cm">** This set of accessor functions is intended for use with</span>
<span class="cm">** &quot;PAT PDC&quot; firmware (ie Prelude/Rhapsody/Piranha boxes).</span>
<span class="cm">**</span>
<span class="cm">** This uses the PIOP space located in the first 64MB of GMMIO.</span>
<span class="cm">** Each rope gets a full 64*KB* (ie 4 bytes per page) this way.</span>
<span class="cm">** bits 1:0 stay the same.  bits 15:2 become 25:12.</span>
<span class="cm">** Then add the base and we can generate an I/O Port cycle.</span>
<span class="cm">********************************************************/</span>
<span class="cp">#undef LBA_PORT_IN</span>
<span class="cp">#define LBA_PORT_IN(size, mask) \</span>
<span class="cp">static u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) \</span>
<span class="cp">{ \</span>
<span class="cp">	u##size t; \</span>
<span class="cp">	DBG_PORT(&quot;%s(0x%p, 0x%x) -&gt;&quot;, __func__, l, addr); \</span>
<span class="cp">	t = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); \</span>
<span class="cp">	DBG_PORT(&quot; 0x%x\n&quot;, t); \</span>
<span class="cp">	return (t); \</span>
<span class="cp">}</span>

<span class="n">LBA_PORT_IN</span><span class="p">(</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">LBA_PORT_IN</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">LBA_PORT_IN</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="cp">#undef LBA_PORT_OUT</span>
<span class="cp">#define LBA_PORT_OUT(size, mask) \</span>
<span class="cp">static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) \</span>
<span class="cp">{ \</span>
<span class="cp">	void __iomem *where = PIOP_TO_GMMIO(LBA_DEV(l), addr); \</span>
<span class="cp">	DBG_PORT(&quot;%s(0x%p, 0x%x, 0x%x)\n&quot;, __func__, l, addr, val); \</span>
<span class="cp">	WRITE_REG##size(val, where); \</span>
<span class="cp">	</span><span class="cm">/* flush the I/O down to the elroy at least */</span><span class="cp"> \</span>
<span class="cp">	lba_t32 = READ_U32(l-&gt;base_addr + LBA_FUNC_ID); \</span>
<span class="cp">}</span>

<span class="n">LBA_PORT_OUT</span><span class="p">(</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">LBA_PORT_OUT</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">LBA_PORT_OUT</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_port_ops</span> <span class="n">lba_pat_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inb</span> <span class="o">=</span>	<span class="n">lba_pat_in8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inw</span> <span class="o">=</span>	<span class="n">lba_pat_in16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inl</span> <span class="o">=</span>	<span class="n">lba_pat_in32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outb</span> <span class="o">=</span>	<span class="n">lba_pat_out8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outw</span> <span class="o">=</span>	<span class="n">lba_pat_out16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">outl</span> <span class="o">=</span>	<span class="n">lba_pat_out32</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm">** make range information from PDC available to PCI subsystem.</span>
<span class="cm">** We make the PDC call here in order to get the PCI bus range</span>
<span class="cm">** numbers. The rest will get forwarded in pcibios_fixup_bus().</span>
<span class="cm">** We don&#39;t have a struct pci_bus assigned to us yet.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_pat_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pa_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">lba_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytecnt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">io_count</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* PDC return status */</span>
	<span class="kt">long</span> <span class="n">pa_count</span><span class="p">;</span>
	<span class="n">pdc_pat_cell_mod_maddr_block_t</span> <span class="o">*</span><span class="n">pa_pdc_cell</span><span class="p">;</span>	<span class="cm">/* PA_VIEW */</span>
	<span class="n">pdc_pat_cell_mod_maddr_block_t</span> <span class="o">*</span><span class="n">io_pdc_cell</span><span class="p">;</span>	<span class="cm">/* IO_VIEW */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pa_pdc_cell</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pdc_pat_cell_mod_maddr_block_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pa_pdc_cell</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">io_pdc_cell</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pdc_pat_cell_mod_maddr_block_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_pdc_cell</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return cell module (IO view) */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_cell_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytecnt</span><span class="p">,</span> <span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">pcell_loc</span><span class="p">,</span> <span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">mod_index</span><span class="p">,</span>
				<span class="n">PA_VIEW</span><span class="p">,</span> <span class="n">pa_pdc_cell</span><span class="p">);</span>
	<span class="n">pa_count</span> <span class="o">=</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">status</span> <span class="o">|=</span> <span class="n">pdc_pat_cell_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytecnt</span><span class="p">,</span> <span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">pcell_loc</span><span class="p">,</span> <span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">mod_index</span><span class="p">,</span>
				<span class="n">IO_VIEW</span><span class="p">,</span> <span class="n">io_pdc_cell</span><span class="p">);</span>
	<span class="n">io_count</span> <span class="o">=</span> <span class="n">io_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* We&#39;ve already done this once for device discovery...*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;pdc_pat_cell_module() call failed for LBA!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAT_GET_ENTITY</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod_info</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAT_ENTITY_LBA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** Inspect the resources PAT tells us about</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pa_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>	<span class="cm">/* aka finish */</span>
		<span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">io</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">io</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">io_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">]);</span>

		<span class="cm">/* Convert the PAT range data to PCI &quot;struct resource&quot; */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PAT_PBNUM</span>:
			<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAT_LMMIO</span>:
			<span class="cm">/* used to fix up pre-initialized MEM BARs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_name</span><span class="p">,</span>
						<span class="s">&quot;PCI%02x LMMIO&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
				<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space_offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span>
					<span class="n">io</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">;</span>
				<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_name</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_name</span><span class="p">,</span>
						<span class="s">&quot;PCI%02x ELMMIO&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">;</span>
				<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_name</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span>
					<span class="s">&quot; only supports 2 LMMIO resources!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span>  <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span>    <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span>  <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAT_GMMIO</span>:
			<span class="cm">/* MMIO space &gt; 4GB phys addr; for 64-bit BAR */</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_name</span><span class="p">,</span> <span class="s">&quot;PCI%02x GMMIO&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_name</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span>  <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span>    <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span>  <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAT_NPIOP</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span>
				<span class="s">&quot; range[%d] : ignoring NPIOP (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAT_PIOP</span>:
			<span class="cm">/*</span>
<span class="cm">			** Postable I/O port space is per PCI host adapter.</span>
<span class="cm">			** base of 64MB PIOP region</span>
<span class="cm">			*/</span>
			<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">iop_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>

			<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_name</span><span class="p">,</span> <span class="s">&quot;PCI%02x Ports&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_name</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span>  <span class="o">=</span> <span class="n">HBA_PORT_BASE</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_num</span><span class="p">);</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span>    <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">HBA_PORT_SPACE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span>  <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">;</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span>
				<span class="s">&quot; range[%d] : unknown pat range type (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">io_pdc_cell</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* keep compiler from complaining about missing declarations */</span>
<span class="cp">#define lba_pat_port_ops lba_astro_port_ops</span>
<span class="cp">#define lba_pat_resources(pa_dev, lba_dev)</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">sba_distributed_lmmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sba_directed_lmmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lba_legacy_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pa_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">lba_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lba_num</span><span class="p">;</span>

	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space_offset</span> <span class="o">=</span> <span class="n">PCI_F_EXTEND</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** With &quot;legacy&quot; firmware, the lowest byte of FW_SCRATCH</span>
<span class="cm">	** represents bus-&gt;secondary and the second byte represents</span>
<span class="cm">	** bus-&gt;subsidiary (i.e. highest PPB programmed by firmware).</span>
<span class="cm">	** PCI bus walk *should* end up with the same result.</span>
<span class="cm">	** FIXME: But we don&#39;t have sanity checks in PCI or LBA.</span>
<span class="cm">	*/</span>
	<span class="n">lba_num</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_FW_SCRATCH</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;LBA PCI Busses&quot;</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">lba_num</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">lba_num</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/* Set up local PCI Bus resources - we don&#39;t need them for</span>
<span class="cm">	** Legacy boxes but it&#39;s nice to see in /proc/iomem.</span>
<span class="cm">	*/</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_name</span><span class="p">,</span> <span class="s">&quot;PCI%02x LMMIO&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_name</span><span class="p">;</span>

<span class="cp">#if 1</span>
	<span class="cm">/* We want the CPU -&gt; IO routing of addresses.</span>
<span class="cm">	 * The SBA BASE/MASK registers control CPU -&gt; IO routing.</span>
<span class="cm">	 * Ask SBA what is routed to this rope/LBA.</span>
<span class="cm">	 */</span>
	<span class="n">sba_distributed_lmmio</span><span class="p">(</span><span class="n">pa_dev</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * The LBA BASE/MASK registers control IO -&gt; System routing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The following code works but doesn&#39;t get us what we want.</span>
<span class="cm">	 * Well, only because firmware (v5.0) on C3000 doesn&#39;t program</span>
<span class="cm">	 * the LBA BASE/MASE registers to be the exact inverse of </span>
<span class="cm">	 * the corresponding SBA registers. Other Astro/Pluto</span>
<span class="cm">	 * based platform firmware may do it right.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Should someone want to mess with MSI, they may need to</span>
<span class="cm">	 * reprogram LBA BASE/MASK registers. Thus preserve the code</span>
<span class="cm">	 * below until MSI is known to work on C3000/A500/N4000/RP3440.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Using the code below, /proc/iomem shows:</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * f0000000-f0ffffff : PCI00 LMMIO</span>
<span class="cm">	 *   f05d0000-f05d0000 : lcd_data</span>
<span class="cm">	 *   f05d0008-f05d0008 : lcd_cmd</span>
<span class="cm">	 * f1000000-f1ffffff : PCI01 LMMIO</span>
<span class="cm">	 * f4000000-f4ffffff : PCI02 LMMIO</span>
<span class="cm">	 *   f4000000-f4001fff : sym53c8xx</span>
<span class="cm">	 *   f4002000-f4003fff : sym53c8xx</span>
<span class="cm">	 *   f4004000-f40043ff : sym53c8xx</span>
<span class="cm">	 *   f4005000-f40053ff : sym53c8xx</span>
<span class="cm">	 *   f4007000-f4007fff : ohci_hcd</span>
<span class="cm">	 *   f4008000-f40083ff : tulip</span>
<span class="cm">	 * f6000000-f6ffffff : PCI03 LMMIO</span>
<span class="cm">	 * f8000000-fbffffff : PCI00 ELMMIO</span>
<span class="cm">	 *   fa100000-fa4fffff : stifb mmio</span>
<span class="cm">	 *   fb000000-fb1fffff : stifb fb</span>
<span class="cm">	 *</span>
<span class="cm">	 * But everything listed under PCI02 actually lives under PCI00.</span>
<span class="cm">	 * This is clearly wrong.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Asking SBA how things are routed tells the correct story:</span>
<span class="cm">	 * LMMIO_BASE/MASK/ROUTE f4000001 fc000000 00000000</span>
<span class="cm">	 * DIR0_BASE/MASK/ROUTE fa000001 fe000000 00000006</span>
<span class="cm">	 * DIR1_BASE/MASK/ROUTE f9000001 ff000000 00000004</span>
<span class="cm">	 * DIR2_BASE/MASK/ROUTE f0000000 fc000000 00000000</span>
<span class="cm">	 * DIR3_BASE/MASK/ROUTE f0000000 fc000000 00000000</span>
<span class="cm">	 *</span>
<span class="cm">	 * Which looks like this in /proc/iomem:</span>
<span class="cm">	 * f4000000-f47fffff : PCI00 LMMIO</span>
<span class="cm">	 *   f4000000-f4001fff : sym53c8xx</span>
<span class="cm">	 *   ...[deteled core devices - same as above]...</span>
<span class="cm">	 *   f4008000-f40083ff : tulip</span>
<span class="cm">	 * f4800000-f4ffffff : PCI01 LMMIO</span>
<span class="cm">	 * f6000000-f67fffff : PCI02 LMMIO</span>
<span class="cm">	 * f7000000-f77fffff : PCI03 LMMIO</span>
<span class="cm">	 * f9000000-f9ffffff : PCI02 ELMMIO</span>
<span class="cm">	 * fa000000-fbffffff : PCI03 ELMMIO</span>
<span class="cm">	 *   fa100000-fa4fffff : stifb mmio</span>
<span class="cm">	 *   fb000000-fb1fffff : stifb fb</span>
<span class="cm">	 *</span>
<span class="cm">	 * ie all Built-in core are under now correctly under PCI00.</span>
<span class="cm">	 * The &quot;PCI02 ELMMIO&quot; directed range is for:</span>
<span class="cm">	 *  +-[02]---03.0  3Dfx Interactive, Inc. Voodoo 2</span>
<span class="cm">	 *</span>
<span class="cm">	 * All is well now.</span>
<span class="cm">	 */</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_LMMIO_BASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rsize</span><span class="p">;</span>

		<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
		<span class="cm">/* mmio_mask also clears Enable bit */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;=</span> <span class="n">mmio_mask</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">PCI_HOST_ADDR</span><span class="p">(</span><span class="n">HBA_DATA</span><span class="p">(</span><span class="n">lba_dev</span><span class="p">),</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">rsize</span> <span class="o">=</span> <span class="o">~</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_LMMIO_MASK</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		** Each rope only gets part of the distributed range.</span>
<span class="cm">		** Adjust &quot;window&quot; for this rope.</span>
<span class="cm">		*/</span>
		<span class="n">rsize</span> <span class="o">/=</span> <span class="n">ROPES_PER_IOC</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">LBA_NUM</span><span class="p">(</span><span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">rsize</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Not enabled. */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	** &quot;Directed&quot; ranges are used when the &quot;distributed range&quot; isn&#39;t</span>
<span class="cm">	** sufficient for all devices below a given LBA.  Typically devices</span>
<span class="cm">	** like graphics cards or X25 may need a directed range when the</span>
<span class="cm">	** bus has multiple slots (ie multiple devices) or the device</span>
<span class="cm">	** needs more than the typical 4 or 8MB a distributed range offers.</span>
<span class="cm">	**</span>
<span class="cm">	** The main reason for ignoring it now frigging complications.</span>
<span class="cm">	** Directed ranges may overlap (and have precedence) over</span>
<span class="cm">	** distributed ranges. Or a distributed range assigned to a unused</span>
<span class="cm">	** rope may be used by a directed range on a different rope.</span>
<span class="cm">	** Support for graphics devices may require fixing this</span>
<span class="cm">	** since they may be assigned a directed range which overlaps</span>
<span class="cm">	** an existing (but unused portion of) distributed range.</span>
<span class="cm">	*/</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_name</span><span class="p">,</span> <span class="s">&quot;PCI%02x ELMMIO&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_name</span><span class="p">;</span>

<span class="cp">#if 1</span>
	<span class="cm">/* See comment which precedes call to sba_directed_lmmio() */</span>
	<span class="n">sba_directed_lmmio</span><span class="p">(</span><span class="n">pa_dev</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ELMMIO_BASE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rsize</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
		<span class="cm">/* mmio_mask also clears Enable bit */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;=</span> <span class="n">mmio_mask</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">PCI_HOST_ADDR</span><span class="p">(</span><span class="n">HBA_DATA</span><span class="p">(</span><span class="n">lba_dev</span><span class="p">),</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">rsize</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ELMMIO_MASK</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="o">~</span><span class="n">rsize</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_name</span><span class="p">,</span> <span class="s">&quot;PCI%02x Ports&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_name</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_IOS_BASE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1L</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">READ_REG32</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_IOS_MASK</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">HBA_PORT_SPACE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Virtualize the I/O Port space ranges */</span>
	<span class="n">lba_num</span> <span class="o">=</span> <span class="n">HBA_PORT_BASE</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_num</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">|=</span> <span class="n">lba_num</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span>   <span class="o">|=</span> <span class="n">lba_num</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**   LBA initialization code (HW and SW)</span>
<span class="cm">**</span>
<span class="cm">**   o identify LBA chip itself</span>
<span class="cm">**   o initialize LBA chip modes (HardFail)</span>
<span class="cm">**   o FIXME: initialize DMA hints for reasonable defaults</span>
<span class="cm">**   o enable configuration functions</span>
<span class="cm">**   o call pci_register_ops() to discover devs (fixup/fixup_bus get invoked)</span>
<span class="cm">**</span>
<span class="cm">**************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">lba_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bus_reset</span><span class="p">;</span>	<span class="cm">/* PDC_PAT_BUG */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_DEBUG &quot;LBA %lx  STAT_CTL %Lx  ERROR_CFG %Lx  STATUS %Lx DMA_CTL %Lx\n&quot;,</span>
<span class="c">		d-&gt;hba.base_addr,</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_STAT_CTL),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ERROR_CONFIG),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ERROR_STATUS),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_DMA_CTL) );</span>
<span class="c">	printk(KERN_DEBUG &quot;	ARB mask %Lx  pri %Lx  mode %Lx  mtlt %Lx\n&quot;,</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ARB_MASK),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ARB_PRI),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ARB_MODE),</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_ARB_MTLT) );</span>
<span class="c">	printk(KERN_DEBUG &quot;	HINT cfg 0x%Lx\n&quot;,</span>
<span class="c">		READ_REG64(d-&gt;hba.base_addr + LBA_HINT_CFG));</span>
<span class="c">	printk(KERN_DEBUG &quot;	HINT reg &quot;);</span>
<span class="c">	{ int i;</span>
<span class="c">	for (i=LBA_HINT_BASE; i&lt; (14*8 + LBA_HINT_BASE); i+=8)</span>
<span class="c">		printk(&quot; %Lx&quot;, READ_REG64(d-&gt;hba.base_addr + i));</span>
<span class="c">	}</span>
<span class="c">	printk(&quot;\n&quot;);</span>
<span class="cp">#endif	/* DEBUG_LBA_PAT */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cm">/*</span>
<span class="cm"> * FIXME add support for PDC_PAT_IO &quot;Get slot status&quot; - OLAR support</span>
<span class="cm"> * Only N-Class and up can really make use of Get slot status.</span>
<span class="cm"> * maybe L-class too but I&#39;ve never played with it there.</span>
<span class="cm"> */</span>
<span class="cp">#endif</span>

	<span class="cm">/* PDC_PAT_BUG: exhibited in rev 40.48  on L2000 */</span>
	<span class="n">bus_reset</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_STAT_CTL</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NOTICE: PCI bus reset still asserted! (clearing)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ERROR_CONFIG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">LBA_SMART_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NOTICE: LBA in SMART mode! (cleared)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBA_SMART_MODE</span><span class="p">;</span>
		<span class="n">WRITE_REG32</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ERROR_CONFIG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set HF mode as the default (vs. -1 mode). */</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_STAT_CTL</span><span class="p">);</span>
	<span class="n">WRITE_REG32</span><span class="p">(</span><span class="n">stat</span> <span class="o">|</span> <span class="n">HF_ENABLE</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_STAT_CTL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Writing a zero to STAT_CTL.rf (bit 0) will clear reset signal</span>
<span class="cm">	** if it&#39;s not already set. If we just cleared the PCI Bus Reset</span>
<span class="cm">	** signal, wait a bit for the PCI devices to recover and setup.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_reset</span><span class="p">)</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">pci_post_reset_delay</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ARB_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** PDC_PAT_BUG: PDC rev 40.48 on L2000.</span>
<span class="cm">		** B2000/C3600/J6000 also have this problem?</span>
<span class="cm">		** </span>
<span class="cm">		** Elroys with hot pluggable slots don&#39;t get configured</span>
<span class="cm">		** correctly if the slot is empty.  ARB_MASK is set to 0</span>
<span class="cm">		** and we can&#39;t master transactions on the bus if it&#39;s</span>
<span class="cm">		** not at least one. 0x3 enables elroy and first slot.</span>
<span class="cm">		*/</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NOTICE: Enabling PCI Arbitration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">WRITE_REG32</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_ARB_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** FIXME: Hint registers are programmed with default hint</span>
<span class="cm">	** values by firmware. Hints should be sane even if we</span>
<span class="cm">	** can&#39;t reprogram them the way drivers want.</span>
<span class="cm">	*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unfortunately, when firmware numbers busses, it doesn&#39;t take into account</span>
<span class="cm"> * Cardbus bridges.  So we have to renumber the busses to suit ourselves.</span>
<span class="cm"> * Elroy/Mercury don&#39;t actually know what bus number they&#39;re attached to;</span>
<span class="cm"> * we use bus 0 to indicate the directly attached bus and any other bus</span>
<span class="cm"> * number will be taken care of by the PCI-PCI bridge.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba_next_bus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if lba should claim this chip (return 0) or not (return 1).</span>
<span class="cm"> * If so, initialize the chip and tell other partners in crime they</span>
<span class="cm"> * have work to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">lba_driver_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lba_device</span> <span class="o">*</span><span class="n">lba_dev</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">resources</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">lba_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">cfg_ops</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">func_class</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tmp_obj</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="cm">/* Read HW Rev First */</span>
	<span class="n">func_class</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">LBA_FCLASS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ELROY</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>	
		<span class="n">func_class</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">func_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR1.0&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR2.0&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR2.1&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR2.2&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR3.0&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">5</span>:	<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR4.0&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">version</span> <span class="o">=</span> <span class="s">&quot;TR4+&quot;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Elroy version %s (0x%x) found at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">version</span><span class="p">,</span> <span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">func_class</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Can&#39;t support LBA older than &quot;</span>
				<span class="s">&quot;TR2.1 - continuing under adversity.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* Elroy TR4.0 should work with simple algorithm.</span>
<span class="c">   But it doesn&#39;t.  Still missing something. *sigh*</span>
<span class="c">*/</span>
<span class="c">		if (func_class &gt; 4) {</span>
<span class="c">			cfg_ops = &amp;mercury_cfg_ops;</span>
<span class="c">		} else</span>
<span class="cp">#endif</span>
		<span class="p">{</span>
			<span class="n">cfg_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elroy_cfg_ops</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_MERCURY</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_QUICKSILVER</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">;</span>

		<span class="n">func_class</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">major</span> <span class="o">=</span> <span class="n">func_class</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

		<span class="cm">/* We could use one printk for both Elroy and Mercury,</span>
<span class="cm">                 * but for the mask for func_class.</span>
<span class="cm">                 */</span> 
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s version TR%d.%d (0x%x) found at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">IS_MERCURY</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Mercury&quot;</span> <span class="o">:</span> <span class="s">&quot;Quicksilver&quot;</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span>
		       <span class="n">minor</span><span class="p">,</span> <span class="n">func_class</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>

		<span class="n">cfg_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mercury_cfg_ops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unknown LBA found at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell I/O SAPIC driver we have a IRQ handler/region. */</span>
	<span class="n">tmp_obj</span> <span class="o">=</span> <span class="n">iosapic_register</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">LBA_IOSAPIC_BASE</span><span class="p">);</span>

	<span class="cm">/* NOTE: PCI devices (e.g. 103c:1005 graphics card) which don&#39;t</span>
<span class="cm">	**	have an IRT entry will get NULL back from iosapic code.</span>
<span class="cm">	*/</span>
	
	<span class="n">lba_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lba_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;lba_init_chip - couldn&#39;t alloc lba_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/* ---------- First : initialize data we already have --------- */</span>

	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hw_rev</span> <span class="o">=</span> <span class="n">func_class</span><span class="p">;</span>
	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">iosapic_obj</span> <span class="o">=</span> <span class="n">tmp_obj</span><span class="p">;</span>  <span class="cm">/* save interrupt handle */</span>
	<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">sba_get_iommu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>  <span class="cm">/* get iommu data */</span>
	<span class="n">parisc_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba_dev</span><span class="p">);</span>

	<span class="cm">/* ------------ Second : initialize common stuff ---------- */</span>
	<span class="n">pci_bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_bios_ops</span><span class="p">;</span>
	<span class="n">pcibios_register_hba</span><span class="p">(</span><span class="n">HBA_DATA</span><span class="p">(</span><span class="n">lba_dev</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">lba_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lba_hw_init</span><span class="p">(</span><span class="n">lba_dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* ---------- Third : setup I/O Port and MMIO resources  --------- */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* PDC PAT firmware uses PIOP region of GMMIO space. */</span>
		<span class="n">pci_port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_pat_port_ops</span><span class="p">;</span>
		<span class="cm">/* Go ask PDC PAT what resources this LBA has */</span>
		<span class="n">lba_pat_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">astro_iop_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Sprockets PDC uses NPIOP region */</span>
			<span class="n">astro_iop_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">LBA_PORT_BASE</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
			<span class="n">pci_port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lba_astro_port_ops</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Poke the chip a bit for /proc output */</span>
		<span class="n">lba_legacy_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">lba_next_bus</span><span class="p">)</span>
		<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">lba_next_bus</span><span class="p">;</span>

	<span class="cm">/*   Overlaps with elmmio can (and should) fail here.</span>
<span class="cm">	 *   We will prune (or ignore) the distributed range.</span>
<span class="cm">	 *</span>
<span class="cm">	 *   FIXME: SBA code should register all elmmio ranges first.</span>
<span class="cm">	 *      that would take care of elmmio ranges routed</span>
<span class="cm">	 *	to a different rope (already discovered) from</span>
<span class="cm">	 *	getting registered *after* LBA code has already</span>
<span class="cm">	 *	registered it&#39;s distributed lmmio range.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">truncate_pat_collision</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;LBA: lmmio_space [%lx/%lx] duplicate!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
		<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">,</span>
				<span class="n">HBA_PORT_BASE</span><span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_num</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">.</span><span class="n">start</span><span class="p">)</span>
		<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">elmmio_space</span><span class="p">,</span>
					<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">,</span>
					<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">pci_add_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">gmmio_space</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">lba_dev</span><span class="p">;</span>
	<span class="n">lba_bus</span> <span class="o">=</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">hba_bus</span> <span class="o">=</span>
		<span class="n">pci_create_root_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">bus_num</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
				    <span class="n">cfg_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resources</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_resource_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lba_bus</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">=</span> <span class="n">pci_scan_child_bus</span><span class="p">(</span><span class="n">lba_bus</span><span class="p">);</span>

	<span class="cm">/* This is in lieu of calling pci_assign_unassigned_resources() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* assign resources to un-initialized devices */</span>

		<span class="n">DBG_PAT</span><span class="p">(</span><span class="s">&quot;LBA pci_bus_size_bridges()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_bus_size_bridges</span><span class="p">(</span><span class="n">lba_bus</span><span class="p">);</span>

		<span class="n">DBG_PAT</span><span class="p">(</span><span class="s">&quot;LBA pci_bus_assign_resources()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_bus_assign_resources</span><span class="p">(</span><span class="n">lba_bus</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_LBA_PAT</span>
		<span class="n">DBG_PAT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">LBA PIOP resource tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lba_dump_res</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">io_space</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">DBG_PAT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">LBA LMMIO resource tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lba_dump_res</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">hba</span><span class="p">.</span><span class="n">lmmio_space</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">pci_enable_bridges</span><span class="p">(</span><span class="n">lba_bus</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Once PCI register ops has walked the bus, access to config</span>
<span class="cm">	** space is restricted. Avoids master aborts on config cycles.</span>
<span class="cm">	** Early LBA revs go fatal on *any* master abort.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">elroy_cfg_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lba_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBA_FLAG_SKIP_PROBE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lba_next_bus</span> <span class="o">=</span> <span class="n">lba_bus</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_bus_add_devices</span><span class="p">(</span><span class="n">lba_bus</span><span class="p">);</span>

	<span class="cm">/* Whew! Finally done! Tell services we got this one covered. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="n">lba_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">HPHW_BRIDGE</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">ELROY_HVERS</span><span class="p">,</span> <span class="mh">0xa</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_BRIDGE</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">MERCURY_HVERS</span><span class="p">,</span> <span class="mh">0xa</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_BRIDGE</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">QUICKSILVER_HVERS</span><span class="p">,</span> <span class="mh">0xa</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_driver</span> <span class="n">lba_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="n">MODULE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">lba_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">lba_driver_probe</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">** One time initialization to let the world know the LBA was found.</span>
<span class="cm">** Must be called exactly once before pci_init().</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">lba_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_parisc_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lba_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Initialize the IBASE/IMASK registers for LBA (Elroy).</span>
<span class="cm">** Only called from sba_iommu.c in order to route ranges (MMIO vs DMA).</span>
<span class="cm">** sba_iommu is responsible for locking (none needed at init time).</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">lba_set_iregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">lba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ibase</span><span class="p">,</span> <span class="n">u32</span> <span class="n">imask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">lba</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">imask</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* adjust for hints - 2 more bits */</span>

	<span class="cm">/* Make sure we aren&#39;t trying to set bits that aren&#39;t writeable. */</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">ibase</span> <span class="o">&amp;</span> <span class="mh">0x001fffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">imask</span> <span class="o">&amp;</span> <span class="mh">0x001fffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%s() ibase 0x%x imask 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ibase</span><span class="p">,</span> <span class="n">imask</span><span class="p">);</span>
	<span class="n">WRITE_REG32</span><span class="p">(</span> <span class="n">imask</span><span class="p">,</span> <span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_IMASK</span><span class="p">);</span>
	<span class="n">WRITE_REG32</span><span class="p">(</span> <span class="n">ibase</span><span class="p">,</span> <span class="n">base_addr</span> <span class="o">+</span> <span class="n">LBA_IBASE</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
