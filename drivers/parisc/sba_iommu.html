<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parisc › sba_iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sba_iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">**  System Bus Adapter (SBA) I/O MMU manager</span>
<span class="cm">**</span>
<span class="cm">**	(c) Copyright 2000-2004 Grant Grundler &lt;grundler @ parisc-linux x org&gt;</span>
<span class="cm">**	(c) Copyright 2004 Naresh Kumar Inna &lt;knaresh at india x hp x com&gt;</span>
<span class="cm">**	(c) Copyright 2000-2004 Hewlett-Packard Company</span>
<span class="cm">**</span>
<span class="cm">**	Portions (c) 1999 Dave S. Miller (from sparc64 I/O MMU code)</span>
<span class="cm">**</span>
<span class="cm">**	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**	it under the terms of the GNU General Public License as published by</span>
<span class="cm">**      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**      (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** This module initializes the IOC (I/O Controller) found on B1000/C3000/</span>
<span class="cm">** J5000/J7000/N-class/L-class machines and their successors.</span>
<span class="cm">**</span>
<span class="cm">** FIXME: add DMA hint support programming in both sba and lba modules.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/iommu-helper.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;		</span><span class="cm">/* for DMA_CHUNK_SIZE */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/hardware.h&gt;	</span><span class="cm">/* for register_parisc_driver() stuff */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/ropes.h&gt;</span>
<span class="cp">#include &lt;asm/mckinley.h&gt;	</span><span class="cm">/* for proc_mckinley_root */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/runway.h&gt;		</span><span class="cm">/* for proc_runway_root */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/page.h&gt;		</span><span class="cm">/* for PAGE0 */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/pdc.h&gt;		</span><span class="cm">/* for PDC_MODEL_* */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/pdcpat.h&gt;		</span><span class="cm">/* for is_pdc_pat() */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/parisc-device.h&gt;</span>

<span class="cp">#define MODULE_NAME &quot;SBA&quot;</span>

<span class="cm">/*</span>
<span class="cm">** The number of debug flags is a clue - this code is fragile.</span>
<span class="cm">** Don&#39;t even think about messing with it unless you have</span>
<span class="cm">** plenty of 710&#39;s to sacrifice to the computer gods. :^)</span>
<span class="cm">*/</span>
<span class="cp">#undef DEBUG_SBA_INIT</span>
<span class="cp">#undef DEBUG_SBA_RUN</span>
<span class="cp">#undef DEBUG_SBA_RUN_SG</span>
<span class="cp">#undef DEBUG_SBA_RESOURCE</span>
<span class="cp">#undef ASSERT_PDIR_SANITY</span>
<span class="cp">#undef DEBUG_LARGE_SG_ENTRIES</span>
<span class="cp">#undef DEBUG_DMB_TRAP</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>
<span class="cp">#define DBG_INIT(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_INIT(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_SBA_RUN</span>
<span class="cp">#define DBG_RUN(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_SBA_RUN_SG</span>
<span class="cp">#define DBG_RUN_SG(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN_SG(x...)</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef DEBUG_SBA_RESOURCE</span>
<span class="cp">#define DBG_RES(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RES(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#define SBA_INLINE	__inline__</span>

<span class="cp">#define DEFAULT_DMA_HINT_REG	0</span>

<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_list</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sba_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioc_needs_fdc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* global count of IOMMUs in the system */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">global_ioc_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* PA8700 (Piranha 2.2) bug workaround */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">piranha_bad_128k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Looks nice and keeps the compiler happy */</span>
<span class="cp">#define SBA_DEV(d) ((struct sba_device *) (d))</span>

<span class="cp">#ifdef CONFIG_AGP_PARISC</span>
<span class="cp">#define SBA_AGP_SUPPORT</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_AGP_PARISC*/</span><span class="cp"></span>

<span class="cp">#ifdef SBA_AGP_SUPPORT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sba_reserve_agpgart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sba_reserve_agpgart</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sba_reserve_agpgart</span><span class="p">,</span> <span class="s">&quot;Reserve half of IO pdir as AGPGART&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="cm">/************************************</span>
<span class="cm">** SBA register read and write support</span>
<span class="cm">**</span>
<span class="cm">** BE WARNED: register writes are posted.</span>
<span class="cm">**  (ie follow writes which must reach HW with a read)</span>
<span class="cm">**</span>
<span class="cm">** Superdome (in particular, REO) allows only 64-bit CSR accesses.</span>
<span class="cm">*/</span>
<span class="cp">#define READ_REG32(addr)	readl(addr)</span>
<span class="cp">#define READ_REG64(addr)	readq(addr)</span>
<span class="cp">#define WRITE_REG32(val, addr)	writel((val), (addr))</span>
<span class="cp">#define WRITE_REG64(val, addr)	writeq((val), (addr))</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define READ_REG(addr)		READ_REG64(addr)</span>
<span class="cp">#define WRITE_REG(value, addr)	WRITE_REG64(value, addr)</span>
<span class="cp">#else</span>
<span class="cp">#define READ_REG(addr)		READ_REG32(addr)</span>
<span class="cp">#define WRITE_REG(value, addr)	WRITE_REG32(value, addr)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>

<span class="cm">/* NOTE: When CONFIG_64BIT isn&#39;t defined, READ_REG64() is two 32-bit reads */</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dump_ranges - debugging only - print ranges assigned to this IOA</span>
<span class="cm"> * @hpa: base address of the sba</span>
<span class="cm"> *</span>
<span class="cm"> * Print the MMIO and IO Port address ranges forwarded by an Astro/Ike/RIO</span>
<span class="cm"> * IO Adapter (aka Bus Converter).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_ranges</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;SBA at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hpa</span><span class="p">);</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIST_BASE   : %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIST_BASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIST_MASK   : %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIST_MASK</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIST_ROUTE  : %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIST_ROUTE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIRECT_BASE : %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIRECT_BASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIRECT_MASK : %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIRECT_MASK</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOS_DIRECT_ROUTE: %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOS_DIRECT_ROUTE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dump_tlb - debugging only - print IOMMU operating parameters</span>
<span class="cm"> * @hpa: base address of the IOMMU</span>
<span class="cm"> *</span>
<span class="cm"> * Print the size/location of the IO MMU PDIR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sba_dump_tlb</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IO TLB at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hpa</span><span class="p">);</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_IBASE    : 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_IBASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_IMASK    : 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_IMASK</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_TCNFG    : 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_TCNFG</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_PDIR_BASE: 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_PDIR_BASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define sba_dump_ranges(x)</span>
<span class="cp">#define sba_dump_tlb(x)</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG_SBA_INIT */</span><span class="cp"></span>


<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dump_pdir_entry - debugging only - print one IOMMU PDIR entry</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @msg: text to print ont the output line.</span>
<span class="cm"> * @pide: pdir index.</span>
<span class="cm"> *</span>
<span class="cm"> * Print one entry of the IO MMU PDIR in human readable form.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_pdir_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">uint</span> <span class="n">pide</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* start printing from lowest pde in rval */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0U</span> <span class="o">*</span> <span class="n">BITS_PER_LONG</span><span class="p">)]);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[(</span><span class="n">pide</span> <span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]);</span>
	<span class="n">uint</span> <span class="n">rcnt</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SBA: %s rp %p bit %d rval 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">msg</span><span class="p">,</span>
		 <span class="n">rptr</span><span class="p">,</span> <span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">rptr</span><span class="p">);</span>

	<span class="n">rcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rcnt</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s %2d %p %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rcnt</span> <span class="o">==</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
				<span class="o">?</span> <span class="s">&quot;    --&gt;&quot;</span> <span class="o">:</span> <span class="s">&quot;       &quot;</span><span class="p">,</span>
			<span class="n">rcnt</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">);</span>
		<span class="n">rcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_check_pdir - debugging only - consistency checker</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @msg: text to print ont the output line.</span>
<span class="cm"> *</span>
<span class="cm"> * Verify the resource map and pdir state is consistent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_check_pdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rptr_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">]);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>	<span class="cm">/* resource map ptr */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">;</span>	<span class="cm">/* pdir ptr */</span>
	<span class="n">uint</span> <span class="n">pide</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rptr</span> <span class="o">&lt;</span> <span class="n">rptr_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rval</span> <span class="o">=</span> <span class="o">*</span><span class="n">rptr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rcnt</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>	<span class="cm">/* number of bits we might check */</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">rcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get last byte and highest bit from that */</span>
			<span class="n">u32</span> <span class="n">pde</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pptr</span><span class="p">)[</span><span class="mi">7</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rval</span> <span class="o">^</span> <span class="n">pde</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				** BUMMER!  -- res_map != pdir --</span>
<span class="cm">				** Dump rval and matching pdir entries</span>
<span class="cm">				*/</span>
				<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">pide</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">rcnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">rval</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* try the next bit */</span>
			<span class="n">pptr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pide</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rptr</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* look at next word of res_map */</span>
	<span class="p">}</span>
	<span class="cm">/* It&#39;d be nice if we always got here :^) */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_dump_sg - debugging only - print Scatter-Gather list</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @startsg: head of the SG list</span>
<span class="cm"> * @nents: number of entries in SG list</span>
<span class="cm"> *</span>
<span class="cm"> * print the SG list so we can verify it&#39;s correct by hand.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_sg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">startsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nents</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %d : %08lx/%05x %p/%05x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nents</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">),</span>
				<span class="n">sg_dma_len</span><span class="p">(</span><span class="n">startsg</span><span class="p">),</span>
				<span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">startsg</span><span class="p">),</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">startsg</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ASSERT_PDIR_SANITY */</span><span class="cp"></span>




<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   I/O Pdir Resource Management</span>
<span class="cm">*</span>
<span class="cm">*   Bits set in the resource map are in use.</span>
<span class="cm">*   Each bit can represent a number of pages.</span>
<span class="cm">*   LSbs represent lower addresses (IOVA&#39;s).</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>
<span class="cp">#define PAGES_PER_RANGE 1	</span><span class="cm">/* could increase this to 4 or 8 if needed */</span><span class="cp"></span>

<span class="cm">/* Convert from IOVP to IOVA and vice versa. */</span>

<span class="cp">#ifdef ZX1_SUPPORT</span>
<span class="cm">/* Pluto (aka ZX1) boxes need to set or clear the ibase bits appropriately */</span>
<span class="cp">#define SBA_IOVA(ioc,iovp,offset,hint_reg) ((ioc-&gt;ibase) | (iovp) | (offset))</span>
<span class="cp">#define SBA_IOVP(ioc,iova) ((iova) &amp; (ioc)-&gt;iovp_mask)</span>
<span class="cp">#else</span>
<span class="cm">/* only support Astro and ancestors. Saves a few cycles in key places */</span>
<span class="cp">#define SBA_IOVA(ioc,iovp,offset,hint_reg) ((iovp) | (offset))</span>
<span class="cp">#define SBA_IOVP(ioc,iova) (iova)</span>
<span class="cp">#endif</span>

<span class="cp">#define PDIR_INDEX(iovp)   ((iovp)&gt;&gt;IOVP_SHIFT)</span>

<span class="cp">#define RESMAP_MASK(n)    (~0UL &lt;&lt; (BITS_PER_LONG - (n)))</span>
<span class="cp">#define RESMAP_IDX_MASK   (sizeof(unsigned long) - 1)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ptr_to_pide</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitshiftcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res_ptr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">bitshiftcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_search_bitmap - find free space in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @bits_wanted: number of entries we need.</span>
<span class="cm"> *</span>
<span class="cm"> * Find consecutive free bits in resource bitmap.</span>
<span class="cm"> * Each bit represents one entry in the IO Pdir.</span>
<span class="cm"> * Cool perf optimization: search for log2(size) bits at a time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">sba_search_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits_wanted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">]);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pide</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">tpide</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boundary_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">boundary_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">IOVP_SHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>

<span class="cp">#if defined(ZX1_SUPPORT)</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">);</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits_wanted</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Search word at a time - no mask needed */</span>
		<span class="k">for</span><span class="p">(;</span> <span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">res_end</span><span class="p">;</span> <span class="o">++</span><span class="n">res_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tpide</span> <span class="o">=</span> <span class="n">ptr_to_pide</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_is_span_boundary</span><span class="p">(</span><span class="n">tpide</span><span class="p">,</span> <span class="n">bits_wanted</span><span class="p">,</span>
						     <span class="n">shift</span><span class="p">,</span>
						     <span class="n">boundary_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">res_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_wanted</span><span class="p">);</span>
				<span class="n">pide</span> <span class="o">=</span> <span class="n">tpide</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* point to the next word on next pass */</span>
		<span class="n">res_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** Search the resource bit map on well-aligned values.</span>
<span class="cm">		** &quot;o&quot; is the alignment.</span>
<span class="cm">		** We need the alignment to invalidate I/O TLB using</span>
<span class="cm">		** SBA HW features in the unmap path.</span>
<span class="cm">		*/</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">bits_wanted</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">uint</span> <span class="n">bitshiftcnt</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bitshiftcnt</span> <span class="o">&gt;=</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bitshiftcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">res_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_wanted</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bitshiftcnt</span><span class="p">;</span>

		<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s() o %ld %p&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">res_end</span><span class="p">)</span>
		<span class="p">{</span> 
			<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;    %p %lx %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">tpide</span> <span class="o">=</span> <span class="n">ptr_to_pide</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="n">bitshiftcnt</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_is_span_boundary</span><span class="p">(</span><span class="n">tpide</span><span class="p">,</span> <span class="n">bits_wanted</span><span class="p">,</span>
						     <span class="n">shift</span><span class="p">,</span>
						     <span class="n">boundary_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((((</span><span class="o">*</span><span class="n">res_ptr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">res_ptr</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>     <span class="cm">/* mark resources busy! */</span>
				<span class="n">pide</span> <span class="o">=</span> <span class="n">tpide</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">o</span><span class="p">;</span>
			<span class="n">bitshiftcnt</span> <span class="o">+=</span> <span class="n">o</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_wanted</span><span class="p">);</span>
				<span class="n">bitshiftcnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
				<span class="n">res_ptr</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* look in the same word on the next pass */</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="n">bitshiftcnt</span> <span class="o">+</span> <span class="n">bits_wanted</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wrapped ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_end</span> <span class="o">&lt;=</span> <span class="n">res_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="n">res_ptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pide</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_alloc_range - find free bits and mark them in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @size: number of bytes to create a mapping for</span>
<span class="cm"> *</span>
<span class="cm"> * Given a size, find consecutive unmarked and then mark those bits in the</span>
<span class="cm"> * resource bit map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_alloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr_start</span> <span class="o">=</span> <span class="n">mfctl</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pide</span><span class="p">;</span>

	<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_search_bitmap</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_search_bitmap</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: I/O MMU @ %p is out of mapping resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">__FILE__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="cm">/* verify the first enable bit is clear */</span>
	<span class="k">if</span><span class="p">(</span><span class="mh">0x00</span> <span class="o">!=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)[</span><span class="n">pide</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="s">&quot;sba_search_bitmap() botched it?&quot;</span><span class="p">,</span> <span class="n">pide</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s(%x) %d -&gt; %lx hint %x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="n">pide</span><span class="p">,</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">),</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="p">);</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr_end</span> <span class="o">=</span> <span class="n">mfctl</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cr_end</span> <span class="o">-</span> <span class="n">cr_start</span><span class="p">;</span>
		<span class="cm">/* check for roll over */</span>
		<span class="n">cr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">cr_end</span> <span class="o">&lt;</span> <span class="n">cr_start</span><span class="p">)</span> <span class="o">?</span>  <span class="o">-</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cr_start</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span> <span class="o">&amp;=</span> <span class="n">SBA_SEARCH_SAMPLE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">+=</span> <span class="n">pages_needed</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pide</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_free_range - unmark bits in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @iova: IO virtual address which was previously allocated.</span>
<span class="cm"> * @size: number of bytes to create a mapping for</span>
<span class="cm"> *</span>
<span class="cm"> * clear bits in the ioc&#39;s resource map</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span>
<span class="nf">sba_free_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp</span> <span class="o">=</span> <span class="n">SBA_IOVP</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pide</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">pide</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* convert bit to byte address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">ioc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ridx</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RESMAP_IDX_MASK</span><span class="p">]);</span>

	<span class="kt">int</span> <span class="n">bits_not_wanted</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>

	<span class="cm">/* 3-bits &quot;bit&quot; address plus 2 (or 3) bits for &quot;byte&quot; == bit in word */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_not_wanted</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s( ,%x,%x) %x/%lx %x %p %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="n">bits_not_wanted</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pide</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">-=</span> <span class="n">bits_not_wanted</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">res_ptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   &quot;Dynamic DMA Mapping&quot; support (aka &quot;Coherent I/O&quot;)</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>

<span class="cp">#ifdef SBA_HINT_SUPPORT</span>
<span class="cp">#define SBA_DMA_HINT(ioc, val) ((val) &lt;&lt; (ioc)-&gt;hint_shift_pdir)</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">space_t</span><span class="p">;</span>
<span class="cp">#define KERNEL_SPACE 0</span>

<span class="cm">/**</span>
<span class="cm"> * sba_io_pdir_entry - fill in one IO PDIR entry</span>
<span class="cm"> * @pdir_ptr:  pointer to IO PDIR entry</span>
<span class="cm"> * @sid: process Space ID - currently only support KERNEL_SPACE</span>
<span class="cm"> * @vba: Virtual CPU address of buffer to map</span>
<span class="cm"> * @hint: DMA hint set to use for this mapping</span>
<span class="cm"> *</span>
<span class="cm"> * SBA Mapping Routine</span>
<span class="cm"> *</span>
<span class="cm"> * Given a virtual address (vba, arg2) and space id, (sid, arg1)</span>
<span class="cm"> * sba_io_pdir_entry() loads the I/O PDIR entry pointed to by</span>
<span class="cm"> * pdir_ptr (arg0). </span>
<span class="cm"> * Using the bass-ackwards HP bit numbering, Each IO Pdir entry</span>
<span class="cm"> * for Astro/Ike looks like:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  0                    19                                 51   55       63</span>
<span class="cm"> * +-+---------------------+----------------------------------+----+--------+</span>
<span class="cm"> * |V|        U            |            PPN[43:12]            | U  |   VI   |</span>
<span class="cm"> * +-+---------------------+----------------------------------+----+--------+</span>
<span class="cm"> *</span>
<span class="cm"> * Pluto is basically identical, supports fewer physical address bits:</span>
<span class="cm"> *</span>
<span class="cm"> *  0                       23                              51   55       63</span>
<span class="cm"> * +-+------------------------+-------------------------------+----+--------+</span>
<span class="cm"> * |V|        U               |         PPN[39:12]            | U  |   VI   |</span>
<span class="cm"> * +-+------------------------+-------------------------------+----+--------+</span>
<span class="cm"> *</span>
<span class="cm"> *  V  == Valid Bit  (Most Significant Bit is bit 0)</span>
<span class="cm"> *  U  == Unused</span>
<span class="cm"> * PPN == Physical Page Number</span>
<span class="cm"> * VI  == Virtual Index (aka Coherent Index)</span>
<span class="cm"> *</span>
<span class="cm"> * LPA instruction output is put into PPN field.</span>
<span class="cm"> * LCI (Load Coherence Index) instruction provides the &quot;VI&quot; bits.</span>
<span class="cm"> *</span>
<span class="cm"> * We pre-swap the bytes since PCX-W is Big Endian and the</span>
<span class="cm"> * IOMMU uses little endian for the pdir.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">SBA_INLINE</span>
<span class="nf">sba_io_pdir_entry</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">pdir_ptr</span><span class="p">,</span> <span class="n">space_t</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vba</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">pa</span><span class="p">;</span> <span class="cm">/* physical address */</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="n">ci</span><span class="p">;</span> <span class="cm">/* coherent index */</span>

	<span class="n">pa</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">vba</span><span class="p">);</span>
	<span class="n">pa</span> <span class="o">&amp;=</span> <span class="n">IOVP_MASK</span><span class="p">;</span>

	<span class="n">mtsp</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;lci 0(%%sr1, %1), %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">vba</span><span class="p">));</span>
	<span class="n">pa</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ci</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>  <span class="cm">/* move CI (8 bits) into lowest byte */</span>

	<span class="n">pa</span> <span class="o">|=</span> <span class="n">SBA_PDIR_VALID_BIT</span><span class="p">;</span>	<span class="cm">/* set &quot;valid&quot; bit */</span>
	<span class="o">*</span><span class="n">pdir_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>	<span class="cm">/* swap and store into I/O Pdir */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the PDC_MODEL capabilities has Non-coherent IO-PDIR bit set</span>
<span class="cm">	 * (bit #61, big endian), we have to flush and sync every time</span>
<span class="cm">	 * IO-PDIR is changed in Ike/Astro.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;fdc %%r0(%0)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pdir_ptr</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_mark_invalid - invalidate one or more IO PDIR entries</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @iova:  IO Virtual Address mapped earlier</span>
<span class="cm"> * @byte_cnt:  number of bytes this mapping covers.</span>
<span class="cm"> *</span>
<span class="cm"> * Marking the IO PDIR entry(ies) as Invalid and invalidate</span>
<span class="cm"> * corresponding IO TLB entry. The Ike PCOM (Purge Command Register)</span>
<span class="cm"> * is to purge stale entries in the IO TLB when unmapping entries.</span>
<span class="cm"> *</span>
<span class="cm"> * The PCOM register supports purging of multiple pages, with a minium</span>
<span class="cm"> * of 1 page and a maximum of 2GB. Hardware requires the address be</span>
<span class="cm"> * aligned to the size of the range being purged. The size of the range</span>
<span class="cm"> * must be a power of 2. The &quot;Cool perf optimization&quot; in the</span>
<span class="cm"> * allocation routine helps keep that true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span>
<span class="nf">sba_mark_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">SBA_IOVP</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="n">iova</span><span class="p">);</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdir_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">)];</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="cm">/* Assert first pdir entry is set.</span>
<span class="cm">	**</span>
<span class="cm">	** Even though this is a big-endian machine, the entries</span>
<span class="cm">	** in the iopdir are little endian. That&#39;s why we look at</span>
<span class="cm">	** the byte at +7 instead of at +0.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="mh">0x80</span> <span class="o">!=</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_ptr</span><span class="p">)[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;sba_mark_invalid()&quot;</span><span class="p">,</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="n">IOVP_SIZE</span><span class="p">)</span>
	<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		unsigned long entries_per_cacheline = ioc_needs_fdc ?</span>
<span class="c">				L1_CACHE_ALIGN(((unsigned long) pdir_ptr))</span>
<span class="c">					- (unsigned long) pdir_ptr;</span>
<span class="c">				: 262144;</span>
<span class="cp">#endif</span>

		<span class="cm">/* set &quot;size&quot; field for PCOM */</span>
		<span class="n">iovp</span> <span class="o">|=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">byte_cnt</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* clear I/O Pdir entry &quot;valid&quot; bit first */</span>
			<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_ptr</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;fdc %%r0(%0)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pdir_ptr</span><span class="p">));</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				entries_per_cacheline = L1_CACHE_SHIFT - 3;</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
			<span class="n">pdir_ptr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">byte_cnt</span> <span class="o">-=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="n">IOVP_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">iovp</span> <span class="o">|=</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>     <span class="cm">/* set &quot;size&quot; field for PCOM */</span>

	<span class="cm">/*</span>
<span class="cm">	** clear I/O PDIR entry &quot;valid&quot; bit.</span>
<span class="cm">	** We have to R/M/W the cacheline regardless how much of the</span>
<span class="cm">	** pdir entry that we clobber.</span>
<span class="cm">	** The rest of the entry would be useful for debugging if we</span>
<span class="cm">	** could dump core on HPMC.</span>
<span class="cm">	*/</span>
	<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_ptr</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;fdc %%r0(%0)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pdir_ptr</span><span class="p">));</span>

	<span class="n">WRITE_REG</span><span class="p">(</span> <span class="n">SBA_IOVA</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dma_supported - PCI driver can query DMA support</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking</span>
<span class="cm"> * @mask:  number of address bits this PCI device can handle</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_dma_supported</span><span class="p">(</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: EISA/ISA/et al not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Documentation/DMA-API-HOWTO.txt tells drivers to try 64-bit</span>
<span class="cm">	 * first, then fall back to 32-bit if that fails.</span>
<span class="cm">	 * We are just &quot;encouraging&quot; 32-bit DMA masks here since we can</span>
<span class="cm">	 * never allow IOMMU bypass unless we add special support for ZX1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if mask is &gt;= than the current max IO Virt Address</span>
<span class="cm">	 * The max IO Virt address will *always* &lt; 30 bits.</span>
<span class="cm">	 */</span>
	<span class="k">return</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">mask</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="p">)));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_map_single - map one buffer and return IOVA for DMA</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @addr:  driver buffer to map.</span>
<span class="cm"> * @size:  number of bytes to map in driver buffer.</span>
<span class="cm"> * @direction:  R/W or both.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span>
<span class="nf">sba_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> 
	<span class="n">dma_addr_t</span> <span class="n">iovp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdir_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pide</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* save offset bits */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">;</span>

	<span class="cm">/* round up to nearest IOVP_SIZE */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IOVP_MASK</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_map_single()&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_alloc_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">pide</span> <span class="o">&lt;&lt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() 0x%p -&gt; 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">iovp</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">pdir_start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span><span class="p">]);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sba_io_pdir_entry</span><span class="p">(</span><span class="n">pdir_start</span><span class="p">,</span> <span class="n">KERNEL_SPACE</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;	pdir 0x%p %02x%02x%02x%02x%02x%02x%02x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pdir_start</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">7</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">6</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">5</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">4</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			<span class="p">);</span>

		<span class="n">addr</span> <span class="o">+=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">IOVP_SIZE</span><span class="p">;</span>
		<span class="n">pdir_start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* force FDC ops in io_pdir_entry() to be visible to IOMMU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_map_single()&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* form complete address */</span>
	<span class="k">return</span> <span class="n">SBA_IOVA</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">DEFAULT_DMA_HINT_REG</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_unmap_single - unmap one IOVA and free resources</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @iova:  IOVA of driver buffer previously mapped.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @direction:  R/W or both.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_unmap_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="k">struct</span> <span class="n">sba_dma_pair</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> 
	<span class="n">dma_addr_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() iovp 0x%lx/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">iova</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">;</span>
	<span class="n">iova</span> <span class="o">^=</span> <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* clear offset bits */</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">IOVP_SIZE</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_calls</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_pages</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOVP_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">sba_mark_invalid</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="cm">/* Delaying when we re-use a IO Pdir entry reduces the number</span>
<span class="cm">	 * of MMIO reads needed to flush writes to the PCOM register.</span>
<span class="cm">	 */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">]);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span> <span class="o">=</span> <span class="n">iova</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">DELAYED_RESOURCE_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sba_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">d</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>	<span class="cm">/* flush purges */</span>
	<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* DELAYED_RESOURCE_CNT == 0 */</span><span class="cp"></span>
	<span class="n">sba_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* If fdc&#39;s were issued, force fdc&#39;s to be visible now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="p">);</span>

	<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>	<span class="cm">/* flush purges */</span>
<span class="cp">#endif </span><span class="cm">/* DELAYED_RESOURCE_CNT == 0 */</span><span class="cp"></span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* XXX REVISIT for 2.5 Linux - need syncdma for zero-copy support.</span>
<span class="cm">	** For Astro based systems this isn&#39;t a big deal WRT performance.</span>
<span class="cm">	** As long as 2.4 kernels copyin/copyout data from/to userspace,</span>
<span class="cm">	** we don&#39;t need the syncdma. The issue here is I/O MMU cachelines</span>
<span class="cm">	** are *not* coherent in all cases.  May be hwrev dependent.</span>
<span class="cm">	** Need to investigate more.</span>
<span class="cm">	asm volatile(&quot;syncdma&quot;);	</span>
<span class="cm">	*/</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_alloc_consistent - allocate/map shared mem for DMA</span>
<span class="cm"> * @hwdev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @dma_handle:  IOVA of new buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sba_alloc_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only support PCI */</span>
		<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">sba_map_single</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_free_consistent - free/unmap shared mem for DMA</span>
<span class="cm"> * @hwdev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @vaddr:  virtual address IOVA of &quot;consistent&quot; buffer.</span>
<span class="cm"> * @dma_handler:  IO virtual address of &quot;consistent&quot; buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_free_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
		    <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sba_unmap_single</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** Since 0 is a valid pdir_base index value, can&#39;t use that</span>
<span class="cm">** to determine if a value is valid or not. Use a flag to indicate</span>
<span class="cm">** the SG list entry contains a valid pdir index.</span>
<span class="cm">*/</span>
<span class="cp">#define PIDE_FLAG 0x80000000UL</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
<span class="cp">#define IOMMU_MAP_STATS</span>
<span class="cp">#endif</span>
<span class="cp">#include &quot;iommu-helpers.h&quot;</span>

<span class="cp">#ifdef DEBUG_LARGE_SG_ENTRIES</span>
<span class="kt">int</span> <span class="n">dump_run_sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * sba_map_sg - map Scatter/Gather list</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @sglist:  array of buffer/length pairs</span>
<span class="cm"> * @nents:  number of entries in list</span>
<span class="cm"> * @direction:  R/W or both.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
	   <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coalesced</span><span class="p">,</span> <span class="n">filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Fast path single entry scatterlists. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">=</span> <span class="n">sba_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span>
						<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
		<span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span>     <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_map_sg()&quot;</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">sba_dump_sg</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Check before sba_map_sg()&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	** First coalesce the chunks and allocate I/O pdir space</span>
<span class="cm">	**</span>
<span class="cm">	** If this is one DMA stream, we can properly map using the</span>
<span class="cm">	** correct virtual address associated with each DMA page.</span>
<span class="cm">	** w/o this association, we wouldn&#39;t have coherent DMA!</span>
<span class="cm">	** Access to the virtual address is what forces a two pass algorithm.</span>
<span class="cm">	*/</span>
	<span class="n">coalesced</span> <span class="o">=</span> <span class="n">iommu_coalesce_chunks</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">sba_alloc_range</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Program the I/O Pdir</span>
<span class="cm">	**</span>
<span class="cm">	** map the virtual addresses to the I/O Pdir</span>
<span class="cm">	** o dma_address will contain the pdir index</span>
<span class="cm">	** o dma_len will contain the number of bytes to map </span>
<span class="cm">	** o address contains the virtual address.</span>
<span class="cm">	*/</span>
	<span class="n">filled</span> <span class="o">=</span> <span class="n">iommu_fill_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sba_io_pdir_entry</span><span class="p">);</span>

	<span class="cm">/* force FDC ops in io_pdir_entry() to be visible to IOMMU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_map_sg()&quot;</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">sba_dump_sg</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Check after sba_map_sg()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE %d mappings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">filled</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">filled</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_unmap_sg - unmap Scatter/Gather list</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @sglist:  array of buffer/length pairs</span>
<span class="cm"> * @nents:  number of entries in list</span>
<span class="cm"> * @direction:  R/W or both.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">sba_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
	     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries,  %p,%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_unmap_sg()&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nents</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">sba_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">direction</span><span class="p">);</span>
<span class="cp">#ifdef SBA_COLLECT_STATS</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span> <span class="o">+=</span> <span class="p">((</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOVP_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">+</span> <span class="n">IOVP_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_calls</span><span class="o">--</span><span class="p">;</span>	<span class="cm">/* kluge since call is unmap_sg() */</span>
<span class="cp">#endif</span>
		<span class="o">++</span><span class="n">sglist</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE (nents %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>  <span class="n">nents</span><span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_unmap_sg()&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hppa_dma_ops</span> <span class="n">sba_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_supported</span> <span class="o">=</span>	<span class="n">sba_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_consistent</span> <span class="o">=</span>	<span class="n">sba_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_noncoherent</span> <span class="o">=</span>	<span class="n">sba_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_consistent</span> <span class="o">=</span>	<span class="n">sba_free_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_single</span> <span class="o">=</span>		<span class="n">sba_map_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_single</span> <span class="o">=</span>		<span class="n">sba_unmap_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span> <span class="o">=</span>		<span class="n">sba_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span> <span class="o">=</span>		<span class="n">sba_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_cpu</span> <span class="o">=</span>	<span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_device</span> <span class="o">=</span>	<span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_cpu</span> <span class="o">=</span>		<span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_device</span> <span class="o">=</span>	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**   SBA PAT PDC support</span>
<span class="cm">**</span>
<span class="cm">**   o call pdc_pat_cell_module()</span>
<span class="cm">**   o store ranges in PCI &quot;resource&quot; structures</span>
<span class="cm">**</span>
<span class="cm">**************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_get_pat_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c">** TODO/REVISIT/FIXME: support for directed ranges requires calls to</span>
<span class="c">**      PAT PDC to program the SBA/LBA directed range registers...this</span>
<span class="c">**      burden may fall on the LBA code since it directly supports the</span>
<span class="c">**      PCI subsystem. It&#39;s not clear yet. - ggg</span>
<span class="c">*/</span>
<span class="c">PAT_MOD(mod)-&gt;mod_info.mod_pages   = PAT_GET_MOD_PAGES(temp);</span>
<span class="c">	FIXME : ???</span>
<span class="c">PAT_MOD(mod)-&gt;mod_info.dvi         = PAT_GET_DVI(temp);</span>
<span class="c">	Tells where the dvi bits are located in the address.</span>
<span class="c">PAT_MOD(mod)-&gt;mod_info.ioc         = PAT_GET_IOC(temp);</span>
<span class="c">	FIXME : ???</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   Initialization and claim</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>
<span class="cp">#define PIRANHA_ADDR_MASK	0x00160000UL </span><span class="cm">/* bit 17,18,20 */</span><span class="cp"></span>
<span class="cp">#define PIRANHA_ADDR_VAL	0x00060000UL </span><span class="cm">/* bit 17,18 on */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">sba_alloc_pdir</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pdir_size</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdir_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdir_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">pdir_base</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">pdir_order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_base</span><span class="p">)</span>	<span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s() could not allocate I/O Page Table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If this is not PA8700 (PCX-W2)</span>
<span class="cm">	**	OR newer than ver 2.2</span>
<span class="cm">	**	OR in a system that doesn&#39;t need VINDEX bits from SBA,</span>
<span class="cm">	**</span>
<span class="cm">	** then we aren&#39;t exposed to the HW bug.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">((</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">pdc</span><span class="p">.</span><span class="n">cpuid</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x13</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">pdc</span><span class="p">.</span><span class="n">versions</span> <span class="o">&gt;</span> <span class="mh">0x202</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">pdc</span><span class="p">.</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="mh">0x08L</span><span class="p">)</span> <span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PA8700 (PCX-W2, aka piranha) silent data corruption fix</span>
<span class="cm">	 *</span>
<span class="cm">	 * An interaction between PA8700 CPU (Ver 2.2 or older) and</span>
<span class="cm">	 * Ike/Astro can cause silent data corruption. This is only</span>
<span class="cm">	 * a problem if the I/O PDIR is located in memory such that</span>
<span class="cm">	 * (little-endian)  bits 17 and 18 are on and bit 20 is off.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since the max IO Pdir size is 2MB, by cleverly allocating the</span>
<span class="cm">	 * right physical address, we can either avoid (IOPDIR &lt;= 1MB)</span>
<span class="cm">	 * or minimize (2MB IO Pdir) the problem if we restrict the</span>
<span class="cm">	 * IO Pdir to a maximum size of 2MB-128K (1902K).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Because we always allocate 2^N sized IO pdirs, either of the</span>
<span class="cm">	 * &quot;bad&quot; regions will be the last 128K if at all. That&#39;s easy</span>
<span class="cm">	 * to test for.</span>
<span class="cm">	 * </span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdir_order</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">19</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">pdir_base</span><span class="p">)</span><span class="o">+</span><span class="n">pdir_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PIRANHA_ADDR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">PIRANHA_ADDR_VAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* allocate a new one on 512k alignment */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_pdir</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="p">(</span><span class="mi">19</span><span class="o">-</span><span class="mi">12</span><span class="p">));</span>
			<span class="cm">/* release original */</span>
			<span class="n">free_pages</span><span class="p">(</span><span class="n">pdir_base</span><span class="p">,</span> <span class="n">pdir_order</span><span class="p">);</span>

			<span class="n">pdir_base</span> <span class="o">=</span> <span class="n">new_pdir</span><span class="p">;</span>

			<span class="cm">/* release excess */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">pdir_order</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">19</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">new_pdir</span> <span class="o">+=</span> <span class="n">pdir_size</span><span class="p">;</span>
				<span class="n">free_pages</span><span class="p">(</span><span class="n">new_pdir</span><span class="p">,</span> <span class="n">pdir_order</span><span class="p">);</span>
				<span class="n">pdir_order</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">pdir_size</span> <span class="o">&lt;&lt;=</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** 1MB or 2MB Pdir</span>
<span class="cm">		** Needs to be aligned on an &quot;odd&quot; 1MB boundary.</span>
<span class="cm">		*/</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_pdir</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">pdir_order</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* 2 or 4MB */</span>

		<span class="cm">/* release original */</span>
		<span class="n">free_pages</span><span class="p">(</span> <span class="n">pdir_base</span><span class="p">,</span> <span class="n">pdir_order</span><span class="p">);</span>

		<span class="cm">/* release first 1MB */</span>
		<span class="n">free_pages</span><span class="p">(</span><span class="n">new_pdir</span><span class="p">,</span> <span class="mi">20</span><span class="o">-</span><span class="mi">12</span><span class="p">);</span>

		<span class="n">pdir_base</span> <span class="o">=</span> <span class="n">new_pdir</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdir_order</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">20</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			** 2MB Pdir.</span>
<span class="cm">			**</span>
<span class="cm">			** Flag tells init_bitmap() to mark bad 128k as used</span>
<span class="cm">			** and to reduce the size by 128k.</span>
<span class="cm">			*/</span>
			<span class="n">piranha_bad_128k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">new_pdir</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
			<span class="cm">/* release last 1MB */</span>
			<span class="n">free_pages</span><span class="p">(</span><span class="n">new_pdir</span><span class="p">,</span> <span class="mi">20</span><span class="o">-</span><span class="mi">12</span><span class="p">);</span>

			<span class="cm">/* release unusable 128KB */</span>
			<span class="n">free_pages</span><span class="p">(</span><span class="n">new_pdir</span> <span class="o">-</span> <span class="mi">128</span><span class="o">*</span><span class="mi">1024</span> <span class="p">,</span> <span class="mi">17</span><span class="o">-</span><span class="mi">12</span><span class="p">);</span>

			<span class="n">pdir_size</span> <span class="o">-=</span> <span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pdir_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdir_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ibase_data_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioc_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_ibase_imask_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* lba_set_iregs() is in drivers/parisc/lba_pci.c */</span>
        <span class="k">extern</span> <span class="kt">void</span> <span class="n">lba_set_iregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">lba</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ibase_data_struct</span> <span class="o">*</span><span class="n">ibd</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rope_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">lba</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rope_num</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">==</span> <span class="n">ibd</span><span class="o">-&gt;</span><span class="n">ioc_num</span><span class="p">)</span>
		<span class="n">lba_set_iregs</span><span class="p">(</span><span class="n">lba</span><span class="p">,</span> <span class="n">ibd</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">,</span> <span class="n">ibd</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* setup Mercury or Elroy IBASE/IMASK registers. */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">setup_ibase_imask</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioc_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ibase_data_struct</span> <span class="n">ibase_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ioc</span>		<span class="o">=</span> <span class="n">ioc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ioc_num</span>	<span class="o">=</span> <span class="n">ioc_num</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibase_data</span><span class="p">,</span>
			      <span class="n">setup_ibase_imask_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef SBA_AGP_SUPPORT</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_ioc_find_quicksilver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">agp_found</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">lba</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_QUICKSILVER</span><span class="p">(</span><span class="n">lba</span><span class="p">))</span>
		<span class="o">*</span><span class="n">agp_found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_ioc_init_pluto</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioc_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iova_space_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iova_space_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iov_order</span><span class="p">,</span> <span class="n">tcnfg</span><span class="p">;</span>
<span class="cp">#ifdef SBA_AGP_SUPPORT</span>
	<span class="kt">int</span> <span class="n">agp_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	** Firmware programs the base and size of a &quot;safe IOVA space&quot;</span>
<span class="cm">	** (one that doesn&#39;t overlap memory or LMMIO space) in the</span>
<span class="cm">	** IBASE and IMASK registers.</span>
<span class="cm">	*/</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IBASE</span><span class="p">);</span>
	<span class="n">iova_space_size</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IMASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFUL</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">&lt;</span> <span class="mh">0xfed00000UL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">+</span> <span class="n">iova_space_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0xfee00000UL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;WARNING: IOV space overlaps local config and interrupt message, truncating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iova_space_size</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** iov_order is always based on a 1GB IOVA space since we want to</span>
<span class="cm">	** turn on the other half for AGP GART.</span>
<span class="cm">	*/</span>
	<span class="n">iov_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">IOVP_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">/</span> <span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() hpa 0x%p IOV %dMB (%d bits)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">,</span> <span class="n">iova_space_size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span>
		<span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
						   <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate I/O Page Table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() pdir %p size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

<span class="cp">#ifdef SBA_HINT_SUPPORT</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_shift_pdir</span> <span class="o">=</span> <span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_mask_pdir</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;	hint_shift_pdir %x hint_mask_pdir %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_shift_pdir</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_mask_pdir</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">WARN_ON</span><span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">);</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">),</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PDIR_BASE</span><span class="p">);</span>

	<span class="cm">/* build IMASK for IOC and Elroy */</span>
	<span class="n">iova_space_mask</span> <span class="o">=</span>  <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">iova_space_mask</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span> <span class="o">=</span> <span class="n">iova_space_mask</span><span class="p">;</span>
<span class="cp">#ifdef ZX1_SUPPORT</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iovp_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">iova_space_mask</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">sba_dump_tlb</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">);</span>

	<span class="n">setup_ibase_imask</span><span class="p">(</span><span class="n">sba</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span> <span class="n">ioc_num</span><span class="p">);</span>

	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IMASK</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="cm">/*</span>
<span class="cm">	** Setting the upper bits makes checking for bypass addresses</span>
<span class="cm">	** a little faster later on.</span>
<span class="cm">	*/</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span> <span class="o">|=</span> <span class="mh">0xFFFFFFFF00000000UL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Set I/O PDIR Page size to system page size */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">12</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>	<span class="cm">/*  4K */</span>
		<span class="k">case</span> <span class="mi">13</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>	<span class="cm">/*  8K */</span>
		<span class="k">case</span> <span class="mi">14</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>	<span class="cm">/* 16K */</span>
		<span class="k">case</span> <span class="mi">16</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>	<span class="cm">/* 64K */</span>
		<span class="nl">default:</span>
			<span class="n">panic</span><span class="p">(</span><span class="n">__FILE__</span> <span class="s">&quot;Unsupported system page size %d&quot;</span><span class="p">,</span>
				<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">tcnfg</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_TCNFG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Program the IOC&#39;s ibase and enable IOVA translation</span>
<span class="cm">	** Bit zero == enable bit.</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IBASE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Clear I/O TLB of any possible entries.</span>
<span class="cm">	** (Yes. This is a bit paranoid...but so what)</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">|</span> <span class="mi">31</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PCOM</span><span class="p">);</span>

<span class="cp">#ifdef SBA_AGP_SUPPORT</span>

	<span class="cm">/*</span>
<span class="cm">	** If an AGP device is present, only use half of the IOV space</span>
<span class="cm">	** for PCI DMA.  Unfortunately we can&#39;t know ahead of time</span>
<span class="cm">	** whether GART support will actually be used, for now we</span>
<span class="cm">	** can just key on any AGP device found in the system.</span>
<span class="cm">	** We program the next pdir index after we stop w/ a key for</span>
<span class="cm">	** the GART code to handshake on.</span>
<span class="cm">	*/</span>
	<span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agp_found</span><span class="p">,</span> <span class="n">sba_ioc_find_quicksilver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">agp_found</span> <span class="o">&amp;&amp;</span> <span class="n">sba_reserve_agpgart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: reserving %dMb of IOVA space for agpgart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">iova_space_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iova_space_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SBA_AGPGART_COOKIE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/*SBA_AGP_SUPPORT*/</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_ioc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioc_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iova_space_size</span><span class="p">,</span> <span class="n">iova_space_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pdir_size</span><span class="p">,</span> <span class="n">iov_order</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** Determine IOVA Space size from memory size.</span>
<span class="cm">	**</span>
<span class="cm">	** Ideally, PCI drivers would register the maximum number</span>
<span class="cm">	** of DMA they can have outstanding for each device they</span>
<span class="cm">	** own.  Next best thing would be to guess how much DMA</span>
<span class="cm">	** can be outstanding based on PCI Class/sub-class. Both</span>
<span class="cm">	** methods still require some &quot;extra&quot; to support PCI</span>
<span class="cm">	** Hot-Plug/Removal of PCI cards. (aka PCI OLARD).</span>
<span class="cm">	**</span>
<span class="cm">	** While we have 32-bits &quot;IOVA&quot; space, top two 2 bits are used</span>
<span class="cm">	** for DMA hints - ergo only 30 bits max.</span>
<span class="cm">	*/</span>

	<span class="n">iova_space_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">totalram_pages</span><span class="o">/</span><span class="n">global_ioc_cnt</span><span class="p">);</span>

	<span class="cm">/* limit IOVA space size to 1MB-1GB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iova_space_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iova_space_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** iova space must be log2() in size.</span>
<span class="cm">	** thus, pdir/res_map will also be log2().</span>
<span class="cm">	** PIRANHA BUG: Exception is when IO Pdir is 2MB (gets reduced)</span>
<span class="cm">	*/</span>
	<span class="n">iov_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">iova_space_size</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/* iova_space_size is now bytes, not pages */</span>
	<span class="n">iova_space_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">=</span> <span class="n">pdir_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">iova_space_size</span><span class="o">/</span><span class="n">IOVP_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() hpa 0x%lx mem %ldMB IOV %dMB (%d bits)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">totalram_pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
			<span class="n">iova_space_size</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span>
			<span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span> <span class="o">=</span> <span class="n">sba_alloc_pdir</span><span class="p">(</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() pdir %p size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="n">pdir_size</span><span class="p">);</span>

<span class="cp">#ifdef SBA_HINT_SUPPORT</span>
	<span class="cm">/* FIXME : DMA HINTs not used */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_shift_pdir</span> <span class="o">=</span> <span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_mask_pdir</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;	hint_shift_pdir %x hint_mask_pdir %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_shift_pdir</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">hint_mask_pdir</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">WRITE_REG64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">),</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PDIR_BASE</span><span class="p">);</span>

	<span class="cm">/* build IMASK for IOC and Elroy */</span>
	<span class="n">iova_space_mask</span> <span class="o">=</span>  <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">iova_space_mask</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">iov_order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** On C3000 w/512MB mem, HP-UX 10.20 reports:</span>
<span class="cm">	**     ibase=0, imask=0xFE000000, size=0x2000000.</span>
<span class="cm">	*/</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span> <span class="o">=</span> <span class="n">iova_space_mask</span><span class="p">;</span>	<span class="cm">/* save it */</span>
<span class="cp">#ifdef ZX1_SUPPORT</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iovp_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">iova_space_mask</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() IOV base 0x%lx mask 0x%0lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** FIXME: Hint registers are programmed with default hint</span>
<span class="cm">	** values during boot, so hints should be sane even if we</span>
<span class="cm">	** can&#39;t reprogram them the way drivers want.</span>
<span class="cm">	*/</span>

	<span class="n">setup_ibase_imask</span><span class="p">(</span><span class="n">sba</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span> <span class="n">ioc_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Program the IOC&#39;s ibase and enable IOVA translation</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_IBASE</span><span class="p">);</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_IMASK</span><span class="p">);</span>

	<span class="cm">/* Set I/O PDIR Page size to 4K */</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_TCNFG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Clear I/O TLB of any possible entries.</span>
<span class="cm">	** (Yes. This is a bit paranoid...but so what)</span>
<span class="cm">	*/</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="mi">0</span> <span class="o">|</span> <span class="mi">31</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* used by SBA_IOVA and related macros */</span>	

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/**************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**   SBA initialization code (HW and SW)</span>
<span class="cm">**</span>
<span class="cm">**   o identify SBA chip itself</span>
<span class="cm">**   o initialize SBA chip modes (HardFail)</span>
<span class="cm">**   o initialize SBA chip modes (HardFail)</span>
<span class="cm">**   o FIXME: initialize DMA hints for reasonable defaults</span>
<span class="cm">**</span>
<span class="cm">**************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">ioc_remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SBA_FUNC_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sba_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_ioc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ioc_ctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* Shutdown the USB controller on Astro-based workstations.</span>
<span class="cm">		** Once we reprogram the IOMMU, the next DMA performed by</span>
<span class="cm">		** USB will HPMC the box. USB is only enabled if a</span>
<span class="cm">		** keyboard is present and found.</span>
<span class="cm">		**</span>
<span class="cm">		** With serial console, j6k v5.0 firmware says:</span>
<span class="cm">		**   mem_kbd hpa 0xfee003f8 sba 0x0 pad 0x0 cl_class 0x7</span>
<span class="cm">		**</span>
<span class="cm">		** FIXME: Using GFX+USB console at power up but direct</span>
<span class="cm">		**	linux to serial console is still broken.</span>
<span class="cm">		**	USB could generate DMA so we must reset USB.</span>
<span class="cm">		**	The proper sequence would be:</span>
<span class="cm">		**	o block console output</span>
<span class="cm">		**	o reset USB device</span>
<span class="cm">		**	o reprogram serial port</span>
<span class="cm">		**	o unblock console output</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">cl_class</span> <span class="o">==</span> <span class="n">CL_KEYBD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdc_io_reset_devices</span><span class="p">();</span>
		<span class="p">}</span>

	<span class="p">}</span>


<span class="cp">#if 0</span><span class="c"></span>
<span class="c">printk(&quot;sba_hw_init(): mem_boot 0x%x 0x%x 0x%x 0x%x\n&quot;, PAGE0-&gt;mem_boot.hpa,</span>
<span class="c">	PAGE0-&gt;mem_boot.spa, PAGE0-&gt;mem_boot.pad, PAGE0-&gt;mem_boot.cl_class);</span>

<span class="c">	/*</span>
<span class="c">	** Need to deal with DMA from LAN.</span>
<span class="c">	**	Maybe use page zero boot device as a handle to talk</span>
<span class="c">	**	to PDC about which device to shutdown.</span>
<span class="c">	**</span>
<span class="c">	** Netbooting, j6k v5.0 firmware says:</span>
<span class="c">	** 	mem_boot hpa 0xf4008000 sba 0x0 pad 0x0 cl_class 0x1002</span>
<span class="c">	** ARGH! invalid class.</span>
<span class="c">	*/</span>
<span class="c">	if ((PAGE0-&gt;mem_boot.cl_class != CL_RANDOM)</span>
<span class="c">		&amp;&amp; (PAGE0-&gt;mem_boot.cl_class != CL_SEQU)) {</span>
<span class="c">			pdc_io_reset();</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ioc_ctl</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span><span class="o">+</span><span class="n">IOC_CTRL</span><span class="p">);</span>
		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() hpa 0x%lx ioc_ctl 0x%Lx -&gt;&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span><span class="p">,</span> <span class="n">ioc_ctl</span><span class="p">);</span>
		<span class="n">ioc_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IOC_CTRL_RM</span> <span class="o">|</span> <span class="n">IOC_CTRL_NC</span> <span class="o">|</span> <span class="n">IOC_CTRL_CE</span><span class="p">);</span>
		<span class="n">ioc_ctl</span> <span class="o">|=</span> <span class="n">IOC_CTRL_DD</span> <span class="o">|</span> <span class="n">IOC_CTRL_D4</span> <span class="o">|</span> <span class="n">IOC_CTRL_TC</span><span class="p">;</span>
			<span class="cm">/* j6700 v1.6 firmware sets 0x294f */</span>
			<span class="cm">/* A500 firmware sets 0x4d */</span>

		<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc_ctl</span><span class="p">,</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span><span class="o">+</span><span class="n">IOC_CTRL</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>
		<span class="n">ioc_ctl</span> <span class="o">=</span> <span class="n">READ_REG64</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span><span class="o">+</span><span class="n">IOC_CTRL</span><span class="p">);</span>
		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot; 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc_ctl</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="cm">/* if !PLUTO */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ASTRO</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">ioc_remap</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">,</span> <span class="n">ASTRO_IOC_OFFSET</span><span class="p">);</span>
		<span class="n">num_ioc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Astro Intr Ack&quot;</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">PCI_F_EXTEND</span> <span class="o">|</span> <span class="mh">0xfef00000UL</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="n">PCI_F_EXTEND</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xff000000UL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">ioc_remap</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">,</span> <span class="n">PLUTO_IOC_OFFSET</span><span class="p">);</span>
		<span class="n">num_ioc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Pluto Intr/PIOP/VGA&quot;</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">PCI_F_EXTEND</span> <span class="o">|</span> <span class="mh">0xfee00000UL</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="n">PCI_F_EXTEND</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xff200000UL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">chip_resv</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">iommu_resv</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;IOVA Space&quot;</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">iommu_resv</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mh">0x40000000UL</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">iommu_resv</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="mh">0x50000000UL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">iommu_resv</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* IKE, REO */</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">ioc_remap</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">,</span> <span class="n">IKE_IOC_OFFSET</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">ioc_remap</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">,</span> <span class="n">IKE_IOC_OFFSET</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">num_ioc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* TODO - LOOKUP Ike/Stretch chipset mem map */</span>
	<span class="p">}</span>
	<span class="cm">/* XXX: What about Reo Grande? */</span>

	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">num_ioc</span> <span class="o">=</span> <span class="n">num_ioc</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ioc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">ROPES_PER_IOC</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Clear ROPE(N)_CONFIG AO bit.</span>
<span class="cm">			 * Disables &quot;NT Ordering&quot; (~= !&quot;Relaxed Ordering&quot;)</span>
<span class="cm">			 * Overrides bit 1 in DMA Hint Sets.</span>
<span class="cm">			 * Improves netperf UDP_STREAM by ~10% for bcm5701.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rope_cfg</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cfg_val</span><span class="p">;</span>

				<span class="n">rope_cfg</span> <span class="o">=</span> <span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_ROPE0_CFG</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
				<span class="n">cfg_val</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">rope_cfg</span><span class="p">);</span>
				<span class="n">cfg_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOC_ROPE_AO</span><span class="p">;</span>
				<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">cfg_val</span><span class="p">,</span> <span class="n">rope_cfg</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			** Make sure the box crashes on rope errors.</span>
<span class="cm">			*/</span>
			<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">HF_ENABLE</span><span class="p">,</span> <span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">ROPE0_CTL</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* flush out the last writes */</span>
		<span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">ROPE7_CTL</span><span class="p">);</span>

		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;	ioc[%d] ROPE_CFG 0x%Lx  ROPE_DBG 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span>
				<span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">),</span>
				<span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">)</span>
			<span class="p">);</span>
		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;	STATUS_CONTROL 0x%Lx  FLUSH_CTRL 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="mh">0x108</span><span class="p">),</span>
				<span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="mh">0x400</span><span class="p">)</span>
			<span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sba_ioc_init_pluto</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sba_ioc_init</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_common_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* add this one to the head of the list (order doesn&#39;t matter)</span>
<span class="cm">	** This will be useful for debugging - especially if we get coredumps</span>
<span class="cm">	*/</span>
	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sba_list</span><span class="p">;</span>
	<span class="n">sba_list</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">num_ioc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res_size</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DMB_TRAP</span>
		<span class="k">extern</span> <span class="kt">void</span> <span class="n">iterate_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">,</span>
					  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">);</span>
		<span class="kt">void</span> <span class="n">set_data_memory_break</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/* resource map size dictated by pdir_size */</span>
		<span class="n">res_size</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_size</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span> <span class="cm">/* entries */</span>

		<span class="cm">/* Second part of PIRANHA BUG */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piranha_bad_128k</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res_size</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">res_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* convert bit count to byte count */</span>
		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() res_size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">res_size</span><span class="p">);</span>

		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_size</span> <span class="o">=</span> <span class="n">res_size</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">res_size</span><span class="p">));</span>

<span class="cp">#ifdef DEBUG_DMB_TRAP</span>
		<span class="n">iterate_pages</span><span class="p">(</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">,</span> <span class="n">res_size</span><span class="p">,</span>
				<span class="n">set_data_memory_break</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s:%s() could not allocate resource map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res_size</span><span class="p">);</span>
		<span class="cm">/* next available IOVP - circular search */</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_hint</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">[</span><span class="n">L1_CACHE_BYTES</span><span class="p">]);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
		<span class="cm">/* Mark first bit busy - ie no IOVA 0 */</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xeeffc0addbba0080ULL</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="cm">/* Third (and last) part of PIRANHA BUG */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piranha_bad_128k</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* region from +1408K to +1536 is un-usable. */</span>

			<span class="kt">int</span> <span class="n">idx_start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1408</span><span class="o">*</span><span class="mi">1024</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">idx_end</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1536</span><span class="o">*</span><span class="mi">1024</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="kt">long</span> <span class="o">*</span><span class="n">p_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">[</span><span class="n">idx_start</span><span class="p">]);</span>
			<span class="kt">long</span> <span class="o">*</span><span class="n">p_end</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">[</span><span class="n">idx_end</span><span class="p">]);</span>

			<span class="cm">/* mark that part of the io pdir busy */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">p_start</span> <span class="o">&lt;</span> <span class="n">p_end</span><span class="p">)</span>
				<span class="o">*</span><span class="n">p_start</span><span class="o">++</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				
		<span class="p">}</span>

<span class="cp">#ifdef DEBUG_DMB_TRAP</span>
		<span class="n">iterate_pages</span><span class="p">(</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">,</span> <span class="n">res_size</span><span class="p">,</span>
				<span class="n">set_data_memory_break</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iterate_pages</span><span class="p">(</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_base</span><span class="p">,</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_size</span><span class="p">,</span>
				<span class="n">set_data_memory_break</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() %d res_map %x %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">res_size</span><span class="p">,</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_lock</span><span class="p">);</span>
	<span class="n">ioc_needs_fdc</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">pdc</span><span class="p">.</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">PDC_MODEL_IOPDIR_FDC</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the PDC_MODEL capabilities has Non-coherent IO-PDIR bit set</span>
<span class="cm">	 * (bit #61, big endian), we have to flush and sync every time</span>
<span class="cm">	 * IO-PDIR is changed in Ike/Astro.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_needs_fdc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">MODULE_NAME</span> <span class="s">&quot; FDC/SYNC required.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">MODULE_NAME</span> <span class="s">&quot; IOC has cache coherent PDIR.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span> <span class="o">=</span> <span class="n">sba_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* FIXME: Multi-IOC support! */</span>
	<span class="kt">int</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* 8 bits per byte */</span>
<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s rev %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">hw_rev</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">hw_rev</span> <span class="o">&amp;</span> <span class="mh">0x18</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
		<span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;IO PDIR size    : %d bytes (%d entries)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)),</span> <span class="cm">/* 8 bits/byte */</span>
		<span class="n">total_pages</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Resource bitmap : %d bytes (%d pages)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>   <span class="cm">/* 8 bits per byte */</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;LMMIO_BASE/MASK/ROUTE %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIST_BASE</span><span class="p">),</span>
		<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIST_MASK</span><span class="p">),</span>
		<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIST_ROUTE</span><span class="p">)</span>
		<span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DIR%d_BASE/MASK/ROUTE %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_BASE</span>  <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x18</span><span class="p">),</span>
			<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_MASK</span>  <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x18</span><span class="p">),</span>
			<span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_ROUTE</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x18</span><span class="p">)</span>
		<span class="p">);</span>

<span class="cp">#ifdef SBA_COLLECT_STATS</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;IO PDIR entries : %ld free  %ld used (%d%%)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">total_pages</span> <span class="o">-</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">used_pages</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">total_pages</span><span class="p">));</span>

	<span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SBA_SEARCH_SAMPLE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">avg</span> <span class="o">+=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="n">min</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">avg</span> <span class="o">/=</span> <span class="n">SBA_SEARCH_SAMPLE</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">min</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_map_single(): %12ld calls  %12ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msingle_calls</span><span class="p">));</span>

	<span class="cm">/* KLUGE - unmap_sg calls unmap_single for each mapped page */</span>
	<span class="n">min</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_calls</span><span class="p">;</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usingle_pages</span> <span class="o">-</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_unmap_single: %12ld calls  %12ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">max</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">min</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_map_sg()    : %12ld calls  %12ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_pages</span><span class="p">,</span> 
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">msg_calls</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pci_unmap_sg()  : %12ld calls  %12ld pages (avg %d/1000)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_pages</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">usg_calls</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sba_proc_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sba_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sba_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_proc_bitmap_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span> <span class="o">=</span> <span class="n">sba_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* FIXME: Multi-IOC support! */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">res_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %08x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_proc_bitmap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sba_proc_bitmap_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sba_proc_bitmap_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sba_proc_bitmap_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="n">sba_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">HPHW_IOA</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">ASTRO_RUNWAY_PORT</span><span class="p">,</span> <span class="mh">0xb</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_BCPORT</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">IKE_MERCED_PORT</span><span class="p">,</span> <span class="mh">0xc</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_BCPORT</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">REO_MERCED_PORT</span><span class="p">,</span> <span class="mh">0xc</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_BCPORT</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">REOG_MERCED_PORT</span><span class="p">,</span> <span class="mh">0xc</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">HPHW_IOA</span><span class="p">,</span> <span class="n">HVERSION_REV_ANY_ID</span><span class="p">,</span> <span class="n">PLUTO_MCKINLEY_PORT</span><span class="p">,</span> <span class="mh">0xc</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sba_driver_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_driver</span> <span class="n">sba_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="n">MODULE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">sba_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">sba_driver_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">** Determine if sba should claim this chip (return 0) or not (return 1).</span>
<span class="cm">** If so, initialize the chip and tell other partners in crime they</span>
<span class="cm">** have work to do.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_driver_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">func_class</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sba_addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">SBA_FUNC_SIZE</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">sba_dump_ranges</span><span class="p">(</span><span class="n">sba_addr</span><span class="p">);</span>

	<span class="cm">/* Read HW Rev First */</span>
	<span class="n">func_class</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_addr</span> <span class="o">+</span> <span class="n">SBA_FCLASS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ASTRO</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fclass</span><span class="p">;</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">astro_rev</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;Astro ?.?&quot;</span><span class="p">;</span>

		<span class="cm">/* Astro is broken...Read HW Rev First */</span>
		<span class="n">fclass</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">sba_addr</span><span class="p">);</span>

		<span class="n">astro_rev</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">fclass</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
		<span class="n">astro_rev</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">fclass</span> <span class="o">&amp;</span> <span class="mh">0x18</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">version</span> <span class="o">=</span> <span class="n">astro_rev</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_IKE</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">ike_rev</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Ike rev ?&quot;</span><span class="p">;</span>
		<span class="n">ike_rev</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">version</span> <span class="o">=</span> <span class="n">ike_rev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">pluto_rev</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;Pluto ?.?&quot;</span><span class="p">;</span>
		<span class="n">pluto_rev</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span> 
		<span class="n">pluto_rev</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span> 
		<span class="n">version</span> <span class="o">=</span> <span class="n">pluto_rev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">reo_rev</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;REO rev ?&quot;</span><span class="p">;</span>
		<span class="n">reo_rev</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">func_class</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">version</span> <span class="o">=</span> <span class="n">reo_rev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_ioc_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">global_ioc_cnt</span> <span class="o">=</span> <span class="n">count_parisc_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_driver</span><span class="p">);</span>

		<span class="cm">/* Astro and Pluto have one IOC per SBA */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">IS_ASTRO</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_PLUTO</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
			<span class="n">global_ioc_cnt</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s found %s at 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">MODULE_NAME</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>

	<span class="n">sba_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sba_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sba_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">MODULE_NAME</span> <span class="s">&quot; - couldn&#39;t alloc sba_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parisc_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sba_dev</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_IOC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_lock</span><span class="p">));</span>

	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">hw_rev</span> <span class="o">=</span> <span class="n">func_class</span><span class="p">;</span>
	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">=</span> <span class="n">sba_addr</span><span class="p">;</span>

	<span class="n">sba_get_pat_resources</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">);</span>
	<span class="n">sba_hw_init</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">);</span>
	<span class="n">sba_common_init</span><span class="p">(</span><span class="n">sba_dev</span><span class="p">);</span>

	<span class="n">hppa_dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sba_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PLUTO_MCKINLEY_PORT</span>:
		<span class="n">root</span> <span class="o">=</span> <span class="n">proc_mckinley_root</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASTRO_RUNWAY_PORT</span>:
	<span class="k">case</span> <span class="n">IKE_MERCED_PORT</span>:
	<span class="nl">default:</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">proc_runway_root</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;sba_iommu&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sba_proc_fops</span><span class="p">);</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;sba_iommu-bitmap&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sba_proc_bitmap_fops</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">parisc_has_iommu</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** One time initialization to let the world know the SBA was found.</span>
<span class="cm">** This is the only routine which is NOT static.</span>
<span class="cm">** Must be called exactly once before pci_init().</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sba_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_parisc_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_get_iommu - Assign the iommu pointer for the pci bus controller.</span>
<span class="cm"> * @dev: The parisc device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the appropriate IOMMU data for the given parisc PCI controller.</span>
<span class="cm"> * This is cached and used later for PCI DMA Mapping.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">sba_get_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pci_hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba_dev</span> <span class="o">=</span> <span class="n">parisc_parent</span><span class="p">(</span><span class="n">pci_hba</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iocnum</span> <span class="o">=</span> <span class="p">(</span><span class="n">pci_hba</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>	<span class="cm">/* rope # */</span>

	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">t</span> <span class="o">!=</span> <span class="n">HPHW_IOA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">HPHW_BCPORT</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sba</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">[</span><span class="n">iocnum</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_directed_lmmio - return first directed LMMIO range routed to rope</span>
<span class="cm"> * @pa_dev: The parisc device.</span>
<span class="cm"> * @r: resource PCI host controller wants start/end fields assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * For the given parisc PCI controller, determine if any direct ranges</span>
<span class="cm"> * are routed down the corresponding rope.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sba_directed_lmmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pci_hba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba_dev</span> <span class="o">=</span> <span class="n">parisc_parent</span><span class="p">(</span><span class="n">pci_hba</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rope</span> <span class="o">=</span> <span class="p">(</span><span class="n">pci_hba</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ROPES_PER_IOC</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>  <span class="cm">/* rope # */</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">t</span><span class="o">!=</span><span class="n">HPHW_IOA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">!=</span><span class="n">HPHW_BCPORT</span><span class="p">));</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Astro has 4 directed ranges. Not sure about Ike/Pluto/et al */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">sba</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x18</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">reg</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_BASE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* not enabled */</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">reg</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_ROUTE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ROPES_PER_IOC</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">rope</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* directed down different rope */</span>
		
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1UL</span><span class="p">)</span> <span class="o">|</span> <span class="n">PCI_F_EXTEND</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="o">~</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">reg</span> <span class="o">+</span> <span class="n">LMMIO_DIRECT0_MASK</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_distributed_lmmio - return portion of distributed LMMIO range</span>
<span class="cm"> * @pa_dev: The parisc device.</span>
<span class="cm"> * @r: resource PCI host controller wants start/end fields assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * For the given parisc PCI controller, return portion of distributed LMMIO</span>
<span class="cm"> * range. The distributed LMMIO is always present and it&#39;s just a question</span>
<span class="cm"> * of the base address and size of the range.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sba_distributed_lmmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pci_hba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">sba_dev</span> <span class="o">=</span> <span class="n">parisc_parent</span><span class="p">(</span><span class="n">pci_hba</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sba_device</span> <span class="o">*</span><span class="n">sba</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sba_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rope</span> <span class="o">=</span> <span class="p">(</span><span class="n">pci_hba</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ROPES_PER_IOC</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>  <span class="cm">/* rope # */</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">t</span><span class="o">!=</span><span class="n">HPHW_IOA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">!=</span><span class="n">HPHW_BCPORT</span><span class="p">));</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIST_BASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>	<span class="cm">/* Gah! Distr Range wasn&#39;t enabled! */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1UL</span><span class="p">)</span> <span class="o">|</span> <span class="n">PCI_F_EXTEND</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">READ_REG32</span><span class="p">(</span><span class="n">sba</span><span class="o">-&gt;</span><span class="n">sba_hpa</span> <span class="o">+</span> <span class="n">LMMIO_DIST_MASK</span><span class="p">))</span> <span class="o">/</span> <span class="n">ROPES_PER_IOC</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+=</span> <span class="n">rope</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* adjust base for this rope */</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
