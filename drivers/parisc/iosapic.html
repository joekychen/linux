<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parisc › iosapic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>iosapic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** I/O Sapic Driver - PCI interrupt line support</span>
<span class="cm">**</span>
<span class="cm">**      (c) Copyright 1999 Grant Grundler</span>
<span class="cm">**      (c) Copyright 1999 Hewlett-Packard Company</span>
<span class="cm">**</span>
<span class="cm">**      This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**      it under the terms of the GNU General Public License as published by</span>
<span class="cm">**      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**      (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">** The I/O sapic driver manages the Interrupt Redirection Table which is</span>
<span class="cm">** the control logic to convert PCI line based interrupts into a Message</span>
<span class="cm">** Signaled Interrupt (aka Transaction Based Interrupt, TBI).</span>
<span class="cm">**</span>
<span class="cm">** Acronyms</span>
<span class="cm">** --------</span>
<span class="cm">** HPA  Hard Physical Address (aka MMIO address)</span>
<span class="cm">** IRQ  Interrupt ReQuest. Implies Line based interrupt.</span>
<span class="cm">** IRT	Interrupt Routing Table (provided by PAT firmware)</span>
<span class="cm">** IRdT Interrupt Redirection Table. IRQ line to TXN ADDR/DATA</span>
<span class="cm">**      table which is implemented in I/O SAPIC.</span>
<span class="cm">** ISR  Interrupt Service Routine. aka Interrupt handler.</span>
<span class="cm">** MSI	Message Signaled Interrupt. PCI 2.2 functionality.</span>
<span class="cm">**      aka Transaction Based Interrupt (or TBI).</span>
<span class="cm">** PA   Precision Architecture. HP&#39;s RISC architecture.</span>
<span class="cm">** RISC Reduced Instruction Set Computer.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** What&#39;s a Message Signalled Interrupt?</span>
<span class="cm">** -------------------------------------</span>
<span class="cm">** MSI is a write transaction which targets a processor and is similar</span>
<span class="cm">** to a processor write to memory or MMIO. MSIs can be generated by I/O</span>
<span class="cm">** devices as well as processors and require *architecture* to work.</span>
<span class="cm">**</span>
<span class="cm">** PA only supports MSI. So I/O subsystems must either natively generate</span>
<span class="cm">** MSIs (e.g. GSC or HP-PB) or convert line based interrupts into MSIs</span>
<span class="cm">** (e.g. PCI and EISA).  IA64 supports MSIs via a &quot;local SAPIC&quot; which</span>
<span class="cm">** acts on behalf of a processor.</span>
<span class="cm">**</span>
<span class="cm">** MSI allows any I/O device to interrupt any processor. This makes</span>
<span class="cm">** load balancing of the interrupt processing possible on an SMP platform.</span>
<span class="cm">** Interrupts are also ordered WRT to DMA data.  It&#39;s possible on I/O</span>
<span class="cm">** coherent systems to completely eliminate PIO reads from the interrupt</span>
<span class="cm">** path. The device and driver must be designed and implemented to</span>
<span class="cm">** guarantee all DMA has been issued (issues about atomicity here)</span>
<span class="cm">** before the MSI is issued. I/O status can then safely be read from</span>
<span class="cm">** DMA&#39;d data by the ISR.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** PA Firmware</span>
<span class="cm">** -----------</span>
<span class="cm">** PA-RISC platforms have two fundamentally different types of firmware.</span>
<span class="cm">** For PCI devices, &quot;Legacy&quot; PDC initializes the &quot;INTERRUPT_LINE&quot; register</span>
<span class="cm">** and BARs similar to a traditional PC BIOS.</span>
<span class="cm">** The newer &quot;PAT&quot; firmware supports PDC calls which return tables.</span>
<span class="cm">** PAT firmware only initializes the PCI Console and Boot interface.</span>
<span class="cm">** With these tables, the OS can program all other PCI devices.</span>
<span class="cm">**</span>
<span class="cm">** One such PAT PDC call returns the &quot;Interrupt Routing Table&quot; (IRT).</span>
<span class="cm">** The IRT maps each PCI slot&#39;s INTA-D &quot;output&quot; line to an I/O SAPIC</span>
<span class="cm">** input line.  If the IRT is not available, this driver assumes</span>
<span class="cm">** INTERRUPT_LINE register has been programmed by firmware. The latter</span>
<span class="cm">** case also means online addition of PCI cards can NOT be supported</span>
<span class="cm">** even if HW support is present.</span>
<span class="cm">**</span>
<span class="cm">** All platforms with PAT firmware to date (Oct 1999) use one Interrupt</span>
<span class="cm">** Routing Table for the entire platform.</span>
<span class="cm">**</span>
<span class="cm">** Where&#39;s the iosapic?</span>
<span class="cm">** --------------------</span>
<span class="cm">** I/O sapic is part of the &quot;Core Electronics Complex&quot;. And on HP platforms</span>
<span class="cm">** it&#39;s integrated as part of the PCI bus adapter, &quot;lba&quot;.  So no bus walk</span>
<span class="cm">** will discover I/O Sapic. I/O Sapic driver learns about each device</span>
<span class="cm">** when lba driver advertises the presence of the I/O sapic by calling</span>
<span class="cm">** iosapic_register().</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** IRQ handling notes</span>
<span class="cm">** ------------------</span>
<span class="cm">** The IO-SAPIC can indicate to the CPU which interrupt was asserted.</span>
<span class="cm">** So, unlike the GSC-ASIC and Dino, we allocate one CPU interrupt per</span>
<span class="cm">** IO-SAPIC interrupt and call the device driver&#39;s handler directly.</span>
<span class="cm">** The IO-SAPIC driver hijacks the CPU interrupt handler so it can</span>
<span class="cm">** issue the End Of Interrupt command to the IO-SAPIC.</span>
<span class="cm">**</span>
<span class="cm">** Overview of exported iosapic functions</span>
<span class="cm">** --------------------------------------</span>
<span class="cm">** (caveat: code isn&#39;t finished yet - this is just the plan)</span>
<span class="cm">**</span>
<span class="cm">** iosapic_init:</span>
<span class="cm">**   o initialize globals (lock, etc)</span>
<span class="cm">**   o try to read IRT. Presence of IRT determines if this is</span>
<span class="cm">**     a PAT platform or not.</span>
<span class="cm">**</span>
<span class="cm">** iosapic_register():</span>
<span class="cm">**   o create iosapic_info instance data structure</span>
<span class="cm">**   o allocate vector_info array for this iosapic</span>
<span class="cm">**   o initialize vector_info - read corresponding IRdT?</span>
<span class="cm">**</span>
<span class="cm">** iosapic_xlate_pin: (only called by fixup_irq for PAT platform)</span>
<span class="cm">**   o intr_pin = read cfg (INTERRUPT_PIN);</span>
<span class="cm">**   o if (device under PCI-PCI bridge)</span>
<span class="cm">**               translate slot/pin</span>
<span class="cm">**</span>
<span class="cm">** iosapic_fixup_irq:</span>
<span class="cm">**   o if PAT platform (IRT present)</span>
<span class="cm">**	   intr_pin = iosapic_xlate_pin(isi,pcidev):</span>
<span class="cm">**         intr_line = find IRT entry(isi, PCI_SLOT(pcidev), intr_pin)</span>
<span class="cm">**         save IRT entry into vector_info later</span>
<span class="cm">**         write cfg INTERRUPT_LINE (with intr_line)?</span>
<span class="cm">**     else</span>
<span class="cm">**         intr_line = pcidev-&gt;irq</span>
<span class="cm">**         IRT pointer = NULL</span>
<span class="cm">**     endif</span>
<span class="cm">**   o locate vector_info (needs: isi, intr_line)</span>
<span class="cm">**   o allocate processor &quot;irq&quot; and get txn_addr/data</span>
<span class="cm">**   o request_irq(processor_irq,  iosapic_interrupt, vector_info,...)</span>
<span class="cm">**</span>
<span class="cm">** iosapic_enable_irq:</span>
<span class="cm">**   o clear any pending IRQ on that line</span>
<span class="cm">**   o enable IRdT - call enable_irq(vector[line]-&gt;processor_irq)</span>
<span class="cm">**   o write EOI in case line is already asserted.</span>
<span class="cm">**</span>
<span class="cm">** iosapic_disable_irq:</span>
<span class="cm">**   o disable IRdT - call disable_irq(vector[line]-&gt;processor_irq)</span>
<span class="cm">*/</span>


<span class="cm">/* FIXME: determine which include files are really needed */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;	</span><span class="cm">/* get in-line asm for swab */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/pdcpat.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;		</span><span class="cm">/* read/write functions */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SUPERIO</span>
<span class="cp">#include &lt;asm/superio.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/ropes.h&gt;</span>
<span class="cp">#include &quot;./iosapic_private.h&quot;</span>

<span class="cp">#define MODULE_NAME &quot;iosapic&quot;</span>

<span class="cm">/* &quot;local&quot; compile flags */</span>
<span class="cp">#undef PCI_BRIDGE_FUNCS</span>
<span class="cp">#undef DEBUG_IOSAPIC</span>
<span class="cp">#undef DEBUG_IOSAPIC_IRT</span>


<span class="cp">#ifdef DEBUG_IOSAPIC</span>
<span class="cp">#define DBG(x...) printk(x)</span>
<span class="cp">#else </span><span class="cm">/* DEBUG_IOSAPIC */</span><span class="cp"></span>
<span class="cp">#define DBG(x...)</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_IOSAPIC */</span><span class="cp"></span>

<span class="cp">#ifdef DEBUG_IOSAPIC_IRT</span>
<span class="cp">#define DBG_IRT(x...) printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_IRT(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define COMPARE_IRTE_ADDR(irte, hpa)	((irte)-&gt;dest_iosapic_addr == (hpa))</span>
<span class="cp">#else</span>
<span class="cp">#define COMPARE_IRTE_ADDR(irte, hpa)	\</span>
<span class="cp">		((irte)-&gt;dest_iosapic_addr == ((hpa) | 0xffffffff00000000ULL))</span>
<span class="cp">#endif</span>

<span class="cp">#define IOSAPIC_REG_SELECT              0x00</span>
<span class="cp">#define IOSAPIC_REG_WINDOW              0x10</span>
<span class="cp">#define IOSAPIC_REG_EOI                 0x40</span>

<span class="cp">#define IOSAPIC_REG_VERSION		0x1</span>

<span class="cp">#define IOSAPIC_IRDT_ENTRY(idx)		(0x10+(idx)*2)</span>
<span class="cp">#define IOSAPIC_IRDT_ENTRY_HI(idx)	(0x11+(idx)*2)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">iosapic_read</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">iosapic</span> <span class="o">+</span> <span class="n">IOSAPIC_REG_SELECT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">iosapic</span> <span class="o">+</span> <span class="n">IOSAPIC_REG_WINDOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iosapic_write</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">iosapic</span> <span class="o">+</span> <span class="n">IOSAPIC_REG_SELECT</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">iosapic</span> <span class="o">+</span> <span class="n">IOSAPIC_REG_WINDOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define IOSAPIC_VERSION_MASK	0x000000ff</span>
<span class="cp">#define	IOSAPIC_VERSION(ver)	((int) (ver &amp; IOSAPIC_VERSION_MASK))</span>

<span class="cp">#define IOSAPIC_MAX_ENTRY_MASK          0x00ff0000</span>
<span class="cp">#define IOSAPIC_MAX_ENTRY_SHIFT         0x10</span>
<span class="cp">#define	IOSAPIC_IRDT_MAX_ENTRY(ver)	\</span>
<span class="cp">	(int) (((ver) &amp; IOSAPIC_MAX_ENTRY_MASK) &gt;&gt; IOSAPIC_MAX_ENTRY_SHIFT)</span>

<span class="cm">/* bits in the &quot;low&quot; I/O Sapic IRdT entry */</span>
<span class="cp">#define IOSAPIC_IRDT_ENABLE       0x10000</span>
<span class="cp">#define IOSAPIC_IRDT_PO_LOW       0x02000</span>
<span class="cp">#define IOSAPIC_IRDT_LEVEL_TRIG   0x08000</span>
<span class="cp">#define IOSAPIC_IRDT_MODE_LPRI    0x00100</span>

<span class="cm">/* bits in the &quot;high&quot; I/O Sapic IRdT entry */</span>
<span class="cp">#define IOSAPIC_IRDT_ID_EID_SHIFT              0x10</span>


<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">iosapic_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iosapic_eoi</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** REVISIT: future platforms may have more than one IRT.</span>
<span class="cm">** If so, the following three fields form a structure which</span>
<span class="cm">** then be linked into a list. Names are chosen to make searching</span>
<span class="cm">** for them easy - not necessarily accurate (eg &quot;cell&quot;).</span>
<span class="cm">**</span>
<span class="cm">** Alternative: iosapic_info could point to the IRT it&#39;s in.</span>
<span class="cm">** iosapic_register() could search a list of IRT&#39;s.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">irt_cell</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">irt_num_entry</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="nf">iosapic_alloc_irt</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">;</span>

	<span class="cm">/* The IRT needs to be 8-byte aligned for the PDC call. </span>
<span class="cm">	 * Normally kmalloc would guarantee larger alignment, but</span>
<span class="cm">	 * if CONFIG_DEBUG_SLAB is enabled, then we can get only</span>
<span class="cm">	 * 4-byte alignment on 32-bit kernels</span>
<span class="cm">	 */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irt_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_entries</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">7UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7UL</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iosapic_load_irt - Fill in the interrupt routing table</span>
<span class="cm"> * @cell_num: The cell number of the CPU we&#39;re currently executing on</span>
<span class="cm"> * @irt: The address to place the new IRT at</span>
<span class="cm"> * @return The number of entries found</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;Get PCI INT Routing Table Size&quot; option returns the number of </span>
<span class="cm"> * entries in the PCI interrupt routing table for the cell specified </span>
<span class="cm"> * in the cell_number argument.  The cell number must be for a cell </span>
<span class="cm"> * within the caller&#39;s protection domain.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;Get PCI INT Routing Table&quot; option returns, for the cell </span>
<span class="cm"> * specified in the cell_number argument, the PCI interrupt routing </span>
<span class="cm"> * table in the caller allocated memory pointed to by mem_addr.</span>
<span class="cm"> * We assume the IRT only contains entries for I/O SAPIC and</span>
<span class="cm"> * calculate the size based on the size of I/O sapic entries.</span>
<span class="cm"> *</span>
<span class="cm"> * The PCI interrupt routing table entry format is derived from the</span>
<span class="cm"> * IA64 SAL Specification 2.4.   The PCI interrupt routing table defines</span>
<span class="cm"> * the routing of PCI interrupt signals between the PCI device output</span>
<span class="cm"> * &quot;pins&quot; and the IO SAPICs&#39; input &quot;lines&quot; (including core I/O PCI</span>
<span class="cm"> * devices).  This table does NOT include information for devices/slots</span>
<span class="cm"> * behind PCI to PCI bridges. See PCI to PCI Bridge Architecture Spec.</span>
<span class="cm"> * for the architected method of routing of IRQ&#39;s behind PPB&#39;s.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">iosapic_load_irt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cell_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">**</span><span class="n">irt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>              <span class="cm">/* PDC return value status */</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>  <span class="cm">/* start of interrupt routing tbl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_entries</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* Use pat pdc routine to get interrupt routing table size */</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;calling get_irt_size (cell %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_get_irt_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_entries</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;get_irt_size: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		** allocate memory for interrupt routing table</span>
<span class="cm">		** This interface isn&#39;t really right. We are assuming</span>
<span class="cm">		** the contents of the table are exclusively</span>
<span class="cm">		** for I/O sapic devices.</span>
<span class="cm">		*/</span>
		<span class="n">table</span> <span class="o">=</span> <span class="n">iosapic_alloc_irt</span><span class="p">(</span><span class="n">num_entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: read_irt : can &quot;</span>
					<span class="s">&quot;not alloc mem for IRT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get PCI INT routing table */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_get_irt</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;pdc_pat_get_irt: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** C3000/J5000 (and similar) platforms with Sprockets PDC</span>
<span class="cm">		** will return exactly one IRT for all iosapics.</span>
<span class="cm">		** So if we have one, don&#39;t need to get it again.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irt_cell</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Should be using the Elroy&#39;s HPA, but it&#39;s ignored anyway */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pci_irt_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;pdc_pci_irt_size: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Not a &quot;legacy&quot; system with I/O SAPIC either */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">table</span> <span class="o">=</span> <span class="n">iosapic_alloc_irt</span><span class="p">(</span><span class="n">num_entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: read_irt : can &quot;</span>
					<span class="s">&quot;not alloc mem for IRT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* HPA ignored by this call too. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pci_irt</span><span class="p">(</span><span class="n">num_entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* return interrupt table address */</span>
	<span class="o">*</span><span class="n">irt</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_IOSAPIC_IRT</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">MODULE_NAME</span> <span class="s">&quot; Interrupt Routing Table (cell %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">MODULE_NAME</span> <span class="s">&quot; start = 0x%p num_entries %ld entry_size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">table</span><span class="p">,</span>
		<span class="n">num_entries</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irt_entry</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_entries</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">MODULE_NAME</span> <span class="s">&quot; %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">entry_type</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">entry_length</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">interrupt_type</span><span class="p">,</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">polarity_trigger</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">src_bus_irq_devno</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">src_bus_id</span><span class="p">,</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">src_seg_id</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">dest_iosapic_intin</span><span class="p">,</span>
		<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span>
		<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_IOSAPIC_IRT */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">num_entries</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="n">__init</span> <span class="nf">iosapic_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;iosapic_init()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef __LP64__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pdc_pat_cell_num</span> <span class="n">cell_info</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_cell_get_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cell</span> <span class="o">=</span> <span class="n">cell_info</span><span class="p">.</span><span class="n">cell_num</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* get interrupt routing table for this cell */</span>
	<span class="n">irt_num_entry</span> <span class="o">=</span> <span class="n">iosapic_load_irt</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irt_cell</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irt_num_entry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">irt_cell</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* old PDC w/o iosapic */</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** Return the IRT entry in case we need to look something else up.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span>
<span class="nf">irt_find_irqline</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span><span class="p">,</span> <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">intr_pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">irt_cell</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>	<span class="cm">/* track how many entries we&#39;ve looked at */</span>
	<span class="n">u8</span> <span class="n">irq_devno</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;&lt;</span> <span class="n">IRT_DEV_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">intr_pin</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;irt_find_irqline() SLOT %d pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">intr_pin</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">irt_num_entry</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		** Validate: entry_type, entry_length, interrupt_type</span>
<span class="cm">		**</span>
<span class="cm">		** Difference between validate vs compare is the former</span>
<span class="cm">		** should print debug info and is not expected to &quot;fail&quot;</span>
<span class="cm">		** on current platforms.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">entry_type</span> <span class="o">!=</span> <span class="n">IRT_IOSAPIC_TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG_IRT</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;:find_irqline(0x%p): skipping entry %d type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">entry_type</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">entry_length</span> <span class="o">!=</span> <span class="n">IRT_IOSAPIC_LENGTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG_IRT</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;:find_irqline(0x%p): skipping entry %d  length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">entry_length</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">interrupt_type</span> <span class="o">!=</span> <span class="n">IRT_VECTORED_INTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG_IRT</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;:find_irqline(0x%p): skipping entry  %d interrupt_type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">interrupt_type</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">COMPARE_IRTE_ADDR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_hpa</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">src_bus_irq_devno</span> <span class="o">&amp;</span> <span class="n">IRT_IRQ_DEVNO_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">irq_devno</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		** Ignore: src_bus_id and rc_seg_id correlate with</span>
<span class="cm">		**         iosapic_info-&gt;isi_hpa on HP platforms.</span>
<span class="cm">		**         If needed, pass in &quot;PFA&quot; (aka config space addr)</span>
<span class="cm">		**         instead of slot.</span>
<span class="cm">		*/</span>

		<span class="cm">/* Found it! */</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: 0x%lx : no IRT entry for slot %d, pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_hpa</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">intr_pin</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** xlate_pin() supports the skewing of IRQ lines done by subsidiary bridges.</span>
<span class="cm">** Legacy PDC already does this translation for us and stores it in INTR_LINE.</span>
<span class="cm">**</span>
<span class="cm">** PAT PDC needs to basically do what legacy PDC does:</span>
<span class="cm">** o read PIN</span>
<span class="cm">** o adjust PIN in case device is &quot;behind&quot; a PPB</span>
<span class="cm">**     (eg 4-port 100BT and SCSI/LAN &quot;Combo Card&quot;)</span>
<span class="cm">** o convert slot/pin to I/O SAPIC input line.</span>
<span class="cm">**</span>
<span class="cm">** HP platforms only support:</span>
<span class="cm">** o one level of skewing for any number of PPBs</span>
<span class="cm">** o only support PCI-PCI Bridges.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span>
<span class="nf">iosapic_xlate_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">intr_pin</span><span class="p">,</span> <span class="n">intr_slot</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_PIN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intr_pin</span><span class="p">);</span>

	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_xlate_pin(%s) SLOT %d pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">slot_name</span><span class="p">,</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">intr_pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_pin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The device does NOT support/use IRQ lines.  */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if pcidev behind a PPB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Convert pcidev INTR_PIN into something we</span>
<span class="cm">		** can lookup in the IRT.</span>
<span class="cm">		*/</span>
<span class="cp">#ifdef PCI_BRIDGE_FUNCS</span>
		<span class="cm">/*</span>
<span class="cm">		** Proposal #1:</span>
<span class="cm">		**</span>
<span class="cm">		** call implementation specific translation function</span>
<span class="cm">		** This is architecturally &quot;cleaner&quot;. HP-UX doesn&#39;t</span>
<span class="cm">		** support other secondary bus types (eg. E/ISA) directly.</span>
<span class="cm">		** May be needed for other processor (eg IA64) architectures</span>
<span class="cm">		** or by some ambitous soul who wants to watch TV.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_bridge_funcs</span><span class="o">-&gt;</span><span class="n">xlate_intr_line</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr_pin</span> <span class="o">=</span> <span class="n">pci_bridge_funcs</span><span class="o">-&gt;</span><span class="n">xlate_intr_line</span><span class="p">(</span><span class="n">pcidev</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* PCI_BRIDGE_FUNCS */</span><span class="cp"></span>
		<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		** Proposal #2:</span>
<span class="cm">		** The &quot;pin&quot; is skewed ((pin + dev - 1) % 4).</span>
<span class="cm">		**</span>
<span class="cm">		** This isn&#39;t very clean since I/O SAPIC must assume:</span>
<span class="cm">		**   - all platforms only have PCI busses.</span>
<span class="cm">		**   - only PCI-PCI bridge (eg not PCI-EISA, PCI-PCMCIA)</span>
<span class="cm">		**   - IRQ routing is only skewed once regardless of</span>
<span class="cm">		**     the number of PPB&#39;s between iosapic and device.</span>
<span class="cm">		**     (Bit3 expansion chassis follows this rule)</span>
<span class="cm">		**</span>
<span class="cm">		** Advantage is it&#39;s really easy to implement.</span>
<span class="cm">		*/</span>
		<span class="n">intr_pin</span> <span class="o">=</span> <span class="n">pci_swizzle_interrupt_pin</span><span class="p">(</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">intr_pin</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PCI_BRIDGE_FUNCS */</span><span class="cp"></span>

		<span class="cm">/*</span>
<span class="cm">		 * Locate the host slot of the PPB.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

		<span class="n">intr_slot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">intr_slot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_xlate_pin:  bus %d slot %d pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">secondary</span><span class="p">,</span> <span class="n">intr_slot</span><span class="p">,</span> <span class="n">intr_pin</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irt_find_irqline</span><span class="p">(</span><span class="n">isi</span><span class="p">,</span> <span class="n">intr_slot</span><span class="p">,</span> <span class="n">intr_pin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iosapic_rd_irt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span> <span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dp0</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dp1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">irqline</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dp0</span> <span class="o">=</span> <span class="n">iosapic_read</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_IRDT_ENTRY</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
	<span class="o">*</span><span class="n">dp1</span> <span class="o">=</span> <span class="n">iosapic_read</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_IRDT_ENTRY_HI</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">iosapic_wr_irt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dp0</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dp1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">;</span>

	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_wr_irt_entry(): irq %d hpa %lx 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">irqline</span><span class="p">,</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">isi_hpa</span><span class="p">,</span> <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span><span class="p">);</span>

	<span class="n">iosapic_write</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_IRDT_ENTRY</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">irqline</span><span class="p">),</span> <span class="n">dp0</span><span class="p">);</span>

	<span class="cm">/* Read the window register to flush the writes down to HW  */</span>
	<span class="n">dp0</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">+</span><span class="n">IOSAPIC_REG_WINDOW</span><span class="p">);</span>

	<span class="n">iosapic_write</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_IRDT_ENTRY_HI</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">irqline</span><span class="p">),</span> <span class="n">dp1</span><span class="p">);</span>

	<span class="cm">/* Read the window register to flush the writes down to HW  */</span>
	<span class="n">dp1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">+</span><span class="n">IOSAPIC_REG_WINDOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** set_irt prepares the data (dp0, dp1) according to the vector_info</span>
<span class="cm">** and target cpu (id_eid).  dp0/dp1 are then used to program I/O SAPIC</span>
<span class="cm">** IRdT for the given &quot;vector&quot; (aka IRQ line).</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_set_irt_data</span><span class="p">(</span> <span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dp0</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dp1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">irte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">polarity_trigger</span> <span class="o">&amp;</span> <span class="n">IRT_PO_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRT_ACTIVE_LO</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">IOSAPIC_IRDT_PO_LOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">polarity_trigger</span> <span class="o">&gt;&gt;</span> <span class="n">IRT_EL_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRT_EL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRT_LEVEL_TRIG</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">IOSAPIC_IRDT_LEVEL_TRIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** IA64 REVISIT</span>
<span class="cm">	** PA doesn&#39;t support EXTINT or LPRIO bits.</span>
<span class="cm">	*/</span>

	<span class="o">*</span><span class="n">dp0</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** Extracting id_eid isn&#39;t a real clean way of getting it.</span>
<span class="cm">	** But the encoding is the same for both PA and IA64 platforms.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pdc_pat</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** PAT PDC just hands it to us &quot;right&quot;.</span>
<span class="cm">		** txn_addr comes from cpu_data[x].txn_addr.</span>
<span class="cm">		*/</span>
		<span class="o">*</span><span class="n">dp1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* </span>
<span class="cm">		** eg if base_addr == 0xfffa0000),</span>
<span class="cm">		**    we want to get 0xa0ff0000.</span>
<span class="cm">		**</span>
<span class="cm">		** eid	0x0ff00000 -&gt; 0x00ff0000</span>
<span class="cm">		** id	0x000ff000 -&gt; 0xff000000</span>
<span class="cm">		*/</span>
		<span class="o">*</span><span class="n">dp1</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span> <span class="o">&amp;</span> <span class="mh">0x0ff00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span> <span class="o">&amp;</span> <span class="mh">0x000ff000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_set_irt_data(): 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">dp0</span><span class="p">,</span> <span class="o">*</span><span class="n">dp1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">iosapic_mask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iosapic_rd_irt_entry</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
	<span class="n">d0</span> <span class="o">|=</span> <span class="n">IOSAPIC_IRDT_ENABLE</span><span class="p">;</span>
	<span class="n">iosapic_wr_irt_entry</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iosapic_unmask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">;</span>

	<span class="cm">/* data is initialized by fixup_irq */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">iosapic_set_irt_data</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
	<span class="n">iosapic_wr_irt_entry</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_IOSAPIC_IRT</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffUL</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iosapic_enable_irq(): regs %p&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iosapic_enable_irq(): sel &quot;</span><span class="p">);</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">d0</span><span class="o">=</span><span class="mh">0x10</span><span class="p">;</span> <span class="n">d0</span><span class="o">&lt;</span><span class="mh">0x1e</span><span class="p">;</span> <span class="n">d0</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d1</span> <span class="o">=</span> <span class="n">iosapic_read</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">d0</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issuing I/O SAPIC an EOI causes an interrupt IFF IRQ line is</span>
<span class="cm">	 * asserted.  IRQ generally should not be asserted when a driver</span>
<span class="cm">	 * enables their IRQ. It can lead to &quot;interesting&quot; race conditions</span>
<span class="cm">	 * in the driver initialization sequence.</span>
<span class="cm">	 */</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;enable_irq(%d): eoi(%p, 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_data</span><span class="p">);</span>
	<span class="n">iosapic_eoi</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iosapic_eoi_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

	<span class="n">iosapic_eoi</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_data</span><span class="p">);</span>
	<span class="n">cpu_eoi_irq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iosapic_set_affinity_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">dummy_d0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>

	<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">cpu_check_affinity</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_cpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">));</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span> <span class="o">=</span> <span class="n">txn_affinity_addr</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* d1 contains the destination CPU, so only want to set that</span>
<span class="cm">	 * entry */</span>
	<span class="n">iosapic_rd_irt_entry</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
	<span class="n">iosapic_set_irt_data</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy_d0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
	<span class="n">iosapic_wr_irt_entry</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">iosapic_interrupt_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span>	<span class="s">&quot;IO-SAPIC-level&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span>	<span class="n">iosapic_unmask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span>	<span class="n">iosapic_mask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>	<span class="o">=</span>	<span class="n">cpu_ack_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_eoi</span>	<span class="o">=</span>	<span class="n">iosapic_eoi_irq</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span> <span class="o">=</span>	<span class="n">iosapic_set_affinity_irq</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">iosapic_fixup_irq</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">isi_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span> <span class="o">=</span> <span class="n">isi_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">irte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* only used if PAT PDC */</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isi_line</span><span class="p">;</span>	<span class="cm">/* line used by device */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: hpa not registered for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pcidev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SUPERIO</span>
	<span class="cm">/*</span>
<span class="cm">	 * HACK ALERT! (non-compliant PCI device support)</span>
<span class="cm">	 *</span>
<span class="cm">	 * All SuckyIO interrupts are routed through the PIC&#39;s on function 1.</span>
<span class="cm">	 * But SuckyIO OHCI USB controller gets an IRT entry anyway because</span>
<span class="cm">	 * it advertises INT D for INT_PIN.  Use that IRT entry to get the</span>
<span class="cm">	 * SuckyIO interrupt routing for PICs on function 1 (*BLEECCHH*).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_superio_device</span><span class="p">(</span><span class="n">pcidev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We must call superio_fixup_irq() to register the pdev */</span>
		<span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">superio_fixup_irq</span><span class="p">(</span><span class="n">pcidev</span><span class="p">);</span>

		<span class="cm">/* Don&#39;t return if need to program the IOSAPIC&#39;s IRT... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SUPERIO_USB_FN</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUPERIO */</span><span class="cp"></span>

	<span class="cm">/* lookup IRT entry for isi/slot/pin set */</span>
	<span class="n">irte</span> <span class="o">=</span> <span class="n">iosapic_xlate_pin</span><span class="p">(</span><span class="n">isi</span><span class="p">,</span> <span class="n">pcidev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iosapic: no IRTE for %s (IRQ not connected?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">pcidev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">irte</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">entry_type</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">entry_length</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">polarity_trigger</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">src_bus_irq_devno</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">src_bus_id</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">src_seg_id</span><span class="p">,</span>
		<span class="n">irte</span><span class="o">-&gt;</span><span class="n">dest_iosapic_intin</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">irte</span><span class="o">-&gt;</span><span class="n">dest_iosapic_addr</span><span class="p">);</span>
	<span class="n">isi_line</span> <span class="o">=</span> <span class="n">irte</span><span class="o">-&gt;</span><span class="n">dest_iosapic_intin</span><span class="p">;</span>

	<span class="cm">/* get vector info for this input line */</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_vector</span> <span class="o">+</span> <span class="n">isi_line</span><span class="p">;</span>
	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_fixup_irq:  line %d vi 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi_line</span><span class="p">,</span> <span class="n">vi</span><span class="p">);</span>

	<span class="cm">/* If this IRQ line has already been setup, skip it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">irte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">irte</span> <span class="o">=</span> <span class="n">irte</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate processor IRQ</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX/FIXME The txn_alloc_irq() code and related code should be</span>
<span class="cm">	 * moved to enable_irq(). That way we only allocate processor IRQ</span>
<span class="cm">	 * bits for devices that actually have drivers claiming them.</span>
<span class="cm">	 * Right now we assign an IRQ to every PCI device present,</span>
<span class="cm">	 * regardless of whether it&#39;s used or not.</span>
<span class="cm">	 */</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span> <span class="o">=</span> <span class="n">txn_alloc_irq</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;I/O sapic: couldn&#39;t get TXN IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* enable_irq() will use txn_* to program IRdT */</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span> <span class="o">=</span> <span class="n">txn_alloc_addr</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span><span class="p">);</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_data</span> <span class="o">=</span> <span class="n">txn_alloc_data</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span><span class="p">);</span>

	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span> <span class="o">=</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">IOSAPIC_REG_EOI</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_data</span><span class="p">);</span>

	<span class="n">cpu_claim_irq</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_interrupt_type</span><span class="p">,</span> <span class="n">vi</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span><span class="p">;</span>

	<span class="n">DBG_IRT</span><span class="p">(</span><span class="s">&quot;iosapic_fixup_irq() %d:%d %x %x line %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span>
		<span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">isi_line</span><span class="p">,</span> <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** squirrel away the I/O Sapic Version</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">iosapic_rd_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iosapic_read</span><span class="p">(</span><span class="n">isi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_REG_VERSION</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** iosapic_register() is called by &quot;drivers&quot; with an integrated I/O SAPIC.</span>
<span class="cm">** Caller must be certain they have an I/O SAPIC and know its MMIO address.</span>
<span class="cm">**</span>
<span class="cm">**	o allocate iosapic_info and add it to the list</span>
<span class="cm">**	o read iosapic version and squirrel that away</span>
<span class="cm">**	o read size of IRdT.</span>
<span class="cm">**	o allocate and initialize isi_vector[]</span>
<span class="cm">**	o allocate irq region</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">iosapic_register</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irt_entry</span> <span class="o">*</span><span class="n">irte</span> <span class="o">=</span> <span class="n">irt_cell</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>	<span class="cm">/* track how many entries we&#39;ve looked at */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Astro based platforms can only support PCI OLARD if they implement</span>
<span class="cm">	 * PAT PDC.  Legacy PDC omits LBAs with no PCI devices from the IRT.</span>
<span class="cm">	 * Search the IRT and ignore iosapic&#39;s which aren&#39;t in the IRT.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">irt_num_entry</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">,</span> <span class="n">irte</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">IRT_IOSAPIC_TYPE</span> <span class="o">!=</span> <span class="n">irte</span><span class="o">-&gt;</span><span class="n">entry_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">COMPARE_IRTE_ADDR</span><span class="p">(</span><span class="n">irte</span><span class="p">,</span> <span class="n">hpa</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">irt_num_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;iosapic_register() ignoring 0x%lx (NOT FOUND)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hpa</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">isi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">isi</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">hpa</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_hpa</span> <span class="o">=</span> <span class="n">hpa</span><span class="p">;</span>
	<span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_version</span> <span class="o">=</span> <span class="n">iosapic_rd_version</span><span class="p">(</span><span class="n">isi</span><span class="p">);</span>
	<span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_num_vectors</span> <span class="o">=</span> <span class="n">IOSAPIC_IRDT_MAX_ENTRY</span><span class="p">(</span><span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_version</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vip</span> <span class="o">=</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_vector</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_num_vectors</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vector_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">isi</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_num_vectors</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">,</span> <span class="n">vip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vip</span><span class="o">-&gt;</span><span class="n">irqline</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">vip</span><span class="o">-&gt;</span><span class="n">iosapic</span> <span class="o">=</span> <span class="n">isi</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">isi</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef DEBUG_IOSAPIC</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_prt_irt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">irt</span><span class="p">,</span> <span class="kt">long</span> <span class="n">num_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">irp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">irt</span><span class="p">;</span>


	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: Interrupt Routing Table (%lx entries)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_entry</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num_entry</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">irp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%p : %2d %.8x %.8x %.8x %.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">irp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">irp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">irp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">irp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">irp</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_prt_vi</span><span class="p">(</span><span class="k">struct</span> <span class="n">vector_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: vector_info[%d] is at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">irqline</span><span class="p">,</span> <span class="n">vi</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">status:	 %.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">txn_irq:  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_irq</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">txn_addr: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_addr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">txn_data: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">txn_data</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">eoi_addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_addr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">eoi_data: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">vi</span><span class="o">-&gt;</span><span class="n">eoi_data</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_prt_isi</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_info</span> <span class="o">*</span><span class="n">isi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">MODULE_NAME</span> <span class="s">&quot;: io_sapic_info at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">isi_hpa:       %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_hpa</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">isi_status:    %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_status</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">isi_version:   %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_version</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">isi_vector:    %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isi</span><span class="o">-&gt;</span><span class="n">isi_vector</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_IOSAPIC */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
