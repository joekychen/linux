<!DOCTYPE html>
<html><head><title>joekychen/linux » security › selinux › hooks.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hooks.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  NSA Security-Enhanced Linux (SELinux) security module</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the SELinux hook function implementations.</span>
<span class="cm"> *</span>
<span class="cm"> *  Authors:  Stephen Smalley, &lt;sds@epoch.ncsc.mil&gt;</span>
<span class="cm"> *	      Chris Vance, &lt;cvance@nai.com&gt;</span>
<span class="cm"> *	      Wayne Salamon, &lt;wsalamon@nai.com&gt;</span>
<span class="cm"> *	      James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2001,2002 Networks Associates Technology, Inc.</span>
<span class="cm"> *  Copyright (C) 2003-2008 Red Hat, Inc., James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *					   Eric Paris &lt;eparis@redhat.com&gt;</span>
<span class="cm"> *  Copyright (C) 2004-2005 Trusted Computer Solutions, Inc.</span>
<span class="cm"> *			    &lt;dgoeddel@trustedcs.com&gt;</span>
<span class="cm"> *  Copyright (C) 2006, 2007, 2009 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> *	Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *  Copyright (C) 2007 Hitachi Software Engineering Co., Ltd.</span>
<span class="cm"> *		       Yuichi Nakamura &lt;ynakam@hitachisoft.jp&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License version 2,</span>
<span class="cm"> *	as published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kd.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv4.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;		</span><span class="cm">/* for local_port_range[] */</span><span class="cp"></span>
<span class="cp">#include &lt;net/tcp.h&gt;		</span><span class="cm">/* struct or_callable used in sock_rcv_skb */</span><span class="cp"></span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/netlabel.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/ioctls.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;	</span><span class="cm">/* for network interface checks */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/dccp.h&gt;</span>
<span class="cp">#include &lt;linux/quota.h&gt;</span>
<span class="cp">#include &lt;linux/un.h&gt;		</span><span class="cm">/* for Unix socket types */</span><span class="cp"></span>
<span class="cp">#include &lt;net/af_unix.h&gt;	</span><span class="cm">/* for Unix socket types */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/parser.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_mount.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/selinux.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/syslog.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/msg.h&gt;</span>
<span class="cp">#include &lt;linux/shm.h&gt;</span>

<span class="cp">#include &quot;avc.h&quot;</span>
<span class="cp">#include &quot;objsec.h&quot;</span>
<span class="cp">#include &quot;netif.h&quot;</span>
<span class="cp">#include &quot;netnode.h&quot;</span>
<span class="cp">#include &quot;netport.h&quot;</span>
<span class="cp">#include &quot;xfrm.h&quot;</span>
<span class="cp">#include &quot;netlabel.h&quot;</span>
<span class="cp">#include &quot;audit.h&quot;</span>
<span class="cp">#include &quot;avc_ss.h&quot;</span>

<span class="cp">#define NUM_SEL_MNT_OPTS 5</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">security_operations</span> <span class="o">*</span><span class="n">security_ops</span><span class="p">;</span>

<span class="cm">/* SECMARK reference count */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">selinux_secmark_refcount</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY_SELINUX_DEVELOP</span>
<span class="kt">int</span> <span class="n">selinux_enforcing</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">enforcing_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">enforcing</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enforcing</span><span class="p">))</span>
		<span class="n">selinux_enforcing</span> <span class="o">=</span> <span class="n">enforcing</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;enforcing=&quot;</span><span class="p">,</span> <span class="n">enforcing_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SECURITY_SELINUX_BOOTPARAM</span>
<span class="kt">int</span> <span class="n">selinux_enabled</span> <span class="o">=</span> <span class="n">CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">selinux_enabled_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">))</span>
		<span class="n">selinux_enabled</span> <span class="o">=</span> <span class="n">enabled</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;selinux=&quot;</span><span class="p">,</span> <span class="n">selinux_enabled_setup</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">selinux_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sel_inode_cache</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * selinux_secmark_enabled - Check to see if SECMARK is currently enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function checks the SECMARK reference counter to see if any SECMARK</span>
<span class="cm"> * targets are currently configured, if the reference counter is greater than</span>
<span class="cm"> * zero SECMARK is considered to be enabled.  Returns true (1) if SECMARK is</span>
<span class="cm"> * enabled, false (0) if SECMARK is disabled.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_secmark_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selinux_secmark_refcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialise the security for the init task</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cred_init_security</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">)</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">real_cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>

	<span class="n">tsec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsec</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SELinux:  Failed to initialize initial task.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">osid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_KERNEL</span><span class="p">;</span>
	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get the security ID of a set of credentials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">cred_sid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>

	<span class="n">tsec</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get the objective security ID of a task</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">task_sid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get the subjective security ID of the current task</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">current_sid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate and free functions for each kind of security blob. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inode_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">sel_inode_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">SECCLASS_FILE</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">task_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="n">isec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sel_inode_cache</span><span class="p">,</span> <span class="n">isec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">file_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">fsec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">fsec</span><span class="o">-&gt;</span><span class="n">fown_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="n">fsec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">file_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">superblock_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">;</span>

	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">superblock_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_head</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
	<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span> <span class="o">=</span> <span class="n">SECINITSID_FILE</span><span class="p">;</span>
	<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span> <span class="o">=</span> <span class="n">sbsec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">superblock_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The file system&#39;s label must be initialized prior to use. */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">labeling_behaviors</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;uses xattr&quot;</span><span class="p">,</span>
	<span class="s">&quot;uses transition SIDs&quot;</span><span class="p">,</span>
	<span class="s">&quot;uses task SIDs&quot;</span><span class="p">,</span>
	<span class="s">&quot;uses genfs_contexts&quot;</span><span class="p">,</span>
	<span class="s">&quot;not configured for labeling&quot;</span><span class="p">,</span>
	<span class="s">&quot;uses mountpoint labeling&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">inode_doinit_with_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">opt_dentry</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inode_doinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inode_doinit_with_dentry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">Opt_error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">Opt_context</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">Opt_fscontext</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">Opt_defcontext</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">Opt_rootcontext</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">Opt_labelsupport</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">match_table_t</span> <span class="n">tokens</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">Opt_context</span><span class="p">,</span> <span class="n">CONTEXT_STR</span> <span class="s">&quot;%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_fscontext</span><span class="p">,</span> <span class="n">FSCONTEXT_STR</span> <span class="s">&quot;%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_defcontext</span><span class="p">,</span> <span class="n">DEFCONTEXT_STR</span> <span class="s">&quot;%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_rootcontext</span><span class="p">,</span> <span class="n">ROOTCONTEXT_STR</span> <span class="s">&quot;%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_labelsupport</span><span class="p">,</span> <span class="n">LABELSUPP_STR</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_error</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define SEL_MOUNT_FAIL_MSG &quot;SELinux:  duplicate or incompatible mount options\n&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_context_mount_sb_relabel</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			  <span class="n">FILESYSTEM__RELABELFROM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			  <span class="n">FILESYSTEM__RELABELTO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_context_mount_inode_relabel</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			  <span class="n">FILESYSTEM__RELABELFROM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			  <span class="n">FILESYSTEM__ASSOCIATE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sb_finish_set_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root_inode</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">SECURITY_FS_USE_XATTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure that the xattr handler exists and that no</span>
<span class="cm">		   error other than -ENODATA is returned by getxattr on</span>
<span class="cm">		   the root directory.  -ENODATA is ok, as this may be</span>
<span class="cm">		   the first boot of the SELinux kernel before we have</span>
<span class="cm">		   assigned xattr values to the filesystem. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: (dev %s, type %s) has no &quot;</span>
			       <span class="s">&quot;xattr support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">root_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: (dev %s, type &quot;</span>
				       <span class="s">&quot;%s) has no security xattr handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: (dev %s, type &quot;</span>
				       <span class="s">&quot;%s) getxattr errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
				       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SE_SBINITIALIZED</span> <span class="o">|</span> <span class="n">SE_SBLABELSUPP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">labeling_behaviors</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: initialized (dev %s, type %s), unknown behavior</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux: initialized (dev %s, type %s), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">labeling_behaviors</span><span class="p">[</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">SECURITY_FS_USE_GENFS</span> <span class="o">||</span>
	    <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">SECURITY_FS_USE_MNTPOINT</span> <span class="o">||</span>
	    <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">SECURITY_FS_USE_NONE</span> <span class="o">||</span>
	    <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">labeling_behaviors</span><span class="p">))</span>
		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SE_SBLABELSUPP</span><span class="p">;</span>

	<span class="cm">/* Special handling for sysfs. Is genfs but also has setxattr handler*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;sysfs&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SE_SBLABELSUPP</span><span class="p">;</span>

	<span class="cm">/* Initialize the root inode. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">inode_doinit_with_dentry</span><span class="p">(</span><span class="n">root_inode</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="cm">/* Initialize any other inodes associated with the superblock, e.g.</span>
<span class="cm">	   inodes created prior to initial policy load or inodes created</span>
<span class="cm">	   during get_sb by a pseudo filesystem that directly</span>
<span class="cm">	   populates itself. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
<span class="nl">next_inode:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span>
				<span class="n">list_entry</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_head</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">inode_security_struct</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_PRIVATE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="n">inode_doinit</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">next_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function should allow an FS to ask what it&#39;s mount security</span>
<span class="cm"> * options were so it can use those later for submounts, displaying</span>
<span class="cm"> * mount options, or whatever.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_get_mnt_opts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">security_init_mnt_opts</span><span class="p">(</span><span class="n">opts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_MNTMASK</span><span class="p">;</span>
	<span class="cm">/* count the number of mount options for this sb */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if the Label support flag is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">)</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">;</span>

	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FSCONTEXT_MNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">FSCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONTEXT_MNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">SE_SBLABELSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">security_free_mnt_opts</span><span class="p">(</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bad_option</span><span class="p">(</span><span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">,</span> <span class="kt">char</span> <span class="n">flag</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">old_sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">mnt_flags</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_MNTMASK</span><span class="p">;</span>

	<span class="cm">/* check if the old mount command had the same options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">old_sid</span> <span class="o">!=</span> <span class="n">new_sid</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check if we were passed the same options twice,</span>
<span class="cm">	 * aka someone passed context=a,context=b</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allow filesystems with binary mount data to explicitly set mount point</span>
<span class="cm"> * labeling information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_set_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">root_isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fscontext_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">context_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rootcontext_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">defcontext_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">mount_options</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_opts</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_opts</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Defer initialization until selinux_complete_init,</span>
<span class="cm">			   after the initial policy is loaded and the security</span>
<span class="cm">			   server is ready to handle calls. */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: Unable to set superblock options &quot;</span>
			<span class="s">&quot;before the security server is initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Binary mount data FS will come through this function twice.  Once</span>
<span class="cm">	 * from an explicit call and once from the generic calls from the vfs.</span>
<span class="cm">	 * Since the generic VFS calls will not contain any security mount data</span>
<span class="cm">	 * we need to skip the double mount verification.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This does open a hole in which we will not notice if the first</span>
<span class="cm">	 * mount using this sb set explict options and a second mount using</span>
<span class="cm">	 * this sb does not set any security options.  (The first options</span>
<span class="cm">	 * will be used for both mounts)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_BINARY_MOUNTDATA</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">num_opts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * parse the mount options, check if they are valid sids.</span>
<span class="cm">	 * also check if someone is trying to mount the same sb more</span>
<span class="cm">	 * than once with different security options.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_opts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">SE_SBLABELSUPP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid</span><span class="p">(</span><span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					     <span class="n">strlen</span><span class="p">(</span><span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: security_context_to_sid&quot;</span>
			       <span class="s">&quot;(%s) failed for (dev %s, type %s) errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FSCONTEXT_MNT</span>:
			<span class="n">fscontext_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">FSCONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					<span class="n">fscontext_sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_double_mount</span><span class="p">;</span>

			<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FSCONTEXT_MNT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONTEXT_MNT</span>:
			<span class="n">context_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">CONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">,</span>
					<span class="n">context_sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_double_mount</span><span class="p">;</span>

			<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CONTEXT_MNT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ROOTCONTEXT_MNT</span>:
			<span class="n">rootcontext_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">,</span> <span class="n">root_isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					<span class="n">rootcontext_sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_double_mount</span><span class="p">;</span>

			<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DEFCONTEXT_MNT</span>:
			<span class="n">defcontext_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">,</span>
					<span class="n">defcontext_sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_double_mount</span><span class="p">;</span>

			<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* previously mounted with options, but not on this attempt? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_MNTMASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">num_opts</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_double_mount</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;proc&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SE_SBPROC</span><span class="p">;</span>

	<span class="cm">/* Determine the labeling behavior to use for this filesystem type. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_fs_use</span><span class="p">((</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBPROC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;proc&quot;</span> <span class="o">:</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: security_fs_use(%s) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sets the context of the superblock for the fs being mounted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fscontext_sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">may_context_mount_sb_relabel</span><span class="p">(</span><span class="n">fscontext_sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">fscontext_sid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch to using mount point labeling behavior.</span>
<span class="cm">	 * sets the label used on all file below the mountpoint, and will set</span>
<span class="cm">	 * the superblock context if not already set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fscontext_sid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">may_context_mount_sb_relabel</span><span class="p">(</span><span class="n">context_sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="p">,</span>
							  <span class="n">cred</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">context_sid</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">may_context_mount_inode_relabel</span><span class="p">(</span><span class="n">context_sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="p">,</span>
							     <span class="n">cred</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootcontext_sid</span><span class="p">)</span>
			<span class="n">rootcontext_sid</span> <span class="o">=</span> <span class="n">context_sid</span><span class="p">;</span>

		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span> <span class="o">=</span> <span class="n">context_sid</span><span class="p">;</span>
		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">=</span> <span class="n">SECURITY_FS_USE_MNTPOINT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rootcontext_sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">may_context_mount_inode_relabel</span><span class="p">(</span><span class="n">rootcontext_sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="p">,</span>
						     <span class="n">cred</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">root_isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">rootcontext_sid</span><span class="p">;</span>
		<span class="n">root_isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">defcontext_sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">!=</span> <span class="n">SECURITY_FS_USE_XATTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: defcontext option is &quot;</span>
			       <span class="s">&quot;invalid for this filesystem type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">defcontext_sid</span> <span class="o">!=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">may_context_mount_inode_relabel</span><span class="p">(</span><span class="n">defcontext_sid</span><span class="p">,</span>
							     <span class="n">sbsec</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span> <span class="o">=</span> <span class="n">defcontext_sid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sb_finish_set_opts</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_double_mount:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: mount invalid.  Same superblock, different &quot;</span>
	       <span class="s">&quot;security settings for (dev %s, type %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sb_clone_mnt_opts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">oldsb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">newsb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">oldsbsec</span> <span class="o">=</span> <span class="n">oldsb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">newsbsec</span> <span class="o">=</span> <span class="n">newsb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">set_fscontext</span> <span class="o">=</span>	<span class="p">(</span><span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FSCONTEXT_MNT</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">set_context</span> <span class="o">=</span>	<span class="p">(</span><span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CONTEXT_MNT</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">set_rootcontext</span> <span class="o">=</span>	<span class="p">(</span><span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the parent was able to be mounted it clearly had no special lsm</span>
<span class="cm">	 * mount options.  thus we can safely deal with this superblock later</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* how can we clone if the old one wasn&#39;t set up?? */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">));</span>

	<span class="cm">/* if fs is reusing a sb, just let its options stand... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span> <span class="o">=</span> <span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">;</span>
	<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">=</span> <span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">behavior</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">oldsbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_fscontext</span><span class="p">)</span>
			<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_rootcontext</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">newinode</span> <span class="o">=</span> <span class="n">newsb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">newisec</span> <span class="o">=</span> <span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
			<span class="n">newisec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_rootcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">oldinode</span> <span class="o">=</span> <span class="n">oldsb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">oldisec</span> <span class="o">=</span> <span class="n">oldinode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">newinode</span> <span class="o">=</span> <span class="n">newsb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">newisec</span> <span class="o">=</span> <span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

		<span class="n">newisec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">oldisec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb_finish_set_opts</span><span class="p">(</span><span class="n">newsb</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsbsec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_parse_opts_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">defcontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fscontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rootcontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">num_mnt_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Standard string-based options. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;|&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
		<span class="n">substring_t</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_OPT_ARGS</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">token</span> <span class="o">=</span> <span class="n">match_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Opt_context</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="o">||</span> <span class="n">defcontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SEL_MOUNT_FAIL_MSG</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">context</span> <span class="o">=</span> <span class="n">match_strdup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">Opt_fscontext</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">fscontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SEL_MOUNT_FAIL_MSG</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fscontext</span> <span class="o">=</span> <span class="n">match_strdup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fscontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">Opt_rootcontext</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">rootcontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SEL_MOUNT_FAIL_MSG</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rootcontext</span> <span class="o">=</span> <span class="n">match_strdup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootcontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">Opt_defcontext</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="o">||</span> <span class="n">defcontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SEL_MOUNT_FAIL_MSG</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">defcontext</span> <span class="o">=</span> <span class="n">match_strdup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">defcontext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_labelsupport</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux:  unknown mount option</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">NUM_SEL_MNT_OPTS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">NUM_SEL_MNT_OPTS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fscontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="p">]</span> <span class="o">=</span> <span class="n">fscontext</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">FSCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rootcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootcontext</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">defcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="p">]</span> <span class="o">=</span> <span class="n">defcontext</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">num_mnt_opts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span> <span class="o">=</span> <span class="n">num_mnt_opts</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">defcontext</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fscontext</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rootcontext</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * string mount options parsing and call set the sbsec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">superblock_doinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">options</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="n">opts</span><span class="p">;</span>

	<span class="n">security_init_mnt_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_BINARY_MOUNTDATA</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_parse_opts_str</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_set_mnt_opts</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>

<span class="nl">out_err:</span>
	<span class="n">security_free_mnt_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_write_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">has_comma</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">has_comma</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">has_comma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CONTEXT_MNT</span>:
			<span class="n">prefix</span> <span class="o">=</span> <span class="n">CONTEXT_STR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSCONTEXT_MNT</span>:
			<span class="n">prefix</span> <span class="o">=</span> <span class="n">FSCONTEXT_STR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ROOTCONTEXT_MNT</span>:
			<span class="n">prefix</span> <span class="o">=</span> <span class="n">ROOTCONTEXT_STR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DEFCONTEXT_MNT</span>:
			<span class="n">prefix</span> <span class="o">=</span> <span class="n">DEFCONTEXT_STR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SE_SBLABELSUPP</span>:
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">LABELSUPP_STR</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="cm">/* we need a comma before each option */</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_comma</span><span class="p">)</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\&quot;&#39;</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_comma</span><span class="p">)</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\&quot;&#39;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="n">opts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_get_mnt_opts</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* before policy load we may get EINVAL, don&#39;t show anything */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">selinux_write_opts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>

	<span class="n">security_free_mnt_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">inode_mode_to_security_class</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="k">return</span> <span class="n">SECCLASS_SOCK_FILE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="k">return</span> <span class="n">SECCLASS_LNK_FILE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="k">return</span> <span class="n">SECCLASS_FILE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
		<span class="k">return</span> <span class="n">SECCLASS_BLK_FILE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">return</span> <span class="n">SECCLASS_DIR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="k">return</span> <span class="n">SECCLASS_CHR_FILE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
		<span class="k">return</span> <span class="n">SECCLASS_FIFO_FILE</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SECCLASS_FILE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_protocol_stream</span><span class="p">(</span><span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_IP</span> <span class="o">||</span> <span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_protocol_dgram</span><span class="p">(</span><span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_IP</span> <span class="o">||</span> <span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">socket_type_to_security_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_UNIX</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
			<span class="k">return</span> <span class="n">SECCLASS_UNIX_STREAM_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
			<span class="k">return</span> <span class="n">SECCLASS_UNIX_DGRAM_SOCKET</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_INET</span>:
	<span class="k">case</span> <span class="n">PF_INET6</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">default_protocol_stream</span><span class="p">(</span><span class="n">protocol</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">SECCLASS_TCP_SOCKET</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">SECCLASS_RAWIP_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">default_protocol_dgram</span><span class="p">(</span><span class="n">protocol</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">SECCLASS_UDP_SOCKET</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">SECCLASS_RAWIP_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SOCK_DCCP</span>:
			<span class="k">return</span> <span class="n">SECCLASS_DCCP_SOCKET</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">SECCLASS_RAWIP_SOCKET</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_NETLINK</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLINK_ROUTE</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_ROUTE_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_FIREWALL</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_FIREWALL_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_SOCK_DIAG</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_TCPDIAG_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_NFLOG</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_NFLOG_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_XFRM</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_XFRM_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_SELINUX</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_SELINUX_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_AUDIT</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_AUDIT_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_IP6_FW</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_IP6FW_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_DNRTMSG</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_DNRT_SOCKET</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLINK_KOBJECT_UEVENT</span>:
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">SECCLASS_NETLINK_SOCKET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">PF_PACKET</span>:
		<span class="k">return</span> <span class="n">SECCLASS_PACKET_SOCKET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_KEY</span>:
		<span class="k">return</span> <span class="n">SECCLASS_KEY_SOCKET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_APPLETALK</span>:
		<span class="k">return</span> <span class="n">SECCLASS_APPLETALK_SOCKET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SECCLASS_SOCKET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_proc_get_sid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">dentry_path_raw</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* each process gets a /proc/PID/ entry. Strip off the</span>
<span class="cm">		 * PID part to get a valid selinux labeling.</span>
<span class="cm">		 * e.g. /proc/1/net/rpc/nfs -&gt; /net/rpc/nfs */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
			<span class="n">path</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_genfs_sid</span><span class="p">(</span><span class="s">&quot;proc&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_proc_get_sid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* The inode&#39;s security attributes must be initialized before first use. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inode_doinit_with_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">opt_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
<span class="cp">#define INITCONTEXTLEN 255</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Defer initialization until selinux_complete_init,</span>
<span class="cm">		   after the initial policy is loaded and the security</span>
<span class="cm">		   server is ready to handle calls. */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_head</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">isec_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SECURITY_FS_USE_XATTR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Need a dentry, since the xattr API requires one.</span>
<span class="cm">		   Life would be simpler if we could just pass the inode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opt_dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Called from d_instantiate or d_splice_alias. */</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">opt_dentry</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Called from selinux_complete_init, try to find a dentry. */</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * this is can be hit on boot when a file is accessed</span>
<span class="cm">			 * before the policy is loaded.  When we load policy we</span>
<span class="cm">			 * may find inodes that have no dentry on the</span>
<span class="cm">			 * sbsec-&gt;isec_head list.  No reason to complain as these</span>
<span class="cm">			 * will get fixed up the next time we go through</span>
<span class="cm">			 * inode_doinit with a dentry, before these inodes could</span>
<span class="cm">			 * be used again by userspace.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">INITCONTEXTLEN</span><span class="p">;</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">context</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span>
					   <span class="n">context</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

			<span class="cm">/* Need a larger buffer.  Query for the right size. */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span>
						   <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">context</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">context</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span>
						   <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span>
						   <span class="n">context</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: %s:  getxattr returned &quot;</span>
				       <span class="s">&quot;%d for dev=%s ino=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				       <span class="o">-</span><span class="n">rc</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Map ENODATA to the default file SID */</span>
			<span class="n">sid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid_default</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">,</span>
							     <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">,</span>
							     <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
						<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SELinux: inode=%lu on dev=%s was found to have an invalid &quot;</span>
							<span class="s">&quot;context=%s.  This indicates you may need to relabel the inode or the &quot;</span>
							<span class="s">&quot;filesystem in question.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: %s:  context_to_sid(%s) &quot;</span>
					       <span class="s">&quot;returned %d for dev=%s ino=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">__func__</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
				<span class="cm">/* Leave with the unlabeled SID */</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SECURITY_FS_USE_TASK</span>:
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">task_sid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SECURITY_FS_USE_TRANS</span>:
		<span class="cm">/* Default to the fs SID. */</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

		<span class="cm">/* Try to obtain a transition SID. */</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">task_sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					     <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SECURITY_FS_USE_MNTPOINT</span>:
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Default to the fs superblock SID. */</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBPROC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opt_dentry</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_proc_get_sid</span><span class="p">(</span><span class="n">opt_dentry</span><span class="p">,</span>
							  <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_FILE</span><span class="p">)</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a Linux signal to an access vector. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">signal_to_av</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">perm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIGCHLD</span>:
		<span class="cm">/* Commonly granted from child to parent. */</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">PROCESS__SIGCHLD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIGKILL</span>:
		<span class="cm">/* Cannot be caught or ignored */</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">PROCESS__SIGKILL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIGSTOP</span>:
		<span class="cm">/* Cannot be caught or ignored */</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">PROCESS__SIGSTOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* All other signals. */</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">PROCESS__SIGNAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">perm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check permission between a pair of credentials</span>
<span class="cm"> * fork check, ptrace check, etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cred_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">actor</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">asid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">actor</span><span class="p">),</span> <span class="n">tsid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">asid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check permission between a pair of tasks, e.g. signal checks,</span>
<span class="cm"> * fork check, ptrace check, etc.</span>
<span class="cm"> * tsk1 is the actor and tsk2 is the target</span>
<span class="cm"> * - this uses the default subjective creds of tsk1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk1</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk2</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">__tsec1</span><span class="p">,</span> <span class="o">*</span><span class="n">__tsec2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid1</span><span class="p">,</span> <span class="n">sid2</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">__tsec1</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">tsk1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>	<span class="n">sid1</span> <span class="o">=</span> <span class="n">__tsec1</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">__tsec2</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">tsk2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>	<span class="n">sid2</span> <span class="o">=</span> <span class="n">__tsec2</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid1</span><span class="p">,</span> <span class="n">sid2</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check permission between current and another task, e.g. signal checks,</span>
<span class="cm"> * fork check, ptrace check, etc.</span>
<span class="cm"> * current is the actor and tsk2 is the target</span>
<span class="cm"> * - this uses current&#39;s subjective creds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">current_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="n">tsid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if CAP_LAST_CAP &gt; 63</span>
<span class="cp">#error Fix SELinux to handle capabilities &gt; 63.</span>
<span class="cp">#endif</span>

<span class="cm">/* Check whether a task is allowed to use a capability. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cred_has_capability</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">av_decision</span> <span class="n">avd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sclass</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="n">CAP_TO_MASK</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_CAP</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">cap</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">CAP_TO_INDEX</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">sclass</span> <span class="o">=</span> <span class="n">SECCLASS_CAPABILITY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">sclass</span> <span class="o">=</span> <span class="n">SECCLASS_CAPABILITY2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;SELinux:  out of range capability %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm_noaudit</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">sclass</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit</span> <span class="o">==</span> <span class="n">SECURITY_CAP_AUDIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc2</span> <span class="o">=</span> <span class="n">avc_audit</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">sclass</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avd</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task is allowed to use a system operation. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_has_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECINITSID_KERNEL</span><span class="p">,</span>
			    <span class="n">SECCLASS_SYSTEM</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task has a particular permission to an inode.</span>
<span class="cm">   The &#39;adp&#39; parameter is optional and allows other audit</span>
<span class="cm">   data to be passed (e.g. the dentry). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inode_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">perms</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">adp</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

	<span class="n">validate_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_PRIVATE</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm_flags</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">adp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Same as inode_has_perm, but pass explicit audit data containing</span>
<span class="cm">   the dentry to help the auditing code to more easily generate the</span>
<span class="cm">   pathname if needed. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dentry_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">inode_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Same as inode_has_perm, but pass explicit audit data containing</span>
<span class="cm">   the path to help the auditing code to more easily generate the</span>
<span class="cm">   pathname if needed. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">path_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">inode_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task can use an open file descriptor to</span>
<span class="cm">   access an inode in a given way.  Check access to the</span>
<span class="cm">   descriptor itself, and then use dentry_has_perm to</span>
<span class="cm">   check a particular permission to the file.</span>
<span class="cm">   Access to the descriptor is implicitly granted if it</span>
<span class="cm">   has the same SID as the process.  If av is zero, then</span>
<span class="cm">   access to the file is not checked, e.g. for cases</span>
<span class="cm">   where only the descriptor is affected like seek. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">file_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">!=</span> <span class="n">fsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">fsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">SECCLASS_FD</span><span class="p">,</span>
				  <span class="n">FD__USE</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* av is zero if only checking access to the descriptor. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">inode_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task can create a file. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		      <span class="n">u16</span> <span class="n">tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">dsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">dsec</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">newsid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">,</span>
			  <span class="n">DIR__ADD_NAME</span> <span class="o">|</span> <span class="n">DIR__SEARCH</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsid</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">FILE__CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">newsid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			    <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			    <span class="n">FILESYSTEM__ASSOCIATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task can create a key. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_create_key</span><span class="p">(</span><span class="n">u32</span> <span class="n">ksid</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">ksid</span><span class="p">,</span> <span class="n">SECCLASS_KEY</span><span class="p">,</span> <span class="n">KEY__CREATE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MAY_LINK	0</span>
<span class="cp">#define MAY_UNLINK	1</span>
<span class="cp">#define MAY_RMDIR	2</span>

<span class="cm">/* Check whether a task can link, unlink, or rmdir a file/directory. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">kind</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">dsec</span><span class="p">,</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">av</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">dsec</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">isec</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="n">av</span> <span class="o">=</span> <span class="n">DIR__SEARCH</span><span class="p">;</span>
	<span class="n">av</span> <span class="o">|=</span> <span class="p">(</span><span class="n">kind</span> <span class="o">?</span> <span class="n">DIR__REMOVE_NAME</span> <span class="o">:</span> <span class="n">DIR__ADD_NAME</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAY_LINK</span>:
		<span class="n">av</span> <span class="o">=</span> <span class="n">FILE__LINK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MAY_UNLINK</span>:
		<span class="n">av</span> <span class="o">=</span> <span class="n">FILE__UNLINK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MAY_RMDIR</span>:
		<span class="n">av</span> <span class="o">=</span> <span class="n">DIR__RMDIR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: %s:  unrecognized kind %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">kind</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">may_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">old_dsec</span><span class="p">,</span> <span class="o">*</span><span class="n">new_dsec</span><span class="p">,</span> <span class="o">*</span><span class="n">old_isec</span><span class="p">,</span> <span class="o">*</span><span class="n">new_isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">av</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_is_dir</span><span class="p">,</span> <span class="n">new_is_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">old_dsec</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">old_isec</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">old_is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">new_dsec</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">old_dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">,</span>
			  <span class="n">DIR__REMOVE_NAME</span> <span class="o">|</span> <span class="n">DIR__SEARCH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">old_isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			  <span class="n">old_isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">FILE__RENAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_is_dir</span> <span class="o">&amp;&amp;</span> <span class="n">new_dir</span> <span class="o">!=</span> <span class="n">old_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">old_isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">old_isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">DIR__REPARENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="p">;</span>
	<span class="n">av</span> <span class="o">=</span> <span class="n">DIR__ADD_NAME</span> <span class="o">|</span> <span class="n">DIR__SEARCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">DIR__REMOVE_NAME</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">new_dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_isec</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
		<span class="n">new_is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">new_isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">new_isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">new_is_dir</span> <span class="o">?</span> <span class="n">DIR__RMDIR</span> <span class="o">:</span> <span class="n">FILE__UNLINK</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether a task can perform a filesystem operation. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">superblock_has_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">perms</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Convert a Linux mode and permission mask to an access vector. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">file_mask_to_av</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__EXECUTE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_READ</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__READ</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_APPEND</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__APPEND</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__WRITE</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">DIR__SEARCH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">DIR__WRITE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_READ</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">DIR__READ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">av</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a Linux file to an access vector. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">file_to_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__APPEND</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__WRITE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">av</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special file opened with flags 3 for ioctl-only use.</span>
<span class="cm">		 */</span>
		<span class="n">av</span> <span class="o">=</span> <span class="n">FILE__IOCTL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">av</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a file to an access vector and include the correct open</span>
<span class="cm"> * open permission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">open_file_to_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="n">file_to_av</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_policycap_openperm</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__OPEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">av</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Hook functions begin here. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_ptrace_access_check</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">PTRACE_MODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
		<span class="n">u32</span> <span class="n">csid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">csid</span><span class="p">,</span> <span class="n">SECCLASS_FILE</span><span class="p">,</span> <span class="n">FILE__READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">PROCESS__PTRACE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_ptrace_traceme</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">task_has_perm</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">PROCESS__PTRACE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_capget</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
			  <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">PROCESS__GETCAP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cap_capget</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">effective</span><span class="p">,</span> <span class="n">inheritable</span><span class="p">,</span> <span class="n">permitted</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_capset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">cap_capset</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span>
				      <span class="n">effective</span><span class="p">,</span> <span class="n">inheritable</span><span class="p">,</span> <span class="n">permitted</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cred_has_perm</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">PROCESS__SETCAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (This comment used to live with the selinux_task_setuid hook,</span>
<span class="cm"> * which was removed).</span>
<span class="cm"> *</span>
<span class="cm"> * Since setuid only affects the current process, and since the SELinux</span>
<span class="cm"> * controls are not based on the Linux identity attributes, SELinux does not</span>
<span class="cm"> * need to control this operation.  However, SELinux does control the use of</span>
<span class="cm"> * the CAP_SETUID and CAP_SETGID capabilities using the capable hook.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_capable</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">audit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cred_has_capability</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">audit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_quotactl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmds</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">Q_SYNC</span>:
	<span class="k">case</span> <span class="n">Q_QUOTAON</span>:
	<span class="k">case</span> <span class="n">Q_QUOTAOFF</span>:
	<span class="k">case</span> <span class="n">Q_SETINFO</span>:
	<span class="k">case</span> <span class="n">Q_SETQUOTA</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">FILESYSTEM__QUOTAMOD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">Q_GETFMT</span>:
	<span class="k">case</span> <span class="n">Q_GETINFO</span>:
	<span class="k">case</span> <span class="n">Q_GETQUOTA</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">FILESYSTEM__QUOTAGET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* let the kernel handle invalid cmds */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_quota_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__QUOTAON</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ_ALL</span>:	<span class="cm">/* Read last kernel messages */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_SIZE_BUFFER</span>:	<span class="cm">/* Return size of the log buffer */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__SYSLOG_READ</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_OFF</span>:	<span class="cm">/* Disable logging to console */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_ON</span>:	<span class="cm">/* Enable logging to console */</span>
	<span class="cm">/* Set level of messages printed to console */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_LEVEL</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__SYSLOG_CONSOLE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CLOSE</span>:	<span class="cm">/* Close log */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_OPEN</span>:	<span class="cm">/* Open log */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ</span>:	<span class="cm">/* Read from log */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ_CLEAR</span>:	<span class="cm">/* Read/clear last kernel messages */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CLEAR</span>:	<span class="cm">/* Clear ring buffer */</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__SYSLOG_MOD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that a process has enough memory to allocate a new virtual</span>
<span class="cm"> * mapping. 0 means there is enough memory for the allocation to</span>
<span class="cm"> * succeed and -ENOMEM implies there is not.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not audit the selinux permission check, as this is applied to all</span>
<span class="cm"> * processes that allocate mappings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">cap_sys_admin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">,</span>
			     <span class="n">SECURITY_CAP_NOAUDIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cap_sys_admin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__vm_enough_memory</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">cap_sys_admin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* binprm security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">old_tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">new_tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_bprm_set_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* SELinux context only depends on initial program or script and not</span>
<span class="cm">	 * the script interpreter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred_prepared</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">old_tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="n">new_tsec</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="cm">/* Default to the current task SID. */</span>
	<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">osid</span> <span class="o">=</span> <span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="cm">/* Reset fs, key, and sock SIDs on execve. */</span>
	<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">exec_sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">exec_sid</span><span class="p">;</span>
		<span class="cm">/* Reset exec SID on execve. */</span>
		<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">exec_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Minimize confusion: if no_new_privs and a transition is</span>
<span class="cm">		 * explicitly requested, then fail the exec.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span> <span class="n">LSM_UNSAFE_NO_NEW_PRIVS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check for a default transition on this program. */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					     <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOSUID</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span> <span class="n">LSM_UNSAFE_NO_NEW_PRIVS</span><span class="p">))</span>
		<span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">==</span> <span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">SECCLASS_FILE</span><span class="p">,</span> <span class="n">FILE__EXECUTE_NO_TRANS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check permissions for the transition. */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">PROCESS__TRANSITION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">SECCLASS_FILE</span><span class="p">,</span> <span class="n">FILE__ENTRYPOINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* Check for shared state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span> <span class="n">LSM_UNSAFE_SHARE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">old_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					  <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">PROCESS__SHARE</span><span class="p">,</span>
					  <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure that anyone attempting to ptrace over a task that</span>
<span class="cm">		 * changes its SID has the appropriate permit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">LSM_UNSAFE_PTRACE</span> <span class="o">|</span> <span class="n">LSM_UNSAFE_PTRACE_CAP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tracer</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">sec</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">ptsid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">tracer</span> <span class="o">=</span> <span class="n">ptrace_parent</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tracer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sec</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
				<span class="n">ptsid</span> <span class="o">=</span> <span class="n">sec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ptsid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">ptsid</span><span class="p">,</span> <span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
						  <span class="n">SECCLASS_PROCESS</span><span class="p">,</span>
						  <span class="n">PROCESS__PTRACE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Clear any possibly unsafe personality bits on exec: */</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">osid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">atsecure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">osid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">osid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">osid</span> <span class="o">!=</span> <span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable secure mode for SIDs transitions unless</span>
<span class="cm">		   the noatsecure permission is granted between</span>
<span class="cm">		   the two SIDs, i.e. ahp returns 0. */</span>
		<span class="n">atsecure</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">osid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span>
					<span class="n">SECCLASS_PROCESS</span><span class="p">,</span>
					<span class="n">PROCESS__NOATSECURE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">atsecure</span> <span class="o">||</span> <span class="n">cap_bprm_secureexec</span><span class="p">(</span><span class="n">bprm</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Derived from fs/exec.c:flush_old_files. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_unauthorized_files</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">devnull</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_tty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">get_current_tty</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">;</span>

			<span class="cm">/* Revalidate access to controlling tty.</span>
<span class="cm">			   Use path_has_perm on the tty path directly rather</span>
<span class="cm">			   than using file_has_perm, as this particular open</span>
<span class="cm">			   file may belong to another process and we are only</span>
<span class="cm">			   interested in the inode-based check here. */</span>
			<span class="n">file_priv</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tty_file_private</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">file</span> <span class="o">=</span> <span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">FILE__READ</span> <span class="o">|</span> <span class="n">FILE__WRITE</span><span class="p">))</span>
				<span class="n">drop_tty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Reset controlling tty. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_tty</span><span class="p">)</span>
		<span class="n">no_tty</span><span class="p">();</span>

	<span class="cm">/* Revalidate access to inherited open files. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">__NFDBITS</span><span class="p">;</span>
		<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">open_fds</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">set</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">set</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span>
						  <span class="n">file</span><span class="p">,</span>
						  <span class="n">file_to_av</span><span class="p">(</span><span class="n">file</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">sys_close</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
					<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
						<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">devnull</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">get_file</span><span class="p">(</span><span class="n">devnull</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">devnull</span> <span class="o">=</span> <span class="n">dentry_open</span><span class="p">(</span>
							<span class="n">dget</span><span class="p">(</span><span class="n">selinux_null</span><span class="p">),</span>
							<span class="n">mntget</span><span class="p">(</span><span class="n">selinuxfs_mount</span><span class="p">),</span>
							<span class="n">O_RDWR</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">devnull</span><span class="p">))</span> <span class="p">{</span>
							<span class="n">devnull</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
							<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
							<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
							<span class="k">continue</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">devnull</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare a process for imminent new credential changes due to exec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_bprm_committing_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">new_tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim</span><span class="p">,</span> <span class="o">*</span><span class="n">initrlim</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_tsec</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">==</span> <span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">osid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Close files for which the new task SID is not authorized. */</span>
	<span class="n">flush_unauthorized_files</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>

	<span class="cm">/* Always clear parent death signal on SID transitions. */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check whether the new SID can inherit resource limits from the old</span>
<span class="cm">	 * SID.  If not, reset all soft limits to the lower of the current</span>
<span class="cm">	 * task&#39;s hard limit and the init task&#39;s soft limit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the setting of hard limits (even to lower them) can be</span>
<span class="cm">	 * controlled by the setrlimit check.  The inclusion of the init task&#39;s</span>
<span class="cm">	 * soft limit into the computation is to avoid resetting soft limits</span>
<span class="cm">	 * higher than the default soft limit for cases where the default is</span>
<span class="cm">	 * lower than the hard limit, e.g. RLIMIT_CORE or RLIMIT_STACK.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">osid</span><span class="p">,</span> <span class="n">new_tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span>
			  <span class="n">PROCESS__RLIMITINH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* protect against do_prlimit() */</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RLIM_NLIMITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rlim</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">initrlim</span> <span class="o">=</span> <span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">rlim</span><span class="o">-&gt;</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rlim</span><span class="o">-&gt;</span><span class="n">rlim_max</span><span class="p">,</span> <span class="n">initrlim</span><span class="o">-&gt;</span><span class="n">rlim_cur</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">update_rlimit_cpu</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_CPU</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up the process immediately after the installation of new credentials</span>
<span class="cm"> * due to exec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_bprm_committed_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">itimerval</span> <span class="n">itimer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">osid</span><span class="p">,</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">osid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">osid</span><span class="p">;</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">==</span> <span class="n">osid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Check whether the new SID can inherit signal state from the old SID.</span>
<span class="cm">	 * If not, clear itimers to avoid subsequent signal generation and</span>
<span class="cm">	 * flush and unblock signals.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This must occur _after_ the task SID has been updated so that any</span>
<span class="cm">	 * kill done after the flush will be checked against the new SID.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">osid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">PROCESS__SIGINH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itimer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">itimer</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">do_setitimer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itimer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="n">flush_signal_handlers</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wake up the parent if it is waiting so that it can recheck</span>
<span class="cm">	 * wait permission to the new task SID. */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">__wake_up_parent</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* superblock security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">superblock_alloc_security</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sb_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">superblock_free_security</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">match_prefix</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">olen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="n">olen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">selinux_option</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">match_prefix</span><span class="p">(</span><span class="n">CONTEXT_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">match_prefix</span><span class="p">(</span><span class="n">FSCONTEXT_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FSCONTEXT_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">match_prefix</span><span class="p">(</span><span class="n">DEFCONTEXT_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DEFCONTEXT_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">match_prefix</span><span class="p">(</span><span class="n">ROOTCONTEXT_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ROOTCONTEXT_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">match_prefix</span><span class="p">(</span><span class="n">LABELSUPP_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LABELSUPP_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">take_option</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">to</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">**</span><span class="n">to</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">to</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">take_selinux_option</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">to</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">**</span><span class="n">to</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">current_size</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">from</span> <span class="o">!=</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">**</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
			<span class="o">*</span><span class="n">to</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">from</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">current_size</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_copy_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fnosec</span><span class="p">,</span> <span class="n">fsec</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">in_save</span><span class="p">,</span> <span class="o">*</span><span class="n">in_curr</span><span class="p">,</span> <span class="o">*</span><span class="n">in_end</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sec_curr</span><span class="p">,</span> <span class="o">*</span><span class="n">nosec_save</span><span class="p">,</span> <span class="o">*</span><span class="n">nosec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_quote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">in_curr</span> <span class="o">=</span> <span class="n">orig</span><span class="p">;</span>
	<span class="n">sec_curr</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>

	<span class="n">nosec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nosec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nosec_save</span> <span class="o">=</span> <span class="n">nosec</span><span class="p">;</span>
	<span class="n">fnosec</span> <span class="o">=</span> <span class="n">fsec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">in_save</span> <span class="o">=</span> <span class="n">in_end</span> <span class="o">=</span> <span class="n">orig</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">in_end</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">)</span>
			<span class="n">open_quote</span> <span class="o">=</span> <span class="o">!</span><span class="n">open_quote</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">in_end</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">open_quote</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">in_end</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">in_end</span> <span class="o">-</span> <span class="n">in_curr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">selinux_option</span><span class="p">(</span><span class="n">in_curr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
				<span class="n">take_selinux_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sec_curr</span><span class="p">,</span> <span class="n">in_curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsec</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">take_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nosec</span><span class="p">,</span> <span class="n">in_curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fnosec</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">in_curr</span> <span class="o">=</span> <span class="n">in_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">in_end</span><span class="o">++</span><span class="p">);</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">in_save</span><span class="p">,</span> <span class="n">nosec_save</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">nosec_save</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="n">opts</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="o">**</span><span class="n">mount_options</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_BINARY_MOUNTDATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">security_init_mnt_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="n">secdata</span> <span class="o">=</span> <span class="n">alloc_secdata</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secdata</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_sb_copy_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">secdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_secdata</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_parse_opts_str</span><span class="p">(</span><span class="n">secdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_secdata</span><span class="p">;</span>

	<span class="n">mount_options</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">mnt_opts</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">mnt_opts_flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="p">.</span><span class="n">num_mnt_opts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">SE_SBLABELSUPP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid</span><span class="p">(</span><span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: security_context_to_sid&quot;</span>
			       <span class="s">&quot;(%s) failed for (dev %s, type %s) errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mount_options</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_opts</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FSCONTEXT_MNT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">FSCONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_bad_option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONTEXT_MNT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">CONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_bad_option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ROOTCONTEXT_MNT</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">root_isec</span><span class="p">;</span>
			<span class="n">root_isec</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">ROOTCONTEXT_MNT</span><span class="p">,</span> <span class="n">root_isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_bad_option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">DEFCONTEXT_MNT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">bad_option</span><span class="p">(</span><span class="n">sbsec</span><span class="p">,</span> <span class="n">DEFCONTEXT_MNT</span><span class="p">,</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">def_sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_bad_option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out_free_opts</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free_opts:</span>
	<span class="n">security_free_mnt_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
<span class="nl">out_free_secdata:</span>
	<span class="n">free_secdata</span><span class="p">(</span><span class="n">secdata</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_bad_option:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux: unable to change security options &quot;</span>
	       <span class="s">&quot;during remount (dev %s, type=%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
	       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_free_opts</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">superblock_doinit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allow all mounts performed by the kernel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_KERNMOUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">FILESYSTEM__MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sb_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">FILESYSTEM__GETATTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_REMOUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span>
					   <span class="n">FILESYSTEM__REMOUNT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">path_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">FILE__MOUNTON</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">superblock_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">,</span>
				   <span class="n">FILESYSTEM__UNMOUNT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* inode security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inode_alloc_security</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_inode_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode_free_security</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">dsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">clen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">namep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>

	<span class="n">dsec</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">newsid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">SECURITY_FS_USE_MNTPOINT</span><span class="p">))</span>
		<span class="n">newsid</span> <span class="o">=</span> <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">mntpoint_sid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsid</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">dsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
					     <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">),</span>
					     <span class="n">qstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:  &quot;</span>
			       <span class="s">&quot;security_transition_sid failed, rc=%d (dev=%s &quot;</span>
			       <span class="s">&quot;ino=%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span>
			       <span class="o">-</span><span class="n">rc</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Possibly defer initialization to selinux_complete_init. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBINITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">newsid</span><span class="p">;</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">namep</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">XATTR_SELINUX_SUFFIX</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">namep</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">namep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context_force</span><span class="p">(</span><span class="n">newsid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">namep</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">SECCLASS_FILE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_link</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">MAY_LINK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_link</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">MAY_UNLINK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">SECCLASS_LNK_FILE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_link</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">MAY_RMDIR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode_mode_to_security_class</span><span class="p">(</span><span class="n">mode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">may_rename</span><span class="p">(</span><span class="n">old_inode</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__READ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nameidata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__READ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">audit_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">perms</span><span class="p">,</span> <span class="n">u32</span> <span class="n">audited</span><span class="p">,</span> <span class="n">u32</span> <span class="n">denied</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_INODE</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">slow_avc_audit</span><span class="p">(</span><span class="n">current_sid</span><span class="p">(),</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span>
			    <span class="n">audited</span><span class="p">,</span> <span class="n">denied</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">perms</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">from_access</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_NOT_BLOCK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">av_decision</span> <span class="n">avd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rc2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">audited</span><span class="p">,</span> <span class="n">denied</span><span class="p">;</span>

	<span class="n">from_access</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_ACCESS</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">MAY_READ</span><span class="o">|</span><span class="n">MAY_WRITE</span><span class="o">|</span><span class="n">MAY_EXEC</span><span class="o">|</span><span class="n">MAY_APPEND</span><span class="p">);</span>

	<span class="cm">/* No permission to check.  Existence test. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">validate_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_PRIVATE</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">perms</span> <span class="o">=</span> <span class="n">file_mask_to_av</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm_noaudit</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avd</span><span class="p">);</span>
	<span class="n">audited</span> <span class="o">=</span> <span class="n">avc_audit_required</span><span class="p">(</span><span class="n">perms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avd</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span>
				     <span class="n">from_access</span> <span class="o">?</span> <span class="n">FILE__AUDIT_ACCESS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">denied</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">audited</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc2</span> <span class="o">=</span> <span class="n">audit_inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">audited</span><span class="p">,</span> <span class="n">denied</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ia_valid</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">av</span> <span class="o">=</span> <span class="n">FILE__WRITE</span><span class="p">;</span>

	<span class="cm">/* ATTR_FORCE is just used for ATTR_KILL_S[UG]ID. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_FORCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATTR_KILL_SUID</span> <span class="o">|</span> <span class="n">ATTR_KILL_SGID</span> <span class="o">|</span> <span class="n">ATTR_MODE</span> <span class="o">|</span>
			      <span class="n">ATTR_FORCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia_valid</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_MODE</span> <span class="o">|</span> <span class="n">ATTR_UID</span> <span class="o">|</span> <span class="n">ATTR_GID</span> <span class="o">|</span>
			<span class="n">ATTR_ATIME_SET</span> <span class="o">|</span> <span class="n">ATTR_MTIME_SET</span> <span class="o">|</span> <span class="n">ATTR_TIMES_SET</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__SETATTR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__OPEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">path_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">FILE__GETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_setotherxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SECURITY_PREFIX</span><span class="p">,</span>
		     <span class="k">sizeof</span> <span class="n">XATTR_SECURITY_PREFIX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETFCAP</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* A different attribute in the security namespace.</span>
<span class="cm">			   Restrict to administrator. */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Not an attribute we recognize, so just check the</span>
<span class="cm">	   ordinary setattr permission. */</span>
	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__SETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_security_struct</span> <span class="o">*</span><span class="n">sbsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">selinux_inode_setotherxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">sbsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SE_SBLABELSUPP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode_owner_or_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
			  <span class="n">FILE__RELABELFROM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>
			<span class="kt">size_t</span> <span class="n">audit_size</span><span class="p">;</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

			<span class="cm">/* We strip a nul only if it is at the end, otherwise the</span>
<span class="cm">			 * context contains a nul and we should audit that */</span>
			<span class="n">str</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
				<span class="n">audit_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">audit_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">);</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;op=setxattr invalid_context=&quot;</span><span class="p">);</span>
			<span class="n">audit_log_n_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">audit_size</span><span class="p">);</span>
			<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid_force</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
			  <span class="n">FILE__RELABELTO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_validate_transition</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span>
					  <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">newsid</span><span class="p">,</span>
			    <span class="n">sbsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			    <span class="n">SECCLASS_FILESYSTEM</span><span class="p">,</span>
			    <span class="n">FILESYSTEM__ASSOCIATE</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_inode_post_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Not an attribute we recognize, so nothing to do. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid_force</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:  unable to map context to SID&quot;</span>
		       <span class="s">&quot;for (%s, %lu), rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__GETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dentry_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">FILE__GETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">selinux_inode_setotherxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/* No one is allowed to remove a SELinux security label.</span>
<span class="cm">	   You can change the label, but all data must be labeled. */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the inode security context value to the user.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission check is handled by selinux_inode_getxattr hook.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_getsecurity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bool</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SELINUX_SUFFIX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the caller has CAP_MAC_ADMIN, then get the raw context</span>
<span class="cm">	 * value even if it is not defined by current policy; otherwise,</span>
<span class="cm">	 * use the in-core value under current policy.</span>
<span class="cm">	 * Use the non-auditing forms of the permission checks since</span>
<span class="cm">	 * getxattr may be called by unprivileged processes commonly</span>
<span class="cm">	 * and lack of permission just means that we fall back to the</span>
<span class="cm">	 * in-core context value, not a denial.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">selinux_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">CAP_MAC_ADMIN</span><span class="p">,</span>
				<span class="n">SECURITY_CAP_NOAUDIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_sid_to_context_force</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nofree</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="nl">out_nofree:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_setsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SELINUX_SUFFIX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span> <span class="o">||</span> <span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_context_to_sid</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_listsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">XATTR_NAME_SELINUX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">buffer_size</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_inode_getsecid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* file security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_revalidate_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* file_mask_to_av won&#39;t add FILE__WRITE if MAY_APPEND is set */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">MAY_APPEND</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
			     <span class="n">file_mask_to_av</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
		<span class="cm">/* No permission to check.  Existence test. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">==</span> <span class="n">fsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">&amp;&amp;</span> <span class="n">fsec</span><span class="o">-&gt;</span><span class="n">isid</span> <span class="o">==</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fsec</span><span class="o">-&gt;</span><span class="n">pseqno</span> <span class="o">==</span> <span class="n">avc_policy_seqno</span><span class="p">())</span>
		<span class="cm">/* No change since file_open check. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">selinux_revalidate_file_permission</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">file_alloc_security</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_file_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file_free_security</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIONREAD</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FIBMAP</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FIGETBSZ</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FS_IOC_GETFLAGS</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FS_IOC_GETVERSION</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__GETATTR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FS_IOC_SETFLAGS</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FS_IOC_SETVERSION</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__SETATTR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* sys_ioctl() checks */</span>
	<span class="k">case</span> <span class="n">FIONBIO</span>:
	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FIOASYNC</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KDSKBENT</span>:
	<span class="k">case</span> <span class="n">KDSKBSENT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">cred_has_capability</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">CAP_SYS_TTY_CONFIG</span><span class="p">,</span>
					    <span class="n">SECURITY_CAP_AUDIT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* default case assumes that the command will go</span>
<span class="cm">	 * to the file&#39;s ioctl() function.</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__IOCTL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">default_noexec</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">file_map_prot_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">default_noexec</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">))))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are making executable an anonymous mapping or a</span>
<span class="cm">		 * private file mapping that will also be writable.</span>
<span class="cm">		 * This has an additional check.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cred_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">PROCESS__EXECMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read access is always possible with a mapping */</span>
		<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="n">FILE__READ</span><span class="p">;</span>

		<span class="cm">/* write access only matters if the mapping is shared */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">))</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__WRITE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span>
			<span class="n">av</span> <span class="o">|=</span> <span class="n">FILE__EXECUTE</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_mmap_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * notice that we are intentionally putting the SELinux check before</span>
<span class="cm">	 * the secondary cap_file_mmap check.  This is such a likely attempt</span>
<span class="cm">	 * at bad behaviour/exploit that we always want to get the AVC, even</span>
<span class="cm">	 * if DAC would have also denied the operation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">CONFIG_LSM_MMAP_MIN_ADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MEMPROTECT</span><span class="p">,</span>
				  <span class="n">MEMPROTECT__MMAP_ZERO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do DAC check on address space usage */</span>
	<span class="k">return</span> <span class="n">cap_mmap_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_checkreqprot</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">=</span> <span class="n">reqprot</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">file_map_prot_check</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_TYPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">MAP_SHARED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_mprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_checkreqprot</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">=</span> <span class="n">reqprot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">default_noexec</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cred_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">PROCESS__EXECHEAP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span>
			   <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">&amp;&amp;</span>
			   <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">PROCESS__EXECSTACK</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We are making executable a file mapping that has</span>
<span class="cm">			 * had some COW done. Since pages might have been</span>
<span class="cm">			 * written, check ability to execute the possibly</span>
<span class="cm">			 * modified content.  This typically should only</span>
<span class="cm">			 * occur for text relocations.</span>
<span class="cm">			 */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">FILE__EXECMOD</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">file_map_prot_check</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="o">&amp;</span><span class="n">VM_SHARED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__LOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_fcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_SETFL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__WRITE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">F_SETOWN</span>:
	<span class="k">case</span> <span class="n">F_SETSIG</span>:
	<span class="k">case</span> <span class="n">F_GETFL</span>:
	<span class="k">case</span> <span class="n">F_GETOWN</span>:
	<span class="k">case</span> <span class="n">F_GETSIG</span>:
		<span class="cm">/* Just check FD__USE permission */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">F_GETLK</span>:
	<span class="k">case</span> <span class="n">F_SETLK</span>:
	<span class="k">case</span> <span class="n">F_SETLKW</span>:
<span class="cp">#if BITS_PER_LONG == 32</span>
	<span class="k">case</span> <span class="n">F_GETLK64</span>:
	<span class="k">case</span> <span class="n">F_SETLK64</span>:
	<span class="k">case</span> <span class="n">F_SETLKW64</span>:
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">FILE__LOCK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_set_fowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span><span class="p">;</span>

	<span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>
	<span class="n">fsec</span><span class="o">-&gt;</span><span class="n">fown_sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_send_sigiotask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">perm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span><span class="p">;</span>

	<span class="cm">/* struct fown_struct is never outside the context of a struct file */</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fown</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span><span class="p">,</span> <span class="n">f_owner</span><span class="p">);</span>

	<span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signum</span><span class="p">)</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">signal_to_av</span><span class="p">(</span><span class="n">SIGIO</span><span class="p">);</span> <span class="cm">/* as per send_sigio_to_task */</span>
	<span class="k">else</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">signal_to_av</span><span class="p">(</span><span class="n">signum</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">fsec</span><span class="o">-&gt;</span><span class="n">fown_sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span>
			    <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">file_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">file_to_av</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_security_struct</span> <span class="o">*</span><span class="n">fsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>

	<span class="n">fsec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">;</span>
	<span class="n">isec</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Save inode label and policy sequence number</span>
<span class="cm">	 * at open-time so that selinux_file_permission</span>
<span class="cm">	 * can determine whether revalidation is necessary.</span>
<span class="cm">	 * Task label is already saved in the file security</span>
<span class="cm">	 * struct as its SID.</span>
<span class="cm">	 */</span>
	<span class="n">fsec</span><span class="o">-&gt;</span><span class="n">isid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">fsec</span><span class="o">-&gt;</span><span class="n">pseqno</span> <span class="o">=</span> <span class="n">avc_policy_seqno</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since the inode label or policy seqno may have changed</span>
<span class="cm">	 * between the selinux_inode_permission check and the saving</span>
<span class="cm">	 * of state above, recheck that access is still permitted.</span>
<span class="cm">	 * Otherwise, access might never be revalidated against the</span>
<span class="cm">	 * new inode label or new policy.</span>
<span class="cm">	 * This check is not redundant - do not remove.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">path_has_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">open_file_to_av</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* task security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">PROCESS__FORK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate the SELinux part of blank credentials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_cred_alloc_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>

	<span class="n">tsec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_security_struct</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsec</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * detach and free the LSM part of a set of credentials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_cred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cred-&gt;security == NULL if security_cred_alloc_blank() or</span>
<span class="cm">	 * security_prepare_creds() returned an error.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x7UL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prepare a new set of credentials for modification</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_cred_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">old_tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>

	<span class="n">old_tsec</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">tsec</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">old_tsec</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_security_struct</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsec</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * transfer the SELinux data to a blank set of creds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_cred_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">old_tsec</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_tsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set the security data for a kernel service</span>
<span class="cm"> * - all the creation contexts are set to unlabelled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_kernel_act_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">secid</span><span class="p">,</span>
			   <span class="n">SECCLASS_KERNEL_SERVICE</span><span class="p">,</span>
			   <span class="n">KERNEL_SERVICE__USE_AS_OVERRIDE</span><span class="p">,</span>
			   <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">secid</span><span class="p">;</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set the file creation context in a security record to the same as the</span>
<span class="cm"> * objective context of the specified inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_kernel_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			   <span class="n">SECCLASS_KERNEL_SERVICE</span><span class="p">,</span>
			   <span class="n">KERNEL_SERVICE__CREATE_FILES_AS</span><span class="p">,</span>
			   <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_kernel_module_request</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kmod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_KMOD</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">kmod_name</span> <span class="o">=</span> <span class="n">kmod_name</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECINITSID_KERNEL</span><span class="p">,</span> <span class="n">SECCLASS_SYSTEM</span><span class="p">,</span>
			    <span class="n">SYSTEM__MODULE_REQUEST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_setpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETPGID</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_getpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__GETPGID</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_getsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__GETSESSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_task_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setnice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setioprio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ioprio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_getioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__GETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_setrlimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_rlim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">old_rlim</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span> <span class="o">+</span> <span class="n">resource</span><span class="p">;</span>

	<span class="cm">/* Control the ability to change the hard limit (whether</span>
<span class="cm">	   lowering or raising it), so that the hard limit can</span>
<span class="cm">	   later be used as a safe reset point for the soft limit</span>
<span class="cm">	   upon context transitions.  See selinux_bprm_committing_creds. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_rlim</span><span class="o">-&gt;</span><span class="n">rlim_max</span> <span class="o">!=</span> <span class="n">new_rlim</span><span class="o">-&gt;</span><span class="n">rlim_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETRLIMIT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_getscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__GETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_movememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETSCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">perm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">PROCESS__SIGNULL</span><span class="p">;</span> <span class="cm">/* null signal; existence test */</span>
	<span class="k">else</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">signal_to_av</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secid</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
				  <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_task_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">PROCESS__SIGCHLD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_task_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns error only if unable to parse addresses */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_parse_skb_ipv4</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ihlen</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="n">_iph</span><span class="p">,</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_iph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_iph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ihlen</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_iph</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span>
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcphdr</span> <span class="n">_tcph</span><span class="p">,</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">frag_off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IP_OFFSET</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ihlen</span><span class="p">;</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_tcph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_tcph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">udphdr</span> <span class="n">_udph</span><span class="p">,</span> <span class="o">*</span><span class="n">uh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">frag_off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IP_OFFSET</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ihlen</span><span class="p">;</span>
		<span class="n">uh</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_udph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_udph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">IPPROTO_DCCP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="n">_dccph</span><span class="p">,</span> <span class="o">*</span><span class="n">dh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">frag_off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IP_OFFSET</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ihlen</span><span class="p">;</span>
		<span class="n">dh</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_dccph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_dccph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>

<span class="cm">/* Returns error only if unable to parse addresses */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_parse_skb_ipv6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">nexthdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="n">_ipv6h</span><span class="p">,</span> <span class="o">*</span><span class="n">ip6</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">frag_off</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ip6</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ipv6h</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_ipv6h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip6</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v6info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">ip6</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v6info</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">ip6</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nexthdr</span> <span class="o">=</span> <span class="n">ip6</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ipv6h</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ipv6_skip_exthdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nexthdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frag_off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span>
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">nexthdr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nexthdr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcphdr</span> <span class="n">_tcph</span><span class="p">,</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

		<span class="n">th</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_tcph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_tcph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">udphdr</span> <span class="n">_udph</span><span class="p">,</span> <span class="o">*</span><span class="n">uh</span><span class="p">;</span>

		<span class="n">uh</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_udph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_udph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">IPPROTO_DCCP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="n">_dccph</span><span class="p">,</span> <span class="o">*</span><span class="n">dh</span><span class="p">;</span>

		<span class="n">dh</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_dccph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_dccph</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span><span class="p">;</span>
		<span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* includes fragments */</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* IPV6 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_parse_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">**</span><span class="n">_addrp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_INET</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">selinux_parse_skb_ipv4</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">proto</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">parse_error</span><span class="p">;</span>
		<span class="n">addrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">src</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">:</span>
				       <span class="o">&amp;</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">daddr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">okay</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
	<span class="k">case</span> <span class="n">PF_INET6</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">selinux_parse_skb_ipv6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">proto</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">parse_error</span><span class="p">;</span>
		<span class="n">addrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">src</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v6info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">:</span>
				       <span class="o">&amp;</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v6info</span><span class="p">.</span><span class="n">daddr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">okay</span><span class="p">;</span>
<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">addrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">okay</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">parse_error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	       <span class="s">&quot;SELinux: failure in selinux_parse_skb(),&quot;</span>
	       <span class="s">&quot; unable to parse packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">okay:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_addrp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">_addrp</span> <span class="o">=</span> <span class="n">addrp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * selinux_skb_peerlbl_sid - Determine the peer label of a packet</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @sid: the packet&#39;s peer label SID</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Check the various different forms of network peer labeling and determine</span>
<span class="cm"> * the peer label/SID for the packet; most of the magic actually occurs in</span>
<span class="cm"> * the security server function security_net_peersid_cmp().  The function</span>
<span class="cm"> * returns zero if the value in @sid is valid (although it may be SECSID_NULL)</span>
<span class="cm"> * or -EACCES if @sid is invalid due to inconsistencies with the different</span>
<span class="cm"> * peer labels.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">family</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">xfrm_sid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nlbl_sid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nlbl_type</span><span class="p">;</span>

	<span class="n">selinux_skb_xfrm_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xfrm_sid</span><span class="p">);</span>
	<span class="n">selinux_netlbl_skbuff_getsid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlbl_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlbl_sid</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_net_peersid_resolve</span><span class="p">(</span><span class="n">nlbl_sid</span><span class="p">,</span> <span class="n">nlbl_type</span><span class="p">,</span> <span class="n">xfrm_sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;SELinux: failure in selinux_skb_peerlbl_sid(),&quot;</span>
		       <span class="s">&quot; unable to determine packet&#39;s peer label</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* socket security operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">socket_sockcreate_sid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="n">secclass</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">socksid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span> <span class="o">&gt;</span> <span class="n">SECSID_NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">socksid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">secclass</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				       <span class="n">socksid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_has_perm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="n">u32</span> <span class="n">tsid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">==</span> <span class="n">SECINITSID_KERNEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsid</span><span class="p">,</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">secclass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kern</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">secclass</span> <span class="o">=</span> <span class="n">socket_type_to_security_class</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">socket_sockcreate_sid</span><span class="p">(</span><span class="n">tsec</span><span class="p">,</span> <span class="n">secclass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">secclass</span><span class="p">,</span> <span class="n">SOCKET__CREATE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">socket_type_to_security_class</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kern</span><span class="p">)</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_KERNEL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">socket_sockcreate_sid</span><span class="p">(</span><span class="n">tsec</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sksec</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
		<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_netlbl_socket_post_create</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Range of port numbers used to automatically bind.</span>
<span class="cm">   Need to determine whether we should perform a name_bind</span>
<span class="cm">   permission check between the socket and the port number. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">family</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__BIND</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If PF_INET or PF_INET6, check name_bind permission for the port.</span>
<span class="cm">	 * Multiple address binding for SCTP is not supported yet: we just</span>
<span class="cm">	 * check the first address now.</span>
<span class="cm">	 */</span>
	<span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">||</span> <span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
		<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">addr4</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">addr6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">node_perm</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr4</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr4</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">);</span>
			<span class="n">addrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr4</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">addr6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">sin6_port</span><span class="p">);</span>
			<span class="n">addrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snum</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>

			<span class="n">inet_get_local_port_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">high</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">snum</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">PROT_SOCK</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span> <span class="o">||</span> <span class="n">snum</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">sel_netport_sid</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span>
						      <span class="n">snum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
				<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
				<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">snum</span><span class="p">);</span>
				<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span>
						   <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
						   <span class="n">SOCKET__NAME_BIND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SECCLASS_TCP_SOCKET</span>:
			<span class="n">node_perm</span> <span class="o">=</span> <span class="n">TCP_SOCKET__NODE_BIND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SECCLASS_UDP_SOCKET</span>:
			<span class="n">node_perm</span> <span class="o">=</span> <span class="n">UDP_SOCKET__NODE_BIND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SECCLASS_DCCP_SOCKET</span>:
			<span class="n">node_perm</span> <span class="o">=</span> <span class="n">DCCP_SOCKET__NODE_BIND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">node_perm</span> <span class="o">=</span> <span class="n">RAWIP_SOCKET__NODE_BIND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sel_netnode_sid</span><span class="p">(</span><span class="n">addrp</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">snum</span><span class="p">);</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET</span><span class="p">)</span>
			<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v6info</span><span class="p">.</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">addr6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span>
				   <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">node_perm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__CONNECT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a TCP or DCCP socket, check name_connect permission for the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_TCP_SOCKET</span> <span class="o">||</span>
	    <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_DCCP_SOCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
		<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">addr4</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">addr6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">perm</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr4</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr4</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">addr6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">&lt;</span> <span class="n">SIN6_LEN_RFC2133</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">sin6_port</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sel_netport_sid</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span> <span class="n">snum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">perm</span> <span class="o">=</span> <span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_TCP_SOCKET</span><span class="p">)</span> <span class="o">?</span>
		       <span class="n">TCP_SOCKET__NAME_CONNECT</span> <span class="o">:</span> <span class="n">DCCP_SOCKET__NAME_CONNECT</span><span class="p">;</span>

		<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">snum</span><span class="p">);</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_netlbl_socket_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__LISTEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">newisec</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__ACCEPT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">newisec</span> <span class="o">=</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">newsock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">newisec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">;</span>
	<span class="n">newisec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">newisec</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__READ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_getsockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__GETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_getpeername</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__GETATTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__SETOPT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">selinux_netlbl_socket_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__GETOPT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCKET__SHUTDOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec_sock</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec_new</span> <span class="o">=</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sksec_sock</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sksec_other</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			   <span class="n">sksec_other</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span>
			   <span class="n">UNIX_STREAM_SOCKET__CONNECTTO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* server child socket */</span>
	<span class="n">sksec_new</span><span class="o">-&gt;</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">sksec_sock</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sid_mls_copy</span><span class="p">(</span><span class="n">sksec_other</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sksec_sock</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">sksec_new</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* connecting socket */</span>
	<span class="n">sksec_sock</span><span class="o">-&gt;</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">sksec_new</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">ssec</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">osec</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">ssec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">osec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">osec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">SOCKET__SENDTO</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inet_sys_rcv_skb</span><span class="p">(</span><span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">peer_sid</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">common_audit_data</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">if_sid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_sid</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sel_netif_sid</span><span class="p">(</span><span class="n">ifindex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">if_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">if_sid</span><span class="p">,</span>
			   <span class="n">SECCLASS_NETIF</span><span class="p">,</span> <span class="n">NETIF__INGRESS</span><span class="p">,</span> <span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sel_netnode_sid</span><span class="p">(</span><span class="n">addrp</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">node_sid</span><span class="p">,</span>
			    <span class="n">SECCLASS_NODE</span><span class="p">,</span> <span class="n">NODE__RECVFROM</span><span class="p">,</span> <span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sock_rcv_skb_compat</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sk_sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_parse_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_secmark_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sk_sid</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">,</span> <span class="n">SECCLASS_PACKET</span><span class="p">,</span>
				   <span class="n">PACKET__RECV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_netlbl_sock_rcv_skb</span><span class="p">(</span><span class="n">sksec</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_xfrm_sock_rcv_skb</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_sock_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sk_sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">secmark_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">peerlbl_active</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">!=</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">family</span> <span class="o">!=</span> <span class="n">PF_INET6</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Handle mapped IPv4 packets arriving via IPv6 sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>

	<span class="cm">/* If any sort of compatibility mode is enabled then handoff processing</span>
<span class="cm">	 * to the selinux_sock_rcv_skb_compat() function to deal with the</span>
<span class="cm">	 * special handling.  We do this in an attempt to keep this function</span>
<span class="cm">	 * as fast and as clean as possible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_policycap_netpeer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">selinux_sock_rcv_skb_compat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>

	<span class="n">secmark_active</span> <span class="o">=</span> <span class="n">selinux_secmark_enabled</span><span class="p">();</span>
	<span class="n">peerlbl_active</span> <span class="o">=</span> <span class="n">netlbl_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="n">selinux_xfrm_enabled</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secmark_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">peerlbl_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_parse_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peerlbl_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">peer_sid</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer_sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_inet_sys_rcv_skb</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">,</span> <span class="n">addrp</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span>
					       <span class="n">peer_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">selinux_netlbl_err</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sk_sid</span><span class="p">,</span> <span class="n">peer_sid</span><span class="p">,</span> <span class="n">SECCLASS_PEER</span><span class="p">,</span>
				   <span class="n">PEER__RECV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">selinux_netlbl_err</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secmark_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sk_sid</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">,</span> <span class="n">SECCLASS_PACKET</span><span class="p">,</span>
				   <span class="n">PACKET__RECV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_getpeersec_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scontext_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peer_sid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_UNIX_STREAM_SOCKET</span> <span class="o">||</span>
	    <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">==</span> <span class="n">SECCLASS_TCP_SOCKET</span><span class="p">)</span>
		<span class="n">peer_sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer_sid</span> <span class="o">==</span> <span class="n">SECSID_NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontext_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scontext_len</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out_len:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">scontext_len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">scontext</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_socket_getpeersec_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">peer_secid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">family</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">&amp;&amp;</span> <span class="n">family</span> <span class="o">==</span> <span class="n">PF_UNIX</span><span class="p">)</span>
		<span class="n">selinux_inode_getsecid</span><span class="p">(</span><span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">peer_secid</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer_secid</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">peer_secid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer_secid</span> <span class="o">==</span> <span class="n">SECSID_NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sk_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span><span class="p">;</span>

	<span class="n">sksec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sksec</span><span class="p">),</span> <span class="n">priority</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sksec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">selinux_netlbl_sk_security_reset</span><span class="p">(</span><span class="n">sksec</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span> <span class="o">=</span> <span class="n">sksec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sk_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">selinux_netlbl_sk_security_free</span><span class="p">(</span><span class="n">sksec</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sksec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sk_clone_security</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">newsksec</span> <span class="o">=</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="n">newsksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">newsksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span><span class="p">;</span>
	<span class="n">newsksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">;</span>

	<span class="n">selinux_netlbl_sk_security_reset</span><span class="p">(</span><span class="n">newsksec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sk_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">SECINITSID_ANY_SOCKET</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

		<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET6</span> <span class="o">||</span>
	    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_UNIX</span><span class="p">)</span>
		<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inet_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">newsid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peersid</span><span class="p">;</span>

	<span class="cm">/* handle mapped IPv4 packets arriving via IPv6 sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peersid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peersid</span> <span class="o">==</span> <span class="n">SECSID_NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_sid_mls_copy</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">peersid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="n">newsid</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span> <span class="o">=</span> <span class="n">peersid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">selinux_netlbl_inet_conn_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_inet_csk_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">newsksec</span> <span class="o">=</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="n">newsksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
	<span class="n">newsksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span><span class="p">;</span>
	<span class="cm">/* NOTE: Ideally, we should also get the isec-&gt;sid for the</span>
<span class="cm">	   new socket in sync, but we don&#39;t have the isec available yet.</span>
<span class="cm">	   So we will wait until sock_graft to do it, by which</span>
<span class="cm">	   time it will have been created and available. */</span>

	<span class="cm">/* We don&#39;t need to take any sort of lock here as we are the only</span>
<span class="cm">	 * thread with access to newsksec */</span>
	<span class="n">selinux_netlbl_inet_csk_clone</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_inet_conn_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="cm">/* handle mapped IPv4 packets arriving via IPv6 sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>

	<span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">peer_sid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_secmark_relabel_packet</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">__tsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsid</span><span class="p">;</span>

	<span class="n">__tsec</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="n">tsid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_PACKET</span><span class="p">,</span> <span class="n">PACKET__RELABELTO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_secmark_refcount_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selinux_secmark_refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_secmark_refcount_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selinux_secmark_refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_req_classify_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">flowi_secid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_tun_dev_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="cm">/* we aren&#39;t taking into account the &quot;sockcreate&quot; SID since the socket</span>
<span class="cm">	 * that is being created here is not a socket in the traditional sense,</span>
<span class="cm">	 * instead it is a private sock, accessible only to the kernel, and</span>
<span class="cm">	 * representing a wide range of network traffic spanning multiple</span>
<span class="cm">	 * connections unlike traditional sockets - check the TUN driver to</span>
<span class="cm">	 * get a better understanding of why this socket is special */</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_TUN_SOCKET</span><span class="p">,</span> <span class="n">TUN_SOCKET__CREATE</span><span class="p">,</span>
			    <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_tun_dev_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t currently perform any NetLabel based labeling here and it</span>
<span class="cm">	 * isn&#39;t clear that we would want to do so anyway; while we could apply</span>
<span class="cm">	 * labeling without the support of the TUN user the resulting labeled</span>
<span class="cm">	 * traffic from the other end of the connection would almost certainly</span>
<span class="cm">	 * cause confusion to the TUN user that had no idea network labeling</span>
<span class="cm">	 * protocols were being used */</span>

	<span class="cm">/* see the comments in selinux_tun_dev_create() about why we don&#39;t use</span>
<span class="cm">	 * the sockcreate SID here */</span>

	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">SECCLASS_TUN_SOCKET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_tun_dev_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_TUN_SOCKET</span><span class="p">,</span>
			   <span class="n">TUN_SOCKET__RELABELFROM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_TUN_SOCKET</span><span class="p">,</span>
			   <span class="n">TUN_SOCKET__RELABELTO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_nlmsg_perm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">perm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_nlmsg_lookup</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">perm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
				  <span class="s">&quot;SELinux:  unrecognized netlink message&quot;</span>
				  <span class="s">&quot; type=%hu for sclass=%hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">,</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_enforcing</span> <span class="o">||</span> <span class="n">security_get_allow_unknown</span><span class="p">())</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ignore */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_has_perm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NETFILTER</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ip_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peer_sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="n">u8</span> <span class="n">secmark_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">netlbl_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">peerlbl_active</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_policycap_netpeer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">secmark_active</span> <span class="o">=</span> <span class="n">selinux_secmark_enabled</span><span class="p">();</span>
	<span class="n">netlbl_active</span> <span class="o">=</span> <span class="n">netlbl_enabled</span><span class="p">();</span>
	<span class="n">peerlbl_active</span> <span class="o">=</span> <span class="n">netlbl_active</span> <span class="o">||</span> <span class="n">selinux_xfrm_enabled</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secmark_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">peerlbl_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer_sid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_parse_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peerlbl_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">selinux_inet_sys_rcv_skb</span><span class="p">(</span><span class="n">ifindex</span><span class="p">,</span> <span class="n">addrp</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span>
					       <span class="n">peer_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">selinux_netlbl_err</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secmark_active</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">,</span>
				 <span class="n">SECCLASS_PACKET</span><span class="p">,</span> <span class="n">PACKET__FORWARD_IN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_active</span><span class="p">)</span>
		<span class="cm">/* we do this in the FORWARD path and not the POST_ROUTING</span>
<span class="cm">		 * path because we want to make sure we apply the necessary</span>
<span class="cm">		 * labeling before IPsec is applied so we can leverage AH</span>
<span class="cm">		 * protection */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">selinux_netlbl_skbuff_setsid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">peer_sid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ipv4_forward</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_ip_forward</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ipv6_forward</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_ip_forward</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">,</span> <span class="n">PF_INET6</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ip_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netlbl_enabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* we do this in the LOCAL_OUT path and not the POST_ROUTING path</span>
<span class="cm">	 * because we want to make sure we apply the necessary labeling</span>
<span class="cm">	 * before IPsec is applied so we can leverage AH protection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_KERNEL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_netlbl_skbuff_setsid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ipv4_output</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_ip_output</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ip_postroute_compat</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span>
						<span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">proto</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_parse_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_secmark_enabled</span><span class="p">())</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">,</span>
				 <span class="n">SECCLASS_PACKET</span><span class="p">,</span> <span class="n">PACKET__SEND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP_ERR</span><span class="p">(</span><span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_xfrm_postroute_last</span><span class="p">(</span><span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">proto</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP_ERR</span><span class="p">(</span><span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ip_postroute</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">secmark_perm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peer_sid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addrp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">secmark_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">peerlbl_active</span><span class="p">;</span>

	<span class="cm">/* If any sort of compatibility mode is enabled then handoff processing</span>
<span class="cm">	 * to the selinux_ip_postroute_compat() function to deal with the</span>
<span class="cm">	 * special handling.  We do this in an attempt to keep this function</span>
<span class="cm">	 * as fast and as clean as possible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_policycap_netpeer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">selinux_ip_postroute_compat</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="cm">/* If skb-&gt;dst-&gt;xfrm is non-NULL then the packet is undergoing an IPsec</span>
<span class="cm">	 * packet transformation so allow the packet to pass without any checks</span>
<span class="cm">	 * since we&#39;ll have another chance to perform access control checks</span>
<span class="cm">	 * when the packet is on it&#39;s final way out.</span>
<span class="cm">	 * NOTE: there appear to be some IPv6 multicast cases where skb-&gt;dst</span>
<span class="cm">	 *       is NULL, in this case go ahead and apply access control. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xfrm</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">secmark_active</span> <span class="o">=</span> <span class="n">selinux_secmark_enabled</span><span class="p">();</span>
	<span class="n">peerlbl_active</span> <span class="o">=</span> <span class="n">netlbl_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="n">selinux_xfrm_enabled</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secmark_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">peerlbl_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* if the packet is being forwarded then get the peer label from the</span>
<span class="cm">	 * packet itself; otherwise check to see if it is from a local</span>
<span class="cm">	 * application or the kernel, if from an application get the peer label</span>
<span class="cm">	 * from the sending socket, otherwise use the kernel&#39;s sid */</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">secmark_perm</span> <span class="o">=</span> <span class="n">PACKET__FORWARD_OUT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selinux_skb_peerlbl_sid</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer_sid</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">secmark_perm</span> <span class="o">=</span> <span class="n">PACKET__SEND</span><span class="p">;</span>
			<span class="n">peer_sid</span> <span class="o">=</span> <span class="n">SECINITSID_KERNEL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_security_struct</span> <span class="o">*</span><span class="n">sksec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="n">peer_sid</span> <span class="o">=</span> <span class="n">sksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
		<span class="n">secmark_perm</span> <span class="o">=</span> <span class="n">PACKET__SEND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_parse_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secmark_active</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">,</span>
				 <span class="n">SECCLASS_PACKET</span><span class="p">,</span> <span class="n">secmark_perm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP_ERR</span><span class="p">(</span><span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peerlbl_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">if_sid</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">node_sid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sel_netif_sid</span><span class="p">(</span><span class="n">ifindex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">if_sid</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">if_sid</span><span class="p">,</span>
				 <span class="n">SECCLASS_NETIF</span><span class="p">,</span> <span class="n">NETIF__EGRESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP_ERR</span><span class="p">(</span><span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sel_netnode_sid</span><span class="p">(</span><span class="n">addrp</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_sid</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avc_has_perm</span><span class="p">(</span><span class="n">peer_sid</span><span class="p">,</span> <span class="n">node_sid</span><span class="p">,</span>
				 <span class="n">SECCLASS_NODE</span><span class="p">,</span> <span class="n">NODE__SENDTO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_DROP_ERR</span><span class="p">(</span><span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ipv4_postroute</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_ip_postroute</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">selinux_ipv6_postroute</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_ip_postroute</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">,</span> <span class="n">PF_INET6</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_NETFILTER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_netlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cap_netlink_send</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">selinux_nlmsg_perm</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipc_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">perm</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">sclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span> <span class="o">=</span> <span class="n">sclass</span><span class="p">;</span>
	<span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">perm</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">isec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipc_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">perm</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="n">perm</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">isec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msg_msg_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msg_security_struct</span> <span class="o">*</span><span class="n">msec</span><span class="p">;</span>

	<span class="n">msec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">msec</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msg_msg_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msg_security_struct</span> <span class="o">*</span><span class="n">msec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipc_has_perm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipc_perms</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">ipc_perms</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">ipc_perms</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sclass</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_msg_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">msg_msg_alloc_security</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_msg_msg_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg_msg_free_security</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* message queue security operations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_queue_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ipc_alloc_security</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">,</span> <span class="n">SECCLASS_MSGQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSGQ</span><span class="p">,</span>
			  <span class="n">MSGQ__CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_msg_queue_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_queue_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSGQ</span><span class="p">,</span>
			    <span class="n">MSGQ__ASSOCIATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_queue_msgctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">perms</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">MSG_INFO</span>:
		<span class="cm">/* No specific object, just general system-wide information. */</span>
		<span class="k">return</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__IPC_INFO</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">MSG_STAT</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">MSGQ__GETATTR</span> <span class="o">|</span> <span class="n">MSGQ__ASSOCIATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">MSGQ__SETATTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">MSGQ__DESTROY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">,</span> <span class="n">perms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_queue_msgsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_security_struct</span> <span class="o">*</span><span class="n">msec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>
	<span class="n">msec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First time through, need to assign label to the message</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">==</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute new sid based on current process and</span>
<span class="cm">		 * message queue this message will be stored in</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_transition_sid</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSG</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="cm">/* Can this process write to the queue? */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSGQ</span><span class="p">,</span>
			  <span class="n">MSGQ__WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="cm">/* Can this process send the message */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSG</span><span class="p">,</span>
				  <span class="n">MSG__SEND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="cm">/* Can the message be put in the queue? */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_MSGQ</span><span class="p">,</span>
				  <span class="n">MSGQ__ENQUEUE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_msg_queue_msgrcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
				    <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_security_struct</span> <span class="o">*</span><span class="n">msec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>
	<span class="n">msec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
			  <span class="n">SECCLASS_MSGQ</span><span class="p">,</span> <span class="n">MSGQ__READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">msec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span>
				  <span class="n">SECCLASS_MSG</span><span class="p">,</span> <span class="n">MSG__RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Shared Memory security operations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_shm_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ipc_alloc_security</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">,</span> <span class="n">SECCLASS_SHM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_SHM</span><span class="p">,</span>
			  <span class="n">SHM__CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_shm_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_shm_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_SHM</span><span class="p">,</span>
			    <span class="n">SHM__ASSOCIATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Note, at this point, shp is locked down */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_shm_shmctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">perms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SHM_INFO</span>:
		<span class="cm">/* No specific object, just general system-wide information. */</span>
		<span class="k">return</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__IPC_INFO</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SHM_STAT</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__GETATTR</span> <span class="o">|</span> <span class="n">SHM__ASSOCIATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__SETATTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHM_LOCK</span>:
	<span class="k">case</span> <span class="n">SHM_UNLOCK</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__LOCK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__DESTROY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">,</span> <span class="n">perms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_shm_shmat</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">perms</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shmflg</span> <span class="o">&amp;</span> <span class="n">SHM_RDONLY</span><span class="p">)</span>
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__READ</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SHM__READ</span> <span class="o">|</span> <span class="n">SHM__WRITE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">,</span> <span class="n">perms</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Semaphore security operations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sem_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ipc_alloc_security</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">SECCLASS_SEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_SEM</span><span class="p">,</span>
			  <span class="n">SEM__CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_sem_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_free_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sem_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">ad</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">current_sid</span><span class="p">();</span>

	<span class="n">isec</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>

	<span class="n">ad</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_SEM</span><span class="p">,</span>
			    <span class="n">SEM__ASSOCIATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Note, at this point, sma is locked down */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sem_semctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">perms</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SEM_INFO</span>:
		<span class="cm">/* No specific object, just general system-wide information. */</span>
		<span class="k">return</span> <span class="n">task_has_system</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SYSTEM__IPC_INFO</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">GETPID</span>:
	<span class="k">case</span> <span class="n">GETNCNT</span>:
	<span class="k">case</span> <span class="n">GETZCNT</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__GETATTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GETVAL</span>:
	<span class="k">case</span> <span class="n">GETALL</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__READ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SETVAL</span>:
	<span class="k">case</span> <span class="n">SETALL</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__WRITE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__DESTROY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__SETATTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SEM_STAT</span>:
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__GETATTR</span> <span class="o">|</span> <span class="n">SEM__ASSOCIATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">perms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_sem_semop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">perms</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alter</span><span class="p">)</span>
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__READ</span> <span class="o">|</span> <span class="n">SEM__WRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">perms</span> <span class="o">=</span> <span class="n">SEM__READ</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">perms</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_ipc_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="kt">short</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">av</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">av</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">S_IRUGO</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">IPC__UNIX_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">S_IWUGO</span><span class="p">)</span>
		<span class="n">av</span> <span class="o">|=</span> <span class="n">IPC__UNIX_WRITE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ipc_has_perm</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_ipc_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_security_struct</span> <span class="o">*</span><span class="n">isec</span> <span class="o">=</span> <span class="n">ipcp</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">isec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">inode_doinit_with_dentry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_getprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">__tsec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__GETATTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">__tsec</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;current&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;prev&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">osid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;exec&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">exec_sid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;fscreate&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;keycreate&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sockcreate&quot;</span><span class="p">))</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">__tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">invalid:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_setprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tracer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptsid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SELinux only allows a process to change its own</span>
<span class="cm">		   security attributes. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Basic control over ability to set these attributes at all.</span>
<span class="cm">	 * current == p, but we&#39;ll pass them separately in case the</span>
<span class="cm">	 * above restriction is ever removed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;exec&quot;</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETEXEC</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;fscreate&quot;</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETFSCREATE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;keycreate&quot;</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETKEYCREATE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sockcreate&quot;</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETSOCKCREATE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;current&quot;</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">current_has_perm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PROCESS__SETCURRENT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Obtain a SID for the context, if one was specified. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">str</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">size</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_context_to_sid</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;fscreate&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>
				<span class="kt">size_t</span> <span class="n">audit_size</span><span class="p">;</span>

				<span class="cm">/* We strip a nul only if it is at the end, otherwise the</span>
<span class="cm">				 * context contains a nul and we should audit that */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
					<span class="n">audit_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">audit_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">);</span>
				<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;op=fscreate invalid_context=&quot;</span><span class="p">);</span>
				<span class="n">audit_log_n_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">audit_size</span><span class="p">);</span>
				<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">security_context_to_sid_force</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Permission checking based on the specified context is</span>
<span class="cm">	   performed during the actual operation (execve,</span>
<span class="cm">	   open/mkdir/...), when we know the full context of the</span>
<span class="cm">	   operation.  See selinux_bprm_set_creds for the execve</span>
<span class="cm">	   checks and may_create for the file creation checks. The</span>
<span class="cm">	   operation will then fail if the context is not permitted. */</span>
	<span class="n">tsec</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;exec&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">exec_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;fscreate&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">create_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;keycreate&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">may_create_key</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sockcreate&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sockcreate_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;current&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>

		<span class="cm">/* Only allow single threaded processes to change context */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_is_single_threaded</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">security_bounded_transition</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check permissions for the transition. */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span>
				     <span class="n">PROCESS__DYNTRANSITION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>

		<span class="cm">/* Check for ptracing, and update the task SID if ok.</span>
<span class="cm">		   Otherwise, leave SID unchanged and fail. */</span>
		<span class="n">ptsid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tracer</span> <span class="o">=</span> <span class="n">ptrace_parent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tracer</span><span class="p">)</span>
			<span class="n">ptsid</span> <span class="o">=</span> <span class="n">task_sid</span><span class="p">(</span><span class="n">tracer</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tracer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">ptsid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_PROCESS</span><span class="p">,</span>
					     <span class="n">PROCESS__PTRACE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_change</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">abort_change:</span>
	<span class="n">abort_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_secid_to_secctx</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span> <span class="n">secdata</span><span class="p">,</span> <span class="n">seclen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_secctx_to_secid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_context_to_sid</span><span class="p">(</span><span class="n">secdata</span><span class="p">,</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">secid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_release_secctx</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">secdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	called with inode-&gt;i_mutex locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_notifysecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">selinux_inode_setsecurity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">XATTR_SELINUX_SUFFIX</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctxlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	called with inode-&gt;i_mutex locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_setsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vfs_setxattr_noperm</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_SELINUX</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctxlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_inode_getsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">selinux_inode_getsecurity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">XATTR_SELINUX_SUFFIX</span><span class="p">,</span>
						<span class="n">ctx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ctxlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_KEYS</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">task_security_struct</span> <span class="o">*</span><span class="n">tsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key_security_struct</span> <span class="o">*</span><span class="n">ksec</span><span class="p">;</span>

	<span class="n">ksec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_security_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ksec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tsec</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span><span class="p">)</span>
		<span class="n">ksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">keycreate_sid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ksec</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">tsec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>

	<span class="n">k</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">ksec</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_key_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_security_struct</span> <span class="o">*</span><span class="n">ksec</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">k</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ksec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_key_permission</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				  <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key_security_struct</span> <span class="o">*</span><span class="n">ksec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

	<span class="cm">/* if no specific permissions are requested, we skip the</span>
<span class="cm">	   permission check. No serious, additional covert channels</span>
<span class="cm">	   appear to be created. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">perm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">cred_sid</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="n">ksec</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">avc_has_perm</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">ksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="n">SECCLASS_KEY</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_key_getsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_security_struct</span> <span class="o">*</span><span class="n">ksec</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_sid_to_context</span><span class="p">(</span><span class="n">ksec</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">security_operations</span> <span class="n">selinux_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>				<span class="s">&quot;selinux&quot;</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ptrace_access_check</span> <span class="o">=</span>		<span class="n">selinux_ptrace_access_check</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ptrace_traceme</span> <span class="o">=</span>		<span class="n">selinux_ptrace_traceme</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capget</span> <span class="o">=</span>			<span class="n">selinux_capget</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capset</span> <span class="o">=</span>			<span class="n">selinux_capset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capable</span> <span class="o">=</span>			<span class="n">selinux_capable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">quotactl</span> <span class="o">=</span>			<span class="n">selinux_quotactl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">quota_on</span> <span class="o">=</span>			<span class="n">selinux_quota_on</span><span class="p">,</span>
	<span class="p">.</span><span class="n">syslog</span> <span class="o">=</span>			<span class="n">selinux_syslog</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vm_enough_memory</span> <span class="o">=</span>		<span class="n">selinux_vm_enough_memory</span><span class="p">,</span>

	<span class="p">.</span><span class="n">netlink_send</span> <span class="o">=</span>			<span class="n">selinux_netlink_send</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bprm_set_creds</span> <span class="o">=</span>		<span class="n">selinux_bprm_set_creds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bprm_committing_creds</span> <span class="o">=</span>	<span class="n">selinux_bprm_committing_creds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bprm_committed_creds</span> <span class="o">=</span>		<span class="n">selinux_bprm_committed_creds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bprm_secureexec</span> <span class="o">=</span>		<span class="n">selinux_bprm_secureexec</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sb_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_sb_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_free_security</span> <span class="o">=</span>		<span class="n">selinux_sb_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_copy_data</span> <span class="o">=</span>			<span class="n">selinux_sb_copy_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_remount</span> <span class="o">=</span>			<span class="n">selinux_sb_remount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_kern_mount</span> <span class="o">=</span>		<span class="n">selinux_sb_kern_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_show_options</span> <span class="o">=</span>		<span class="n">selinux_sb_show_options</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_statfs</span> <span class="o">=</span>			<span class="n">selinux_sb_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_mount</span> <span class="o">=</span>			<span class="n">selinux_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_umount</span> <span class="o">=</span>			<span class="n">selinux_umount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_set_mnt_opts</span> <span class="o">=</span>		<span class="n">selinux_set_mnt_opts</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_clone_mnt_opts</span> <span class="o">=</span>		<span class="n">selinux_sb_clone_mnt_opts</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_parse_opts_str</span> <span class="o">=</span> 		<span class="n">selinux_parse_opts_str</span><span class="p">,</span>


	<span class="p">.</span><span class="n">inode_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_inode_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_free_security</span> <span class="o">=</span>		<span class="n">selinux_inode_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_init_security</span> <span class="o">=</span>		<span class="n">selinux_inode_init_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_create</span> <span class="o">=</span>			<span class="n">selinux_inode_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_link</span> <span class="o">=</span>			<span class="n">selinux_inode_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_unlink</span> <span class="o">=</span>			<span class="n">selinux_inode_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_symlink</span> <span class="o">=</span>		<span class="n">selinux_inode_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_mkdir</span> <span class="o">=</span>			<span class="n">selinux_inode_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_rmdir</span> <span class="o">=</span>			<span class="n">selinux_inode_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_mknod</span> <span class="o">=</span>			<span class="n">selinux_inode_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_rename</span> <span class="o">=</span>			<span class="n">selinux_inode_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_readlink</span> <span class="o">=</span>		<span class="n">selinux_inode_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_follow_link</span> <span class="o">=</span>		<span class="n">selinux_inode_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_permission</span> <span class="o">=</span>		<span class="n">selinux_inode_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setattr</span> <span class="o">=</span>		<span class="n">selinux_inode_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getattr</span> <span class="o">=</span>		<span class="n">selinux_inode_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setxattr</span> <span class="o">=</span>		<span class="n">selinux_inode_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_post_setxattr</span> <span class="o">=</span>		<span class="n">selinux_inode_post_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getxattr</span> <span class="o">=</span>		<span class="n">selinux_inode_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_listxattr</span> <span class="o">=</span>		<span class="n">selinux_inode_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_removexattr</span> <span class="o">=</span>		<span class="n">selinux_inode_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecurity</span> <span class="o">=</span>		<span class="n">selinux_inode_getsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setsecurity</span> <span class="o">=</span>		<span class="n">selinux_inode_setsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_listsecurity</span> <span class="o">=</span>		<span class="n">selinux_inode_listsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecid</span> <span class="o">=</span>		<span class="n">selinux_inode_getsecid</span><span class="p">,</span>

	<span class="p">.</span><span class="n">file_permission</span> <span class="o">=</span>		<span class="n">selinux_file_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_file_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_free_security</span> <span class="o">=</span>		<span class="n">selinux_file_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_ioctl</span> <span class="o">=</span>			<span class="n">selinux_file_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap_file</span> <span class="o">=</span>			<span class="n">selinux_mmap_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap_addr</span> <span class="o">=</span>			<span class="n">selinux_mmap_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_mprotect</span> <span class="o">=</span>		<span class="n">selinux_file_mprotect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_lock</span> <span class="o">=</span>			<span class="n">selinux_file_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_fcntl</span> <span class="o">=</span>			<span class="n">selinux_file_fcntl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_set_fowner</span> <span class="o">=</span>		<span class="n">selinux_file_set_fowner</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_send_sigiotask</span> <span class="o">=</span>		<span class="n">selinux_file_send_sigiotask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_receive</span> <span class="o">=</span>			<span class="n">selinux_file_receive</span><span class="p">,</span>

	<span class="p">.</span><span class="n">file_open</span> <span class="o">=</span>			<span class="n">selinux_file_open</span><span class="p">,</span>

	<span class="p">.</span><span class="n">task_create</span> <span class="o">=</span>			<span class="n">selinux_task_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_alloc_blank</span> <span class="o">=</span>		<span class="n">selinux_cred_alloc_blank</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_free</span> <span class="o">=</span>			<span class="n">selinux_cred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_prepare</span> <span class="o">=</span>			<span class="n">selinux_cred_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_transfer</span> <span class="o">=</span>		<span class="n">selinux_cred_transfer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_act_as</span> <span class="o">=</span>		<span class="n">selinux_kernel_act_as</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_create_files_as</span> <span class="o">=</span>	<span class="n">selinux_kernel_create_files_as</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_module_request</span> <span class="o">=</span>	<span class="n">selinux_kernel_module_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setpgid</span> <span class="o">=</span>			<span class="n">selinux_task_setpgid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getpgid</span> <span class="o">=</span>			<span class="n">selinux_task_getpgid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getsid</span> <span class="o">=</span>			<span class="n">selinux_task_getsid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getsecid</span> <span class="o">=</span>		<span class="n">selinux_task_getsecid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setnice</span> <span class="o">=</span>			<span class="n">selinux_task_setnice</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setioprio</span> <span class="o">=</span>		<span class="n">selinux_task_setioprio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getioprio</span> <span class="o">=</span>		<span class="n">selinux_task_getioprio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setrlimit</span> <span class="o">=</span>		<span class="n">selinux_task_setrlimit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setscheduler</span> <span class="o">=</span>		<span class="n">selinux_task_setscheduler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getscheduler</span> <span class="o">=</span>		<span class="n">selinux_task_getscheduler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_movememory</span> <span class="o">=</span>		<span class="n">selinux_task_movememory</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_kill</span> <span class="o">=</span>			<span class="n">selinux_task_kill</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_wait</span> <span class="o">=</span>			<span class="n">selinux_task_wait</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_to_inode</span> <span class="o">=</span>		<span class="n">selinux_task_to_inode</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ipc_permission</span> <span class="o">=</span>		<span class="n">selinux_ipc_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ipc_getsecid</span> <span class="o">=</span>			<span class="n">selinux_ipc_getsecid</span><span class="p">,</span>

	<span class="p">.</span><span class="n">msg_msg_alloc_security</span> <span class="o">=</span>	<span class="n">selinux_msg_msg_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_msg_free_security</span> <span class="o">=</span>	<span class="n">selinux_msg_msg_free_security</span><span class="p">,</span>

	<span class="p">.</span><span class="n">msg_queue_alloc_security</span> <span class="o">=</span>	<span class="n">selinux_msg_queue_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_free_security</span> <span class="o">=</span>	<span class="n">selinux_msg_queue_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_associate</span> <span class="o">=</span>		<span class="n">selinux_msg_queue_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgctl</span> <span class="o">=</span>		<span class="n">selinux_msg_queue_msgctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgsnd</span> <span class="o">=</span>		<span class="n">selinux_msg_queue_msgsnd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgrcv</span> <span class="o">=</span>		<span class="n">selinux_msg_queue_msgrcv</span><span class="p">,</span>

	<span class="p">.</span><span class="n">shm_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_shm_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_free_security</span> <span class="o">=</span>		<span class="n">selinux_shm_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_associate</span> <span class="o">=</span>		<span class="n">selinux_shm_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_shmctl</span> <span class="o">=</span>			<span class="n">selinux_shm_shmctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_shmat</span> <span class="o">=</span>			<span class="n">selinux_shm_shmat</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sem_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_sem_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_free_security</span> <span class="o">=</span>		<span class="n">selinux_sem_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_associate</span> <span class="o">=</span>		<span class="n">selinux_sem_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_semctl</span> <span class="o">=</span>			<span class="n">selinux_sem_semctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_semop</span> <span class="o">=</span>			<span class="n">selinux_sem_semop</span><span class="p">,</span>

	<span class="p">.</span><span class="n">d_instantiate</span> <span class="o">=</span>		<span class="n">selinux_d_instantiate</span><span class="p">,</span>

	<span class="p">.</span><span class="n">getprocattr</span> <span class="o">=</span>			<span class="n">selinux_getprocattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setprocattr</span> <span class="o">=</span>			<span class="n">selinux_setprocattr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">secid_to_secctx</span> <span class="o">=</span>		<span class="n">selinux_secid_to_secctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">secctx_to_secid</span> <span class="o">=</span>		<span class="n">selinux_secctx_to_secid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_secctx</span> <span class="o">=</span>		<span class="n">selinux_release_secctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_notifysecctx</span> <span class="o">=</span>		<span class="n">selinux_inode_notifysecctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setsecctx</span> <span class="o">=</span>		<span class="n">selinux_inode_setsecctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecctx</span> <span class="o">=</span>		<span class="n">selinux_inode_getsecctx</span><span class="p">,</span>

	<span class="p">.</span><span class="n">unix_stream_connect</span> <span class="o">=</span>		<span class="n">selinux_socket_unix_stream_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unix_may_send</span> <span class="o">=</span>		<span class="n">selinux_socket_unix_may_send</span><span class="p">,</span>

	<span class="p">.</span><span class="n">socket_create</span> <span class="o">=</span>		<span class="n">selinux_socket_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_post_create</span> <span class="o">=</span>		<span class="n">selinux_socket_post_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_bind</span> <span class="o">=</span>			<span class="n">selinux_socket_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_connect</span> <span class="o">=</span>		<span class="n">selinux_socket_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_listen</span> <span class="o">=</span>		<span class="n">selinux_socket_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_accept</span> <span class="o">=</span>		<span class="n">selinux_socket_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_sendmsg</span> <span class="o">=</span>		<span class="n">selinux_socket_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_recvmsg</span> <span class="o">=</span>		<span class="n">selinux_socket_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getsockname</span> <span class="o">=</span>		<span class="n">selinux_socket_getsockname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getpeername</span> <span class="o">=</span>		<span class="n">selinux_socket_getpeername</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getsockopt</span> <span class="o">=</span>		<span class="n">selinux_socket_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_setsockopt</span> <span class="o">=</span>		<span class="n">selinux_socket_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_shutdown</span> <span class="o">=</span>		<span class="n">selinux_socket_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_sock_rcv_skb</span> <span class="o">=</span>		<span class="n">selinux_socket_sock_rcv_skb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getpeersec_stream</span> <span class="o">=</span>	<span class="n">selinux_socket_getpeersec_stream</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getpeersec_dgram</span> <span class="o">=</span>	<span class="n">selinux_socket_getpeersec_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_alloc_security</span> <span class="o">=</span>		<span class="n">selinux_sk_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_free_security</span> <span class="o">=</span>		<span class="n">selinux_sk_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_clone_security</span> <span class="o">=</span>		<span class="n">selinux_sk_clone_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_getsecid</span> <span class="o">=</span>			<span class="n">selinux_sk_getsecid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sock_graft</span> <span class="o">=</span>			<span class="n">selinux_sock_graft</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inet_conn_request</span> <span class="o">=</span>		<span class="n">selinux_inet_conn_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inet_csk_clone</span> <span class="o">=</span>		<span class="n">selinux_inet_csk_clone</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inet_conn_established</span> <span class="o">=</span>	<span class="n">selinux_inet_conn_established</span><span class="p">,</span>
	<span class="p">.</span><span class="n">secmark_relabel_packet</span> <span class="o">=</span>	<span class="n">selinux_secmark_relabel_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">secmark_refcount_inc</span> <span class="o">=</span>		<span class="n">selinux_secmark_refcount_inc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">secmark_refcount_dec</span> <span class="o">=</span>		<span class="n">selinux_secmark_refcount_dec</span><span class="p">,</span>
	<span class="p">.</span><span class="n">req_classify_flow</span> <span class="o">=</span>		<span class="n">selinux_req_classify_flow</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tun_dev_create</span> <span class="o">=</span>		<span class="n">selinux_tun_dev_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tun_dev_post_create</span> <span class="o">=</span> 		<span class="n">selinux_tun_dev_post_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tun_dev_attach</span> <span class="o">=</span>		<span class="n">selinux_tun_dev_attach</span><span class="p">,</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>
	<span class="p">.</span><span class="n">xfrm_policy_alloc_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_policy_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_policy_clone_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_policy_clone</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_policy_free_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_policy_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_policy_delete_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_policy_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_state_alloc_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_state_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_state_free_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_state_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_state_delete_security</span> <span class="o">=</span>	<span class="n">selinux_xfrm_state_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_policy_lookup</span> <span class="o">=</span>		<span class="n">selinux_xfrm_policy_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_state_pol_flow_match</span> <span class="o">=</span>	<span class="n">selinux_xfrm_state_pol_flow_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xfrm_decode_session</span> <span class="o">=</span>		<span class="n">selinux_xfrm_decode_session</span><span class="p">,</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="p">.</span><span class="n">key_alloc</span> <span class="o">=</span>			<span class="n">selinux_key_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_free</span> <span class="o">=</span>			<span class="n">selinux_key_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_permission</span> <span class="o">=</span>		<span class="n">selinux_key_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_getsecurity</span> <span class="o">=</span>		<span class="n">selinux_key_getsecurity</span><span class="p">,</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="p">.</span><span class="n">audit_rule_init</span> <span class="o">=</span>		<span class="n">selinux_audit_rule_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_known</span> <span class="o">=</span>		<span class="n">selinux_audit_rule_known</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_match</span> <span class="o">=</span>		<span class="n">selinux_audit_rule_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_free</span> <span class="o">=</span>		<span class="n">selinux_audit_rule_free</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">selinux_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">security_module_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selinux_ops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">selinux_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux:  Disabled at boot.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux:  Initializing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set the security state for the initial task. */</span>
	<span class="n">cred_init_security</span><span class="p">();</span>

	<span class="n">default_noexec</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">VM_DATA_DEFAULT_FLAGS</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">);</span>

	<span class="n">sel_inode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;selinux_inode_security&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode_security_struct</span><span class="p">),</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">avc_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selinux_ops</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SELinux: Unable to register with kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_enforcing</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Starting in enforcing mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Starting in permissive mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delayed_superblock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">superblock_doinit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">selinux_complete_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Completing initialization.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set up any superblocks initialized prior to the policy load. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Setting up existing superblocks.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">iterate_supers</span><span class="p">(</span><span class="n">delayed_superblock_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* SELinux requires early initialization in order to label</span>
<span class="cm">   all processes and objects when they are created. */</span>
<span class="n">security_initcall</span><span class="p">(</span><span class="n">selinux_init</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_NETFILTER)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">selinux_ipv4_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span>		<span class="n">selinux_ipv4_postroute</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span>		<span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span>	<span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span>	<span class="n">NF_IP_PRI_SELINUX_LAST</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span>		<span class="n">selinux_ipv4_forward</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span>		<span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span>	<span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span>	<span class="n">NF_IP_PRI_SELINUX_FIRST</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span>		<span class="n">selinux_ipv4_output</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span>		<span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span>	<span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span>	<span class="n">NF_IP_PRI_SELINUX_FIRST</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">selinux_ipv6_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span>		<span class="n">selinux_ipv6_postroute</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span>		<span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span>	<span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span>	<span class="n">NF_IP6_PRI_SELINUX_LAST</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span>		<span class="n">selinux_ipv6_forward</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span>		<span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span>	<span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span>	<span class="n">NF_IP6_PRI_SELINUX_FIRST</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">selinux_nf_ip_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_enabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Registering netfilter hooks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nf_register_hooks</span><span class="p">(</span><span class="n">selinux_ipv4_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">selinux_ipv4_ops</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SELinux: nf_register_hooks for IPv4: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nf_register_hooks</span><span class="p">(</span><span class="n">selinux_ipv6_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">selinux_ipv6_ops</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SELinux: nf_register_hooks for IPv6: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">selinux_nf_ip_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY_SELINUX_DISABLE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_nf_ip_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SELinux:  Unregistering netfilter hooks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">selinux_ipv4_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">selinux_ipv4_ops</span><span class="p">));</span>
<span class="cp">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
	<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">selinux_ipv6_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">selinux_ipv6_ops</span><span class="p">));</span>
<span class="cp">#endif	</span><span class="cm">/* IPV6 */</span><span class="cp"></span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_NETFILTER */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_SELINUX_DISABLE</span>
<span class="cp">#define selinux_nf_ip_exit()</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NETFILTER */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_SELINUX_DISABLE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">selinux_disabled</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">selinux_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not permitted after initial policy load. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Only do this once. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux:  Disabled at runtime.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">selinux_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">selinux_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reset_security_ops</span><span class="p">();</span>

	<span class="cm">/* Try to destroy the avc node cache */</span>
	<span class="n">avc_disable</span><span class="p">();</span>

	<span class="cm">/* Unregister netfilter hooks. */</span>
	<span class="n">selinux_nf_ip_exit</span><span class="p">();</span>

	<span class="cm">/* Unregister selinuxfs. */</span>
	<span class="n">exit_sel_fs</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
