<!DOCTYPE html>
<html><head><title>joekychen/linux » security › selinux › ss › services.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>services.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Implementation of the security services.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors : Stephen Smalley, &lt;sds@epoch.ncsc.mil&gt;</span>
<span class="cm"> *	     James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: Trusted Computer Solutions, Inc. &lt;dgoeddel@trustedcs.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Support for enhanced MLS infrastructure.</span>
<span class="cm"> *	Support for context based audit filters.</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: Frank Mayer &lt;mayerf@tresys.com&gt; and Karl MacMillan &lt;kmacmillan@tresys.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Added conditional policy language extensions</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: Hewlett-Packard &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *      Added support for NetLabel</span>
<span class="cm"> *      Added support for the policy capability bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: Chad Sellers &lt;csellers@tresys.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Added validation of kernel classes and permissions</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: KaiGai Kohei &lt;kaigai@ak.jp.nec.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Added support for bounds domain and audit messaged on masked permissions</span>
<span class="cm"> *</span>
<span class="cm"> * Updated: Guido Trentalancia &lt;guido@trentalancia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Added support for runtime switching of the policy type</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, 2009 NEC Corporation</span>
<span class="cm"> * Copyright (C) 2006, 2007 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> * Copyright (C) 2004-2006 Trusted Computer Solutions, Inc.</span>
<span class="cm"> * Copyright (C) 2003 - 2004, 2006 Tresys Technology, LLC</span>
<span class="cm"> * Copyright (C) 2003 Red Hat, Inc., James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation, version 2.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/selinux.h&gt;</span>
<span class="cp">#include &lt;linux/flex_array.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;net/netlabel.h&gt;</span>

<span class="cp">#include &quot;flask.h&quot;</span>
<span class="cp">#include &quot;avc.h&quot;</span>
<span class="cp">#include &quot;avc_ss.h&quot;</span>
<span class="cp">#include &quot;security.h&quot;</span>
<span class="cp">#include &quot;context.h&quot;</span>
<span class="cp">#include &quot;policydb.h&quot;</span>
<span class="cp">#include &quot;sidtab.h&quot;</span>
<span class="cp">#include &quot;services.h&quot;</span>
<span class="cp">#include &quot;conditional.h&quot;</span>
<span class="cp">#include &quot;mls.h&quot;</span>
<span class="cp">#include &quot;objsec.h&quot;</span>
<span class="cp">#include &quot;netlabel.h&quot;</span>
<span class="cp">#include &quot;xfrm.h&quot;</span>
<span class="cp">#include &quot;ebitmap.h&quot;</span>
<span class="cp">#include &quot;audit.h&quot;</span>

<span class="kt">int</span> <span class="n">selinux_policycap_netpeer</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">selinux_policycap_openperm</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">policy_rwlock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sidtab</span> <span class="n">sidtab</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">policydb</span> <span class="n">policydb</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ss_initialized</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The largest sequence number that has been used when</span>
<span class="cm"> * providing an access decision to the access vector cache.</span>
<span class="cm"> * The sequence number only changes when a policy change</span>
<span class="cm"> * occurs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">latest_granting</span><span class="p">;</span>

<span class="cm">/* Forward declaration. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">context_struct_to_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">scontext</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="o">*</span><span class="n">scontext_len</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">context_struct_compute_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">value</span><span class="p">;</span> <span class="cm">/* policy value */</span>
	<span class="kt">unsigned</span> <span class="n">num_perms</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">perms</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="o">*</span><span class="n">current_mapping</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">current_mapping_size</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">selinux_set_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">security_class_mapping</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="o">**</span><span class="n">out_map_p</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="o">*</span><span class="n">out_map_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="o">*</span><span class="n">out_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">selinux_mapping</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">print_unknown_handle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Find number of classes in the input mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">)</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Allocate space for the class records, plus one for class zero */</span>
	<span class="n">out_map</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Store the raw class and permission values */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">security_class_mapping</span> <span class="o">*</span><span class="n">p_in</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">++</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="o">*</span><span class="n">p_out</span> <span class="o">=</span> <span class="n">out_map</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

		<span class="cm">/* An empty class string skips ahead */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p_in</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p_out</span><span class="o">-&gt;</span><span class="n">num_perms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p_out</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">string_to_security_class</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_out</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;SELinux:  Class %s not defined in policy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">reject_unknown</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">p_out</span><span class="o">-&gt;</span><span class="n">num_perms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">print_unknown_handle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p_in</span><span class="o">-&gt;</span><span class="n">perms</span> <span class="o">&amp;&amp;</span> <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* An empty permission string skips ahead */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p_in</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">k</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p_out</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_av_perm</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">p_out</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
							    <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_out</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;SELinux:  Permission %s in class %s not defined in policy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">p_in</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">reject_unknown</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">print_unknown_handle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p_out</span><span class="o">-&gt;</span><span class="n">num_perms</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">print_unknown_handle</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux: the above unknown classes and permissions will be %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pol</span><span class="o">-&gt;</span><span class="n">allow_unknown</span> <span class="o">?</span> <span class="s">&quot;allowed&quot;</span> <span class="o">:</span> <span class="s">&quot;denied&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">out_map_p</span> <span class="o">=</span> <span class="n">out_map</span><span class="p">;</span>
	<span class="o">*</span><span class="n">out_map_size</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">out_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get real, policy values from mapped values</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">unmap_class</span><span class="p">(</span><span class="n">u16</span> <span class="n">tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span> <span class="o">&lt;</span> <span class="n">current_mapping_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tclass</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get kernel value for class from its policy value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">map_class</span><span class="p">(</span><span class="n">u16</span> <span class="n">pol_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_mapping_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="n">pol_value</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SECCLASS_NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_decision</span><span class="p">(</span><span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span> <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">allow_unknown</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span> <span class="o">&lt;</span> <span class="n">current_mapping_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">num_perms</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">perms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">allow_unknown</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">perms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditallow</span> <span class="o">&amp;</span> <span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">perms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditallow</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditdeny</span> <span class="o">&amp;</span> <span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">perms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow_unknown</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current_mapping</span><span class="p">[</span><span class="n">tclass</span><span class="p">].</span><span class="n">perms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case the kernel has a bug and requests a permission</span>
<span class="cm">		 * between num_perms and the maximum permission number, we</span>
<span class="cm">		 * should audit that denial</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditdeny</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_mls_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">policydb</span><span class="p">.</span><span class="n">mls_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the boolean value of a constraint expression</span>
<span class="cm"> * when it is applied to the specified source and target</span>
<span class="cm"> * security contexts.</span>
<span class="cm"> *</span>
<span class="cm"> * xcontext is a special beast...  It is used by the validatetrans rules</span>
<span class="cm"> * only.  For these rules, scontext is the context before the transition,</span>
<span class="cm"> * tcontext is the context after the transition, and xcontext is the context</span>
<span class="cm"> * of the process performing the transition.  All other callers of</span>
<span class="cm"> * constraint_expr_eval should pass in NULL for xcontext.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">constraint_expr_eval</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">xcontext</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">constraint_expr</span> <span class="o">*</span><span class="n">cexpr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_datum</span> <span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mls_level</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="o">*</span><span class="n">l2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">constraint_expr</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">CEXPR_MAXDEPTH</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">sp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">cexpr</span><span class="p">;</span> <span class="n">e</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">expr_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CEXPR_NOT</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">s</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">s</span><span class="p">[</span><span class="n">sp</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CEXPR_AND</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
			<span class="n">s</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">s</span><span class="p">[</span><span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CEXPR_OR</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
			<span class="n">s</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">|=</span> <span class="n">s</span><span class="p">[</span><span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CEXPR_ATTR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="p">(</span><span class="n">CEXPR_MAXDEPTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">CEXPR_USER</span>:
				<span class="n">val1</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
				<span class="n">val2</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_TYPE</span>:
				<span class="n">val1</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
				<span class="n">val2</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_ROLE</span>:
				<span class="n">val1</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
				<span class="n">val2</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
				<span class="n">r1</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">role_val_to_struct</span><span class="p">[</span><span class="n">val1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
				<span class="n">r2</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">role_val_to_struct</span><span class="p">[</span><span class="n">val2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">CEXPR_DOM</span>:
					<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">dominates</span><span class="p">,</span>
								  <span class="n">val2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">CEXPR_DOMBY</span>:
					<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="o">-&gt;</span><span class="n">dominates</span><span class="p">,</span>
								  <span class="n">val1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">CEXPR_INCOMP</span>:
					<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">dominates</span><span class="p">,</span>
								    <span class="n">val2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						   <span class="o">!</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="o">-&gt;</span><span class="n">dominates</span><span class="p">,</span>
								    <span class="n">val1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_L1L2</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_L1H2</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_H1L2</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_H1H2</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_L1H1</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_L2H2</span>:
				<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">mls_ops</span><span class="p">;</span>
<span class="nl">mls_ops:</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">CEXPR_EQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mls_level_eq</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_NEQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">mls_level_eq</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_DOM</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mls_level_dom</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_DOMBY</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mls_level_dom</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_INCOMP</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mls_level_incomp</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">CEXPR_EQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val1</span> <span class="o">==</span> <span class="n">val2</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_NEQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val1</span> <span class="o">!=</span> <span class="n">val2</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CEXPR_NAMES</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="p">(</span><span class="n">CEXPR_MAXDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">scontext</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">CEXPR_TARGET</span><span class="p">)</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">tcontext</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">CEXPR_XTARGET</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">xcontext</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">BUG</span><span class="p">();</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">CEXPR_USER</span><span class="p">)</span>
				<span class="n">val1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">CEXPR_ROLE</span><span class="p">)</span>
				<span class="n">val1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">CEXPR_TYPE</span><span class="p">)</span>
				<span class="n">val1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">CEXPR_EQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">names</span><span class="p">,</span> <span class="n">val1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">CEXPR_NEQ</span>:
				<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">names</span><span class="p">,</span> <span class="n">val1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * security_dump_masked_av - dumps masked permissions during</span>
<span class="cm"> * security_compute_av due to RBAC, MLS/Constraint and Type bounds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dump_masked_av_helper</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perm_datum</span> <span class="o">*</span><span class="n">pdatum</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">permission_names</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pdatum</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">pdatum</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">permission_names</span><span class="p">[</span><span class="n">pdatum</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">k</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">security_dump_masked_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">permissions</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">common_datum</span> <span class="o">*</span><span class="n">common_dat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">tclass_dat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tclass_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">scontext_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tcontext_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">permission_names</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_comma</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">permissions</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tclass_name</span> <span class="o">=</span> <span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_CLASSES</span><span class="p">,</span> <span class="n">tclass</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tclass_dat</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">class_val_to_struct</span><span class="p">[</span><span class="n">tclass</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">common_dat</span> <span class="o">=</span> <span class="n">tclass_dat</span><span class="o">-&gt;</span><span class="n">comdatum</span><span class="p">;</span>

	<span class="cm">/* init permission_names */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common_dat</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hashtab_map</span><span class="p">(</span><span class="n">common_dat</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
			<span class="n">dump_masked_av_helper</span><span class="p">,</span> <span class="n">permission_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hashtab_map</span><span class="p">(</span><span class="n">tclass_dat</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
			<span class="n">dump_masked_av_helper</span><span class="p">,</span> <span class="n">permission_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* get scontext/tcontext in text form */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">scontext_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">tcontext</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">tcontext_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* audit a message */</span>
	<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span>
			     <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;op=security_compute_av reason=%s &quot;</span>
			 <span class="s">&quot;scontext=%s tcontext=%s tclass=%s perms=&quot;</span><span class="p">,</span>
			 <span class="n">reason</span><span class="p">,</span> <span class="n">scontext_name</span><span class="p">,</span> <span class="n">tcontext_name</span><span class="p">,</span> <span class="n">tclass_name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">permissions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span>
				 <span class="n">need_comma</span> <span class="o">?</span> <span class="s">&quot;,&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				 <span class="n">permission_names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
				 <span class="o">?</span> <span class="n">permission_names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;????&quot;</span><span class="p">);</span>
		<span class="n">need_comma</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="cm">/* release scontext/tcontext */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tcontext_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">scontext_name</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * security_boundary_permission - drops violated permissions</span>
<span class="cm"> * on boundary constraint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">type_attribute_bounds_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">lo_scontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">lo_tcontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">av_decision</span> <span class="n">lo_avd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">masked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">source</span> <span class="o">=</span> <span class="n">flex_array_get_ptr</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">type_val_to_struct_array</span><span class="p">,</span>
				    <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">source</span><span class="p">);</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">flex_array_get_ptr</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">type_val_to_struct_array</span><span class="p">,</span>
				    <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">target</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lo_avd</span><span class="p">));</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_scontext</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lo_scontext</span><span class="p">));</span>
		<span class="n">lo_scontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">;</span>

		<span class="n">context_struct_compute_av</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_scontext</span><span class="p">,</span>
					  <span class="n">tcontext</span><span class="p">,</span>
					  <span class="n">tclass</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span> <span class="o">==</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no masked permission */</span>
		<span class="n">masked</span> <span class="o">=</span> <span class="o">~</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lo_avd</span><span class="p">));</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_tcontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lo_tcontext</span><span class="p">));</span>
		<span class="n">lo_tcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">;</span>

		<span class="n">context_struct_compute_av</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">lo_tcontext</span><span class="p">,</span>
					  <span class="n">tclass</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span> <span class="o">==</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no masked permission */</span>
		<span class="n">masked</span> <span class="o">=</span> <span class="o">~</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lo_avd</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * lo_scontext and lo_tcontext are already</span>
<span class="cm">		 * set up.</span>
<span class="cm">		 */</span>

		<span class="n">context_struct_compute_av</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo_scontext</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">lo_tcontext</span><span class="p">,</span>
					  <span class="n">tclass</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">lo_avd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span> <span class="o">==</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no masked permission */</span>
		<span class="n">masked</span> <span class="o">=</span> <span class="o">~</span><span class="n">lo_avd</span><span class="p">.</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">masked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mask violated permissions */</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">masked</span><span class="p">;</span>

		<span class="cm">/* audit masked permissions */</span>
		<span class="n">security_dump_masked_av</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span>
					<span class="n">tclass</span><span class="p">,</span> <span class="n">masked</span><span class="p">,</span> <span class="s">&quot;bounds&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute access vectors based on a context structure pair for</span>
<span class="cm"> * the permissions in a particular class.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_struct_compute_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">constraint_node</span> <span class="o">*</span><span class="n">constraint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_allow</span> <span class="o">*</span><span class="n">ra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">avtab_key</span> <span class="n">avkey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">avtab_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">tclass_datum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebitmap</span> <span class="o">*</span><span class="n">sattr</span><span class="p">,</span> <span class="o">*</span><span class="n">tattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebitmap_node</span> <span class="o">*</span><span class="n">snode</span><span class="p">,</span> <span class="o">*</span><span class="n">tnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditallow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditdeny</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tclass</span> <span class="o">||</span> <span class="n">tclass</span> <span class="o">&gt;</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">nprim</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux:  Invalid class %hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tclass</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tclass_datum</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">class_val_to_struct</span><span class="p">[</span><span class="n">tclass</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a specific type enforcement rule was defined for</span>
<span class="cm">	 * this permission check, then use it.</span>
<span class="cm">	 */</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">target_class</span> <span class="o">=</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">specified</span> <span class="o">=</span> <span class="n">AVTAB_AV</span><span class="p">;</span>
	<span class="n">sattr</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">type_attr_map_array</span><span class="p">,</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sattr</span><span class="p">);</span>
	<span class="n">tattr</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">type_attr_map_array</span><span class="p">,</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tattr</span><span class="p">);</span>
	<span class="n">ebitmap_for_each_positive_bit</span><span class="p">(</span><span class="n">sattr</span><span class="p">,</span> <span class="n">snode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ebitmap_for_each_positive_bit</span><span class="p">(</span><span class="n">tattr</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avkey</span><span class="p">.</span><span class="n">source_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">avkey</span><span class="p">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="n">avtab_search_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">te_avtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avkey</span><span class="p">);</span>
			     <span class="n">node</span><span class="p">;</span>
			     <span class="n">node</span> <span class="o">=</span> <span class="n">avtab_search_node_next</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">avkey</span><span class="p">.</span><span class="n">specified</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">specified</span> <span class="o">==</span> <span class="n">AVTAB_ALLOWED</span><span class="p">)</span>
					<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">|=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">datum</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">specified</span> <span class="o">==</span> <span class="n">AVTAB_AUDITALLOW</span><span class="p">)</span>
					<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditallow</span> <span class="o">|=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">datum</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">specified</span> <span class="o">==</span> <span class="n">AVTAB_AUDITDENY</span><span class="p">)</span>
					<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditdeny</span> <span class="o">&amp;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">datum</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check conditional av table for additional permissions */</span>
			<span class="n">cond_compute_av</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">te_cond_avtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avkey</span><span class="p">,</span> <span class="n">avd</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove any permissions prohibited by a constraint (this includes</span>
<span class="cm">	 * the MLS policy).</span>
<span class="cm">	 */</span>
	<span class="n">constraint</span> <span class="o">=</span> <span class="n">tclass_datum</span><span class="o">-&gt;</span><span class="n">constraints</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">constraint</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">constraint</span><span class="o">-&gt;</span><span class="n">permissions</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">constraint_expr_eval</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="n">constraint</span><span class="o">-&gt;</span><span class="n">expr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">constraint</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If checking process transition permission and the</span>
<span class="cm">	 * role is changing, then check the (current_role, new_role)</span>
<span class="cm">	 * pair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span> <span class="o">==</span> <span class="n">policydb</span><span class="p">.</span><span class="n">process_class</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">&amp;</span> <span class="n">policydb</span><span class="p">.</span><span class="n">process_trans_perms</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">!=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ra</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">role_allow</span><span class="p">;</span> <span class="n">ra</span><span class="p">;</span> <span class="n">ra</span> <span class="o">=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">new_role</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ra</span><span class="p">)</span>
			<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">policydb</span><span class="p">.</span><span class="n">process_trans_perms</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the given source and target types have boundary</span>
<span class="cm">	 * constraint, lazy checks have to mask any violated</span>
<span class="cm">	 * permission and notice it to userspace via audit.</span>
<span class="cm">	 */</span>
	<span class="n">type_attribute_bounds_av</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span>
				 <span class="n">tclass</span><span class="p">,</span> <span class="n">avd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">security_validtrans_handle_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ocontext</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ncontext</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
					   <span class="n">u16</span> <span class="n">tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">o</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">olen</span><span class="p">,</span> <span class="n">nlen</span><span class="p">,</span> <span class="n">tlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">ocontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">olen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">ncontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">tcontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
		  <span class="s">&quot;security_validate_transition:  denied for&quot;</span>
		  <span class="s">&quot; oldcontext=%s newcontext=%s taskcontext=%s tclass=%s&quot;</span><span class="p">,</span>
		  <span class="n">o</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_CLASSES</span><span class="p">,</span> <span class="n">tclass</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_enforcing</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_validate_transition</span><span class="p">(</span><span class="n">u32</span> <span class="n">oldsid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">newsid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tasksid</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="n">orig_tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ocontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ncontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">tclass_datum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">constraint_node</span> <span class="o">*</span><span class="n">constraint</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">tclass</span> <span class="o">=</span> <span class="n">unmap_class</span><span class="p">(</span><span class="n">orig_tclass</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tclass</span> <span class="o">||</span> <span class="n">tclass</span> <span class="o">&gt;</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">nprim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized class %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">tclass</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tclass_datum</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">class_val_to_struct</span><span class="p">[</span><span class="n">tclass</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">ocontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">oldsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ocontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">oldsid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ncontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">newsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ncontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">newsid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tcontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">tasksid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">tasksid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">constraint</span> <span class="o">=</span> <span class="n">tclass_datum</span><span class="o">-&gt;</span><span class="n">validatetrans</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">constraint</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">constraint_expr_eval</span><span class="p">(</span><span class="n">ocontext</span><span class="p">,</span> <span class="n">ncontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span>
					  <span class="n">constraint</span><span class="o">-&gt;</span><span class="n">expr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">security_validtrans_handle_fail</span><span class="p">(</span><span class="n">ocontext</span><span class="p">,</span> <span class="n">ncontext</span><span class="p">,</span>
							     <span class="n">tcontext</span><span class="p">,</span> <span class="n">tclass</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * security_bounded_transition - check whether the given</span>
<span class="cm"> * transition is directed to bounded, or not.</span>
<span class="cm"> * It returns 0, if @newsid is bounded by @oldsid.</span>
<span class="cm"> * Otherwise, it returns error code.</span>
<span class="cm"> *</span>
<span class="cm"> * @oldsid : current security identifier</span>
<span class="cm"> * @newsid : destinated security identifier</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_bounded_transition</span><span class="p">(</span><span class="n">u32</span> <span class="n">old_sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">old_context</span><span class="p">,</span> <span class="o">*</span><span class="n">new_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">old_context</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">old_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s: unrecognized SID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">old_sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">new_context</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">new_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s: unrecognized SID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">new_sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* type/domain unchanged */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_context</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">new_context</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">new_context</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">flex_array_get_ptr</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">type_val_to_struct_array</span><span class="p">,</span>
					  <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">);</span>

		<span class="cm">/* not bounded anymore */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* @newsid is bounded by @oldsid */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">==</span> <span class="n">old_context</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">new_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">old_context</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">old_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">new_context</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">new_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span>
				  <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
				  <span class="s">&quot;op=security_bounded_transition &quot;</span>
				  <span class="s">&quot;result=denied &quot;</span>
				  <span class="s">&quot;oldcontext=%s newcontext=%s&quot;</span><span class="p">,</span>
				  <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">avd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditallow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">auditdeny</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">latest_granting</span><span class="p">;</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * security_compute_av - Compute access vector decisions.</span>
<span class="cm"> * @ssid: source security identifier</span>
<span class="cm"> * @tsid: target security identifier</span>
<span class="cm"> * @tclass: target security class</span>
<span class="cm"> * @avd: access vector decisions</span>
<span class="cm"> *</span>
<span class="cm"> * Compute a set of access vector decisions based on the</span>
<span class="cm"> * SID pair (@ssid, @tsid) for the permissions in @tclass.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">security_compute_av</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span>
			 <span class="n">u16</span> <span class="n">orig_tclass</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tcontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">avd_init</span><span class="p">(</span><span class="n">avd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">allow</span><span class="p">;</span>

	<span class="n">scontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* permissive domain? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">permissive_map</span><span class="p">,</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AVD_FLAGS_PERMISSIVE</span><span class="p">;</span>

	<span class="n">tcontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tclass</span> <span class="o">=</span> <span class="n">unmap_class</span><span class="p">(</span><span class="n">orig_tclass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">orig_tclass</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tclass</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">allow_unknown</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allow</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">context_struct_compute_av</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">avd</span><span class="p">);</span>
	<span class="n">map_decision</span><span class="p">(</span><span class="n">orig_tclass</span><span class="p">,</span> <span class="n">avd</span><span class="p">,</span> <span class="n">policydb</span><span class="p">.</span><span class="n">allow_unknown</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">allow:</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">security_compute_av_user</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">av_decision</span> <span class="o">*</span><span class="n">avd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tcontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">avd_init</span><span class="p">(</span><span class="n">avd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">allow</span><span class="p">;</span>

	<span class="n">scontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* permissive domain? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">permissive_map</span><span class="p">,</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="n">avd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AVD_FLAGS_PERMISSIVE</span><span class="p">;</span>

	<span class="n">tcontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tclass</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">allow_unknown</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allow</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">context_struct_compute_av</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">avd</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">allow:</span>
	<span class="n">avd</span><span class="o">-&gt;</span><span class="n">allowed</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the security context string representation of</span>
<span class="cm"> * the context structure `context&#39; into a dynamically</span>
<span class="cm"> * allocated string of the correct size.  Set `*scontext&#39;</span>
<span class="cm"> * to point to this string and set `*scontext_len&#39; to</span>
<span class="cm"> * the length of the string.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">context_struct_to_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">scontext_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">scontextp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scontext</span><span class="p">)</span>
		<span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">scontext_len</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scontext</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">scontext</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Compute the size of the context. */</span>
	<span class="o">*</span><span class="n">scontext_len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_USERS</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext_len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_ROLES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext_len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_TYPES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext_len</span> <span class="o">+=</span> <span class="n">mls_compute_context_len</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate space for the context; caller must free this space. */</span>
	<span class="n">scontextp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="o">*</span><span class="n">scontext_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontextp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="n">scontextp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the user name, role name and type name into the context.</span>
<span class="cm">	 */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">scontextp</span><span class="p">,</span> <span class="s">&quot;%s:%s:%s&quot;</span><span class="p">,</span>
		<span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_USERS</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_ROLES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_TYPES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">scontextp</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_USERS</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
		     <span class="mi">1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_ROLES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
		     <span class="mi">1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_TYPES</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">mls_sid_to_context</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontextp</span><span class="p">);</span>

	<span class="o">*</span><span class="n">scontextp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;initial_sid_to_string.h&quot;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">security_get_initial_sid_context</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sid</span> <span class="o">&gt;</span> <span class="n">SECINITSID_NUM</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">initial_sid_to_string</span><span class="p">[</span><span class="n">sid</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">security_sid_to_context_core</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">scontext</span><span class="p">,</span>
					<span class="n">u32</span> <span class="o">*</span><span class="n">scontext_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scontext</span><span class="p">)</span>
		<span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontext_len</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&lt;=</span> <span class="n">SECINITSID_NUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">scontextp</span><span class="p">;</span>

			<span class="o">*</span><span class="n">scontext_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">initial_sid_to_string</span><span class="p">[</span><span class="n">sid</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">scontextp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="o">*</span><span class="n">scontext_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontextp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">scontextp</span><span class="p">,</span> <span class="n">initial_sid_to_string</span><span class="p">[</span><span class="n">sid</span><span class="p">]);</span>
			<span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="n">scontextp</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  called before initial &quot;</span>
		       <span class="s">&quot;load_policy on unknown SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">sidtab_search_force</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_sid_to_context - Obtain a context for a given SID.</span>
<span class="cm"> * @sid: security identifier, SID</span>
<span class="cm"> * @scontext: security context</span>
<span class="cm"> * @scontext_len: length in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Write the string representation of the context associated with @sid</span>
<span class="cm"> * into a dynamically allocated string of the correct size.  Set @scontext</span>
<span class="cm"> * to point to this string and set @scontext_len to the length of the string.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_sid_to_context</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">scontext_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_sid_to_context_core</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_sid_to_context_force</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">scontext_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_sid_to_context_core</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caveat:  Mutates scontext.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">string_to_context_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sidtab</span> <span class="o">*</span><span class="n">sidtabp</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">scontext_len</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">def_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">role_datum</span> <span class="o">*</span><span class="n">role</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">typdatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_datum</span> <span class="o">*</span><span class="n">usrdatum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">scontextp</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">oldc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">context_init</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/* Parse the security context. */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">scontextp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">scontext</span><span class="p">;</span>

	<span class="cm">/* Extract the user. */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">scontextp</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">usrdatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">p_users</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">scontextp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usrdatum</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">usrdatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Extract role. */</span>
	<span class="n">scontextp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">role</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">p_roles</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">scontextp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">role</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">=</span> <span class="n">role</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Extract type. */</span>
	<span class="n">scontextp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="n">oldc</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">typdatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">p_types</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">scontextp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">typdatum</span> <span class="o">||</span> <span class="n">typdatum</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">typdatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_context_to_sid</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">oldc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">sidtabp</span><span class="p">,</span> <span class="n">def_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">scontext</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">scontext_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check the validity of the new context. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb_context_isvalid</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">context_destroy</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">security_context_to_sid_core</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scontext_len</span><span class="p">,</span>
					<span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">def_sid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">scontext2</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SECINITSID_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">initial_sid_to_string</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">scontext</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_KERNEL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>

	<span class="cm">/* Copy the string so that we can modify the copy as we parse it. */</span>
	<span class="n">scontext2</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">scontext_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scontext2</span><span class="p">,</span> <span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">);</span>
	<span class="n">scontext2</span><span class="p">[</span><span class="n">scontext_len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save another copy for storing in uninterpreted form */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">scontext2</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">string_to_context_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">scontext2</span><span class="p">,</span>
				      <span class="n">scontext_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">def_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">&amp;&amp;</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
		<span class="n">context</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">scontext_len</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">scontext2</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_context_to_sid - Obtain a SID for a given security context.</span>
<span class="cm"> * @scontext: security context</span>
<span class="cm"> * @scontext_len: length in bytes</span>
<span class="cm"> * @sid: security identifier, SID</span>
<span class="cm"> *</span>
<span class="cm"> * Obtains a SID associated with the security context that</span>
<span class="cm"> * has the string representation specified by @scontext.</span>
<span class="cm"> * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient</span>
<span class="cm"> * memory is available, or 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_context_to_sid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scontext_len</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_context_to_sid_core</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">,</span>
					    <span class="n">sid</span><span class="p">,</span> <span class="n">SECSID_NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_context_to_sid_default - Obtain a SID for a given security context,</span>
<span class="cm"> * falling back to specified default if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * @scontext: security context</span>
<span class="cm"> * @scontext_len: length in bytes</span>
<span class="cm"> * @sid: security identifier, SID</span>
<span class="cm"> * @def_sid: default SID to assign on error</span>
<span class="cm"> *</span>
<span class="cm"> * Obtains a SID associated with the security context that</span>
<span class="cm"> * has the string representation specified by @scontext.</span>
<span class="cm"> * The default SID is passed to the MLS layer to be used to allow</span>
<span class="cm"> * kernel labeling of the MLS field if the MLS field is not present</span>
<span class="cm"> * (for upgrading to MLS without full relabel).</span>
<span class="cm"> * Implicitly forces adding of the context even if it cannot be mapped yet.</span>
<span class="cm"> * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient</span>
<span class="cm"> * memory is available, or 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_context_to_sid_default</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scontext_len</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">def_sid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_context_to_sid_core</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">,</span>
					    <span class="n">sid</span><span class="p">,</span> <span class="n">def_sid</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_context_to_sid_force</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scontext_len</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_context_to_sid_core</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">scontext_len</span><span class="p">,</span>
					    <span class="n">sid</span><span class="p">,</span> <span class="n">SECSID_NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compute_sid_handle_invalid_context</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">tcontext</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">newcontext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">slen</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">nlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">tcontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">newcontext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
		  <span class="s">&quot;security_compute_sid:  invalid context %s&quot;</span>
		  <span class="s">&quot; for scontext=%s&quot;</span>
		  <span class="s">&quot; tcontext=%s&quot;</span>
		  <span class="s">&quot; tclass=%s&quot;</span><span class="p">,</span>
		  <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_CLASSES</span><span class="p">,</span> <span class="n">tclass</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selinux_enforcing</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filename_compute_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">newcontext</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">stype</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">objname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filename_trans</span> <span class="n">ft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filename_trans_datum</span> <span class="o">*</span><span class="n">otype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Most filename trans rules are going to live in specific directories</span>
<span class="cm">	 * like /dev or /var/run.  This bitmap will quickly skip rule searches</span>
<span class="cm">	 * if the ttype does not contain any rules.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">filename_trans_ttypes</span><span class="p">,</span> <span class="n">ttype</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ft</span><span class="p">.</span><span class="n">stype</span> <span class="o">=</span> <span class="n">stype</span><span class="p">;</span>
	<span class="n">ft</span><span class="p">.</span><span class="n">ttype</span> <span class="o">=</span> <span class="n">ttype</span><span class="p">;</span>
	<span class="n">ft</span><span class="p">.</span><span class="n">tclass</span> <span class="o">=</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="n">ft</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">objname</span><span class="p">;</span>

	<span class="n">otype</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">filename_trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ft</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otype</span><span class="p">)</span>
		<span class="n">newcontext</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">otype</span><span class="o">-&gt;</span><span class="n">otype</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">security_compute_sid</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">orig_tclass</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">specified</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">objname</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">cladatum</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">scontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tcontext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">newcontext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_trans</span> <span class="o">*</span><span class="n">roletr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">avtab_key</span> <span class="n">avkey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">avtab_datum</span> <span class="o">*</span><span class="n">avdatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">avtab_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">orig_tclass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SECCLASS_PROCESS</span>: <span class="cm">/* kernel value */</span>
			<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">ssid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">tsid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcontext</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kern</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tclass</span> <span class="o">=</span> <span class="n">unmap_class</span><span class="p">(</span><span class="n">orig_tclass</span><span class="p">);</span>
		<span class="n">sock</span> <span class="o">=</span> <span class="n">security_is_socket_class</span><span class="p">(</span><span class="n">orig_tclass</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tclass</span> <span class="o">=</span> <span class="n">orig_tclass</span><span class="p">;</span>
		<span class="n">sock</span> <span class="o">=</span> <span class="n">security_is_socket_class</span><span class="p">(</span><span class="n">map_class</span><span class="p">(</span><span class="n">tclass</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">scontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ssid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcontext</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcontext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">tsid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span> <span class="o">&amp;&amp;</span> <span class="n">tclass</span> <span class="o">&lt;=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">nprim</span><span class="p">)</span>
		<span class="n">cladatum</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">class_val_to_struct</span><span class="p">[</span><span class="n">tclass</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Set the user identity. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">specified</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AVTAB_TRANSITION</span>:
	<span class="k">case</span> <span class="n">AVTAB_CHANGE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cladatum</span> <span class="o">&amp;&amp;</span> <span class="n">cladatum</span><span class="o">-&gt;</span><span class="n">default_user</span> <span class="o">==</span> <span class="n">DEFAULT_TARGET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* notice this gets both DEFAULT_SOURCE and unset */</span>
			<span class="cm">/* Use the process user identity. */</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AVTAB_MEMBER</span>:
		<span class="cm">/* Use the related object owner. */</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the role to default values. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cladatum</span> <span class="o">&amp;&amp;</span> <span class="n">cladatum</span><span class="o">-&gt;</span><span class="n">default_role</span> <span class="o">==</span> <span class="n">DEFAULT_SOURCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cladatum</span> <span class="o">&amp;&amp;</span> <span class="n">cladatum</span><span class="o">-&gt;</span><span class="n">default_role</span> <span class="o">==</span> <span class="n">DEFAULT_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tclass</span> <span class="o">==</span> <span class="n">policydb</span><span class="p">.</span><span class="n">process_class</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">true</span><span class="p">))</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">OBJECT_R_VAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the type to default values. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cladatum</span> <span class="o">&amp;&amp;</span> <span class="n">cladatum</span><span class="o">-&gt;</span><span class="n">default_type</span> <span class="o">==</span> <span class="n">DEFAULT_SOURCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cladatum</span> <span class="o">&amp;&amp;</span> <span class="n">cladatum</span><span class="o">-&gt;</span><span class="n">default_type</span> <span class="o">==</span> <span class="n">DEFAULT_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tclass</span> <span class="o">==</span> <span class="n">policydb</span><span class="p">.</span><span class="n">process_class</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Use the type of process. */</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Use the type of the related object. */</span>
			<span class="n">newcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Look for a type transition/member/change rule. */</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">source_type</span> <span class="o">=</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">target_class</span> <span class="o">=</span> <span class="n">tclass</span><span class="p">;</span>
	<span class="n">avkey</span><span class="p">.</span><span class="n">specified</span> <span class="o">=</span> <span class="n">specified</span><span class="p">;</span>
	<span class="n">avdatum</span> <span class="o">=</span> <span class="n">avtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">te_avtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avkey</span><span class="p">);</span>

	<span class="cm">/* If no permanent rule, also check for enabled conditional rules */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avdatum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">avtab_search_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">te_cond_avtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avkey</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">node</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">avtab_search_node_next</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">specified</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">specified</span> <span class="o">&amp;</span> <span class="n">AVTAB_ENABLED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">avdatum</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">datum</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">avdatum</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Use the type from the type transition/member/change rule. */</span>
		<span class="n">newcontext</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">avdatum</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we have a objname this is a file trans check so check those rules */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">objname</span><span class="p">)</span>
		<span class="n">filename_compute_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcontext</span><span class="p">,</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
				      <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">objname</span><span class="p">);</span>

	<span class="cm">/* Check for class-specific changes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">specified</span> <span class="o">&amp;</span> <span class="n">AVTAB_TRANSITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for a role transition rule. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">roletr</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">role_tr</span><span class="p">;</span> <span class="n">roletr</span><span class="p">;</span> <span class="n">roletr</span> <span class="o">=</span> <span class="n">roletr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">roletr</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">scontext</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">roletr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">tcontext</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">roletr</span><span class="o">-&gt;</span><span class="n">tclass</span> <span class="o">==</span> <span class="n">tclass</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Use the role transition rule. */</span>
				<span class="n">newcontext</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">roletr</span><span class="o">-&gt;</span><span class="n">new_role</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set the MLS attributes.</span>
<span class="cm">	   This is done last because it may allocate memory. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_compute_sid</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span> <span class="n">tcontext</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">specified</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">newcontext</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Check the validity of the context. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb_context_isvalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcontext</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">compute_sid_handle_invalid_context</span><span class="p">(</span><span class="n">scontext</span><span class="p">,</span>
							<span class="n">tcontext</span><span class="p">,</span>
							<span class="n">tclass</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">newcontext</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Obtain the sid for the context. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcontext</span><span class="p">,</span> <span class="n">out_sid</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcontext</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_transition_sid - Compute the SID for a new subject/object.</span>
<span class="cm"> * @ssid: source security identifier</span>
<span class="cm"> * @tsid: target security identifier</span>
<span class="cm"> * @tclass: target security class</span>
<span class="cm"> * @out_sid: security identifier for new subject/object</span>
<span class="cm"> *</span>
<span class="cm"> * Compute a SID to use for labeling a new subject or object in the</span>
<span class="cm"> * class @tclass based on a SID pair (@ssid, @tsid).</span>
<span class="cm"> * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM</span>
<span class="cm"> * if insufficient memory is available, or %0 if the new SID was</span>
<span class="cm"> * computed successfully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_transition_sid</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_compute_sid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">AVTAB_TRANSITION</span><span class="p">,</span>
				    <span class="n">qstr</span> <span class="o">?</span> <span class="n">qstr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">out_sid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_transition_sid_user</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">objname</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_compute_sid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">AVTAB_TRANSITION</span><span class="p">,</span>
				    <span class="n">objname</span><span class="p">,</span> <span class="n">out_sid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_member_sid - Compute the SID for member selection.</span>
<span class="cm"> * @ssid: source security identifier</span>
<span class="cm"> * @tsid: target security identifier</span>
<span class="cm"> * @tclass: target security class</span>
<span class="cm"> * @out_sid: security identifier for selected member</span>
<span class="cm"> *</span>
<span class="cm"> * Compute a SID to use when selecting a member of a polyinstantiated</span>
<span class="cm"> * object of class @tclass based on a SID pair (@ssid, @tsid).</span>
<span class="cm"> * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM</span>
<span class="cm"> * if insufficient memory is available, or %0 if the SID was</span>
<span class="cm"> * computed successfully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_member_sid</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_compute_sid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">AVTAB_MEMBER</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">out_sid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_change_sid - Compute the SID for object relabeling.</span>
<span class="cm"> * @ssid: source security identifier</span>
<span class="cm"> * @tsid: target security identifier</span>
<span class="cm"> * @tclass: target security class</span>
<span class="cm"> * @out_sid: security identifier for selected member</span>
<span class="cm"> *</span>
<span class="cm"> * Compute a SID to use for relabeling an object of class @tclass</span>
<span class="cm"> * based on a SID pair (@ssid, @tsid).</span>
<span class="cm"> * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM</span>
<span class="cm"> * if insufficient memory is available, or %0 if the SID was</span>
<span class="cm"> * computed successfully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_change_sid</span><span class="p">(</span><span class="n">u32</span> <span class="n">ssid</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">tsid</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">tclass</span><span class="p">,</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_compute_sid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">tsid</span><span class="p">,</span> <span class="n">tclass</span><span class="p">,</span> <span class="n">AVTAB_CHANGE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">out_sid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clone the SID into the new SID table. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clone_sid</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sidtab</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;</span> <span class="n">SECINITSID_NUM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sidtab_insert</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">convert_context_handle_invalid_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selinux_enforcing</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SELinux:  Context %s would be invalid if enforcing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">convert_context_args</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">oldp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">newp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the values in the security context</span>
<span class="cm"> * structure `c&#39; from the values specified</span>
<span class="cm"> * in the policy `p-&gt;oldp&#39; to the values specified</span>
<span class="cm"> * in the policy `p-&gt;newp&#39;.  Verify that the</span>
<span class="cm"> * context is valid under the new policy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_context</span><span class="p">(</span><span class="n">u32</span> <span class="n">key</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">convert_context_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">oldc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mls_range</span> <span class="o">*</span><span class="n">range</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_datum</span> <span class="o">*</span><span class="n">role</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">typdatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_datum</span> <span class="o">*</span><span class="n">usrdatum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">SECINITSID_NUM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">context</span> <span class="n">ctx</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">string_to_context_struct</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
					      <span class="n">c</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SECSID_NULL</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux:  Context %s became valid (mapped).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
			<span class="cm">/* Replace string with mapped representation. */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Retain string representation for later mapping. */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Other error condition, e.g. ENOMEM. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:   Unable to map context %s, rc = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">context_cpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldc</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Convert the user. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">usrdatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">p_users</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
				  <span class="n">sym_name</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="p">,</span> <span class="n">SYM_USERS</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usrdatum</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">usrdatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Convert the role. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">role</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">p_roles</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
			      <span class="n">sym_name</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="p">,</span> <span class="n">SYM_ROLES</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">role</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">=</span> <span class="n">role</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Convert the type. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">typdatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">p_types</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
				  <span class="n">sym_name</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="p">,</span> <span class="n">SYM_TYPES</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">typdatum</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">typdatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Convert the MLS fields if dealing with MLS policies */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_convert_context</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Switching between MLS and non-MLS policy:</span>
<span class="cm">		 * free any storage used by the MLS fields in the</span>
<span class="cm">		 * context for all existing entries in the sidtab.</span>
<span class="cm">		 */</span>
		<span class="n">mls_context_destroy</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">oldp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">mls_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Switching between non-MLS and MLS policy:</span>
<span class="cm">		 * ensure that the MLS fields of the context for all</span>
<span class="cm">		 * existing entries in the sidtab are filled in with a</span>
<span class="cm">		 * suitable default value, likely taken from one of the</span>
<span class="cm">		 * initial SIDs.</span>
<span class="cm">		 */</span>
		<span class="n">oc</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="o">-&gt;</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_ISID</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">oc</span> <span class="o">&amp;&amp;</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">)</span>
			<span class="n">oc</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:  unable to look up&quot;</span>
				<span class="s">&quot; the initial SIDs list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">range</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_range_set</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check the validity of the new context. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb_context_isvalid</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">newp</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">convert_context_handle_invalid_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldc</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">bad:</span>
	<span class="cm">/* Map old representation to string and save it. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">context_struct_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldc</span><span class="p">);</span>
	<span class="n">context_destroy</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux:  Context %s became invalid (unmapped).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">security_load_policycaps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">selinux_policycap_netpeer</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">policycaps</span><span class="p">,</span>
						  <span class="n">POLICYDB_CAPABILITY_NETPEER</span><span class="p">);</span>
	<span class="n">selinux_policycap_openperm</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">policycaps</span><span class="p">,</span>
						  <span class="n">POLICYDB_CAPABILITY_OPENPERM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">security_preserve_bools</span><span class="p">(</span><span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * security_load_policy - Load a security policy configuration.</span>
<span class="cm"> * @data: binary policy data</span>
<span class="cm"> * @len: length of data in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Load a new set of security policy configuration data,</span>
<span class="cm"> * validate it and convert the SID table as necessary.</span>
<span class="cm"> * This function will flush the access vector cache after</span>
<span class="cm"> * loading the new policy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_load_policy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">policydb</span> <span class="n">oldpolicydb</span><span class="p">,</span> <span class="n">newpolicydb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sidtab</span> <span class="n">oldsidtab</span><span class="p">,</span> <span class="n">newsidtab</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">selinux_mapping</span> <span class="o">*</span><span class="n">oldmap</span><span class="p">,</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">convert_context_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">map_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">policy_file</span> <span class="n">file</span> <span class="o">=</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span> <span class="p">},</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">avtab_cache_init</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avtab_cache_destroy</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">policydb</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_set_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">secclass_map</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">current_mapping</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">current_mapping_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">policydb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">);</span>
			<span class="n">avtab_cache_destroy</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb_load_isids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sidtab</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">policydb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">);</span>
			<span class="n">avtab_cache_destroy</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">security_load_policycaps</span><span class="p">();</span>
		<span class="n">ss_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">seqno</span> <span class="o">=</span> <span class="o">++</span><span class="n">latest_granting</span><span class="p">;</span>
		<span class="n">selinux_complete_init</span><span class="p">();</span>
		<span class="n">avc_ss_reset</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selnl_notify_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selinux_status_update_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selinux_netlbl_cache_invalidate</span><span class="p">();</span>
		<span class="n">selinux_xfrm_notify_policyload</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	sidtab_hash_eval(&amp;sidtab, &quot;sids&quot;);</span>
<span class="cp">#endif</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">newpolicydb</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* If switching between different policy types, log MLS status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">mls_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newpolicydb</span><span class="p">.</span><span class="n">mls_enabled</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux: Disabling MLS support...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb</span><span class="p">.</span><span class="n">mls_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">newpolicydb</span><span class="p">.</span><span class="n">mls_enabled</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SELinux: Enabling MLS support...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb_load_isids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsidtab</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:  unable to load the initial SIDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">policydb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">selinux_set_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">,</span> <span class="n">secclass_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_preserve_bools</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:  unable to preserve booleans</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clone the SID table. */</span>
	<span class="n">sidtab_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">clone_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsidtab</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert the internal representations of contexts</span>
<span class="cm">	 * in the new SID table.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">oldp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">policydb</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">newp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsidtab</span><span class="p">,</span> <span class="n">convert_context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux:  unable to convert the internal&quot;</span>
			<span class="s">&quot; representation of contexts in the new SID&quot;</span>
			<span class="s">&quot; table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save the old policydb and SID table to free later. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldpolicydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">policydb</span><span class="p">);</span>
	<span class="n">sidtab_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sidtab</span><span class="p">);</span>

	<span class="cm">/* Install the new policydb and SID table. */</span>
	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">policydb</span><span class="p">);</span>
	<span class="n">sidtab_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsidtab</span><span class="p">);</span>
	<span class="n">security_load_policycaps</span><span class="p">();</span>
	<span class="n">oldmap</span> <span class="o">=</span> <span class="n">current_mapping</span><span class="p">;</span>
	<span class="n">current_mapping</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">current_mapping_size</span> <span class="o">=</span> <span class="n">map_size</span><span class="p">;</span>
	<span class="n">seqno</span> <span class="o">=</span> <span class="o">++</span><span class="n">latest_granting</span><span class="p">;</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="cm">/* Free the old policydb and SID table. */</span>
	<span class="n">policydb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldpolicydb</span><span class="p">);</span>
	<span class="n">sidtab_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsidtab</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">oldmap</span><span class="p">);</span>

	<span class="n">avc_ss_reset</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
	<span class="n">selnl_notify_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
	<span class="n">selinux_status_update_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
	<span class="n">selinux_netlbl_cache_invalidate</span><span class="p">();</span>
	<span class="n">selinux_xfrm_notify_policyload</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">sidtab_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsidtab</span><span class="p">);</span>
	<span class="n">policydb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newpolicydb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">security_policydb_len</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_port_sid - Obtain the SID for a port.</span>
<span class="cm"> * @protocol: protocol number</span>
<span class="cm"> * @port: port number</span>
<span class="cm"> * @out_sid: security identifier</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_port_sid</span><span class="p">(</span><span class="n">u8</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">u16</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_PORT</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">port</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">protocol</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">port</span><span class="p">.</span><span class="n">low_port</span> <span class="o">&lt;=</span> <span class="n">port</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">port</span><span class="p">.</span><span class="n">high_port</span> <span class="o">&gt;=</span> <span class="n">port</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">SECINITSID_PORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_netif_sid - Obtain the SID for a network interface.</span>
<span class="cm"> * @name: interface name</span>
<span class="cm"> * @if_sid: interface SID</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_netif_sid</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">if_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_NETIF</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						  <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">if_sid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">if_sid</span> <span class="o">=</span> <span class="n">SECINITSID_NETIF</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_ipv6_addrmask</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_node_sid - Obtain the SID for a node (host).</span>
<span class="cm"> * @domain: communication domain aka address family</span>
<span class="cm"> * @addrp: address</span>
<span class="cm"> * @addrlen: address length in bytes</span>
<span class="cm"> * @out_sid: security identifier</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_node_sid</span><span class="p">(</span><span class="n">u16</span> <span class="n">domain</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">addrp</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">addrlen</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="o">*</span><span class="n">out_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>: <span class="p">{</span>
		<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">addrp</span><span class="p">);</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_NODE</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="n">addr</span> <span class="o">==</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_NODE6</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_ipv6_addrmask</span><span class="p">(</span><span class="n">addrp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">node6</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
						<span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">node6</span><span class="p">.</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">SECINITSID_NODE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">out_sid</span> <span class="o">=</span> <span class="n">SECINITSID_NODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SIDS_NEL 25</span>

<span class="cm">/**</span>
<span class="cm"> * security_get_user_sids - Obtain reachable SIDs for a user.</span>
<span class="cm"> * @fromsid: starting SID</span>
<span class="cm"> * @username: username</span>
<span class="cm"> * @sids: array of reachable SIDs for user</span>
<span class="cm"> * @nel: number of elements in @sids</span>
<span class="cm"> *</span>
<span class="cm"> * Generate the set of SIDs for legal security contexts</span>
<span class="cm"> * for a given user that can be reached by @fromsid.</span>
<span class="cm"> * Set *@sids to point to a dynamically allocated</span>
<span class="cm"> * array containing the set of SIDs.  Set *@nel to the</span>
<span class="cm"> * number of elements in the array.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">security_get_user_sids</span><span class="p">(</span><span class="n">u32</span> <span class="n">fromsid</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">**</span><span class="n">sids</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">*</span><span class="n">nel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">fromcon</span><span class="p">,</span> <span class="n">usercon</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">mysids</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">mysids2</span><span class="p">,</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mynel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxnel</span> <span class="o">=</span> <span class="n">SIDS_NEL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_datum</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_datum</span> <span class="o">*</span><span class="n">role</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebitmap_node</span> <span class="o">*</span><span class="n">rnode</span><span class="p">,</span> <span class="o">*</span><span class="n">tnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="o">*</span><span class="n">sids</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">nel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usercon</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">fromcon</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">fromsid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fromcon</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">user</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_users</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">usercon</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mysids</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">maxnel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mysids</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mysids</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ebitmap_for_each_positive_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">roles</span><span class="p">,</span> <span class="n">rnode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">role</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">role_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">usercon</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ebitmap_for_each_positive_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">role</span><span class="o">-&gt;</span><span class="n">types</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usercon</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mls_setup_user_range</span><span class="p">(</span><span class="n">fromcon</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usercon</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usercon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mynel</span> <span class="o">&lt;</span> <span class="n">maxnel</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mysids</span><span class="p">[</span><span class="n">mynel</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">maxnel</span> <span class="o">+=</span> <span class="n">SIDS_NEL</span><span class="p">;</span>
				<span class="n">mysids2</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">maxnel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mysids2</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mysids2</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">mysids2</span><span class="p">,</span> <span class="n">mysids</span><span class="p">,</span> <span class="n">mynel</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mysids2</span><span class="p">));</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mysids</span><span class="p">);</span>
				<span class="n">mysids</span> <span class="o">=</span> <span class="n">mysids2</span><span class="p">;</span>
				<span class="n">mysids</span><span class="p">[</span><span class="n">mynel</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="o">!</span><span class="n">mynel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mysids</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mysids2</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">mynel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mysids2</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mysids2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mysids</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mynel</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">av_decision</span> <span class="n">dummy_avd</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">avc_has_perm_noaudit</span><span class="p">(</span><span class="n">fromsid</span><span class="p">,</span> <span class="n">mysids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					  <span class="n">SECCLASS_PROCESS</span><span class="p">,</span> <span class="cm">/* kernel value */</span>
					  <span class="n">PROCESS__TRANSITION</span><span class="p">,</span> <span class="n">AVC_STRICT</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dummy_avd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">mysids2</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mysids</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mysids</span><span class="p">);</span>
	<span class="o">*</span><span class="n">sids</span> <span class="o">=</span> <span class="n">mysids2</span><span class="p">;</span>
	<span class="o">*</span><span class="n">nel</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_genfs_sid - Obtain a SID for a file in a filesystem</span>
<span class="cm"> * @fstype: filesystem type</span>
<span class="cm"> * @path: path from root of mount</span>
<span class="cm"> * @sclass: file security class</span>
<span class="cm"> * @sid: SID for path</span>
<span class="cm"> *</span>
<span class="cm"> * Obtain a SID to use for a file in a filesystem that</span>
<span class="cm"> * cannot support xattr or use a fixed labeling behavior like</span>
<span class="cm"> * transition SIDs or task SIDs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_genfs_sid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fstype</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		       <span class="n">u16</span> <span class="n">orig_sclass</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sclass</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">genfs</span> <span class="o">*</span><span class="n">genfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">cmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
		<span class="n">path</span><span class="o">++</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">sclass</span> <span class="o">=</span> <span class="n">unmap_class</span><span class="p">(</span><span class="n">orig_sclass</span><span class="p">);</span>
	<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECINITSID_UNLABELED</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">genfs</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">genfs</span><span class="p">;</span> <span class="n">genfs</span><span class="p">;</span> <span class="n">genfs</span> <span class="o">=</span> <span class="n">genfs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">fstype</span><span class="p">,</span> <span class="n">genfs</span><span class="o">-&gt;</span><span class="n">fstype</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">genfs</span> <span class="o">||</span> <span class="n">cmp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">genfs</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">c</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">sclass</span> <span class="o">||</span> <span class="n">sclass</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">sclass</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_fs_use - Determine how to handle labeling for a filesystem.</span>
<span class="cm"> * @fstype: filesystem type</span>
<span class="cm"> * @behavior: labeling behavior</span>
<span class="cm"> * @sid: SID for filesystem (superblock)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_fs_use</span><span class="p">(</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fstype</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">behavior</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocontext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">ocontexts</span><span class="p">[</span><span class="n">OCON_FSUSE</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">fstype</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">behavior</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">behavior</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_genfs_sid</span><span class="p">(</span><span class="n">fstype</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">SECCLASS_DIR</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">behavior</span> <span class="o">=</span> <span class="n">SECURITY_FS_USE_NONE</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">behavior</span> <span class="o">=</span> <span class="n">SECURITY_FS_USE_GENFS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_bools</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">***</span><span class="n">names</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">values</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_bools</span><span class="p">.</span><span class="n">nprim</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">names</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">values</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">values</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">name_len</span><span class="p">;</span>

		<span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_BOOLS</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">strncpy</span><span class="p">((</span><span class="o">*</span><span class="n">names</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_BOOLS</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">name_len</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)[</span><span class="n">i</span><span class="p">][</span><span class="n">name_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">((</span><span class="o">*</span><span class="n">names</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">security_set_bools</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">seqno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cond_node</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">lenp</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_bools</span><span class="p">.</span><span class="n">nprim</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">lenp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
				<span class="n">AUDIT_MAC_CONFIG_CHANGE</span><span class="p">,</span>
				<span class="s">&quot;bool=%s val=%d old_val=%d auid=%u ses=%u&quot;</span><span class="p">,</span>
				<span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_BOOLS</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
				<span class="o">!!</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
				<span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
				<span class="n">audit_get_sessionid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">cond_list</span><span class="p">;</span> <span class="n">cur</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">evaluate_cond_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seqno</span> <span class="o">=</span> <span class="o">++</span><span class="n">latest_granting</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">avc_ss_reset</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selnl_notify_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selinux_status_update_policyload</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">selinux_xfrm_notify_policyload</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_bool_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">bool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_bools</span><span class="p">.</span><span class="n">nprim</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bool</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">bool_val_to_struct</span><span class="p">[</span><span class="n">bool</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">security_preserve_bools</span><span class="p">(</span><span class="k">struct</span> <span class="n">policydb</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">nbools</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">bvalues</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">bnames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cond_bool_datum</span> <span class="o">*</span><span class="n">booldatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cond_node</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">security_get_bools</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nbools</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bnames</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bvalues</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbools</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">booldatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p_bools</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">bnames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">booldatum</span><span class="p">)</span>
			<span class="n">booldatum</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">bvalues</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cond_list</span><span class="p">;</span> <span class="n">cur</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">evaluate_cond_node</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bnames</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbools</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bnames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bnames</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bvalues</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * security_sid_mls_copy() - computes a new sid based on the given</span>
<span class="cm"> * sid and the mls portion of mls_sid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_sid_mls_copy</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mls_sid</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">new_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">newcon</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span> <span class="o">||</span> <span class="o">!</span><span class="n">policydb</span><span class="p">.</span><span class="n">mls_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">new_sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcon</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">context1</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">context2</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">mls_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">mls_sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">newcon</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">context1</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
	<span class="n">newcon</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">context1</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
	<span class="n">newcon</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">context1</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_context_cpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcon</span><span class="p">,</span> <span class="n">context2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Check the validity of the new context. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb_context_isvalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcon</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">convert_context_handle_invalid_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcon</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context_struct_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
					  <span class="s">&quot;security_sid_mls_copy: invalid context %s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcon</span><span class="p">,</span> <span class="n">new_sid</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcon</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_net_peersid_resolve - Compare and resolve two network peer SIDs</span>
<span class="cm"> * @nlbl_sid: NetLabel SID</span>
<span class="cm"> * @nlbl_type: NetLabel labeling protocol type</span>
<span class="cm"> * @xfrm_sid: XFRM SID</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Compare the @nlbl_sid and @xfrm_sid values and if the two SIDs can be</span>
<span class="cm"> * resolved into a single SID it is returned via @peer_sid and the function</span>
<span class="cm"> * returns zero.  Otherwise @peer_sid is set to SECSID_NULL and the function</span>
<span class="cm"> * returns a negative value.  A table summarizing the behavior is below:</span>
<span class="cm"> *</span>
<span class="cm"> *                                 | function return |      @sid</span>
<span class="cm"> *   ------------------------------+-----------------+-----------------</span>
<span class="cm"> *   no peer labels                |        0        |    SECSID_NULL</span>
<span class="cm"> *   single peer label             |        0        |    &lt;peer_label&gt;</span>
<span class="cm"> *   multiple, consistent labels   |        0        |    &lt;peer_label&gt;</span>
<span class="cm"> *   multiple, inconsistent labels |    -&lt;errno&gt;     |    SECSID_NULL</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_net_peersid_resolve</span><span class="p">(</span><span class="n">u32</span> <span class="n">nlbl_sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">nlbl_type</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">xfrm_sid</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="o">*</span><span class="n">peer_sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">nlbl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">xfrm_ctx</span><span class="p">;</span>

	<span class="o">*</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>

	<span class="cm">/* handle the common (which also happens to be the set of easy) cases</span>
<span class="cm">	 * right away, these two if statements catch everything involving a</span>
<span class="cm">	 * single or absent peer SID/label */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfrm_sid</span> <span class="o">==</span> <span class="n">SECSID_NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">nlbl_sid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a &quot;fallback&quot; label</span>
<span class="cm">	 * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label</span>
<span class="cm">	 * is present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlbl_sid</span> <span class="o">==</span> <span class="n">SECSID_NULL</span> <span class="o">||</span> <span class="n">nlbl_type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">xfrm_sid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we don&#39;t need to check ss_initialized here since the only way both</span>
<span class="cm">	 * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the</span>
<span class="cm">	 * security server was initialized and ss_initialized was true */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policydb</span><span class="p">.</span><span class="n">mls_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">nlbl_ctx</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">nlbl_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nlbl_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">nlbl_sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">xfrm_ctx</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">xfrm_sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfrm_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">xfrm_sid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">mls_context_cmp</span><span class="p">(</span><span class="n">nlbl_ctx</span><span class="p">,</span> <span class="n">xfrm_ctx</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* at present NetLabel SIDs/labels really only carry MLS</span>
<span class="cm">	 * information so if the MLS portion of the NetLabel SID</span>
<span class="cm">	 * matches the MLS portion of the labeled XFRM SID/label</span>
<span class="cm">	 * then pass along the XFRM SID as it is the most</span>
<span class="cm">	 * expressive */</span>
	<span class="o">*</span><span class="n">peer_sid</span> <span class="o">=</span> <span class="n">xfrm_sid</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_classes_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">datum</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">classes</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">datum</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">classes</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">classes</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_classes</span><span class="p">(</span><span class="kt">char</span> <span class="o">***</span><span class="n">classes</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nclasses</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">nclasses</span> <span class="o">=</span> <span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">nprim</span><span class="p">;</span>
	<span class="o">*</span><span class="n">classes</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="o">*</span><span class="n">nclasses</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">**</span><span class="n">classes</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">classes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hashtab_map</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">get_classes_callback</span><span class="p">,</span>
			<span class="o">*</span><span class="n">classes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">nclasses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">((</span><span class="o">*</span><span class="n">classes</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">classes</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_permissions_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perm_datum</span> <span class="o">*</span><span class="n">datum</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">perms</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">datum</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">perms</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">perms</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_permissions</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="kt">char</span> <span class="o">***</span><span class="n">perms</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nperms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class_datum</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">match</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_classes</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SELinux: %s:  unrecognized class %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">nperms</span> <span class="o">=</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">.</span><span class="n">nprim</span><span class="p">;</span>
	<span class="o">*</span><span class="n">perms</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="o">*</span><span class="n">nperms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">**</span><span class="n">perms</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">perms</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">comdatum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">hashtab_map</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">comdatum</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">.</span><span class="n">table</span><span class="p">,</span>
				<span class="n">get_permissions_callback</span><span class="p">,</span> <span class="o">*</span><span class="n">perms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hashtab_map</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">permissions</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">get_permissions_callback</span><span class="p">,</span>
			<span class="o">*</span><span class="n">perms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">nperms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">((</span><span class="o">*</span><span class="n">perms</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">perms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_reject_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">policydb</span><span class="p">.</span><span class="n">reject_unknown</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">security_get_allow_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">policydb</span><span class="p">.</span><span class="n">allow_unknown</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_policycap_supported - Check for a specific policy capability</span>
<span class="cm"> * @req_cap: capability</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function queries the currently loaded policy to see if it supports the</span>
<span class="cm"> * capability specified by @req_cap.  Returns true (1) if the capability is</span>
<span class="cm"> * supported, false (0) if it isn&#39;t supported.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_policycap_supported</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ebitmap_get_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">.</span><span class="n">policycaps</span><span class="p">,</span> <span class="n">req_cap</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">au_seqno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">au_ctxt</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">selinux_audit_rule_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="n">vrule</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rule</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">selinux_audit_rule_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="o">*</span><span class="n">tmprule</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">role_datum</span> <span class="o">*</span><span class="n">roledatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_datum</span> <span class="o">*</span><span class="n">typedatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_datum</span> <span class="o">*</span><span class="n">userdatum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="o">**</span><span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="o">**</span><span class="p">)</span><span class="n">vrule</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="cm">/* only &#39;equals&#39; and &#39;not equals&#39; fit user, role, and type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_equal</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
		<span class="cm">/* we do not allow a range, indicated by the presence of &#39;-&#39; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">rulestr</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* only the above fields are valid */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmprule</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">selinux_audit_rule</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmprule</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_seqno</span> <span class="o">=</span> <span class="n">latest_granting</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">userdatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_users</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">rulestr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">userdatum</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">userdatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">roledatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_roles</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">rulestr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">roledatum</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">roledatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">typedatum</span> <span class="o">=</span> <span class="n">hashtab_search</span><span class="p">(</span><span class="n">policydb</span><span class="p">.</span><span class="n">p_types</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">rulestr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">typedatum</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">typedatum</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_from_string</span><span class="p">(</span><span class="n">rulestr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmprule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">selinux_audit_rule_free</span><span class="p">(</span><span class="n">tmprule</span><span class="p">);</span>
		<span class="n">tmprule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="n">tmprule</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check to see if the rule contains any selinux fields */</span>
<span class="kt">int</span> <span class="nf">selinux_audit_rule_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">selinux_audit_rule_match</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vrule</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mls_level</span> <span class="o">*</span><span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">selinux_audit_rule</span> <span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="n">vrule</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rule</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log</span><span class="p">(</span><span class="n">actx</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
			  <span class="s">&quot;selinux_audit_rule_match: missing rule</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_seqno</span> <span class="o">&lt;</span> <span class="n">latest_granting</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log</span><span class="p">(</span><span class="n">actx</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
			  <span class="s">&quot;selinux_audit_rule_match: stale rule</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctxt</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log</span><span class="p">(</span><span class="n">actx</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
			  <span class="s">&quot;selinux_audit_rule_match: unrecognized SID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sid</span><span class="p">);</span>
		<span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* a field/op pair that is not caught here will simply fall through</span>
<span class="cm">	   without a match */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Audit_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">==</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">user</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_not_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">!=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">user</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Audit_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">role</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_not_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">!=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">role</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Audit_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_not_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
	<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
	<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
		<span class="n">level</span> <span class="o">=</span> <span class="p">((</span><span class="n">field</span> <span class="o">==</span> <span class="n">AUDIT_SUBJ_SEN</span> <span class="o">||</span>
			  <span class="n">field</span> <span class="o">==</span> <span class="n">AUDIT_OBJ_LEV_LOW</span><span class="p">)</span> <span class="o">?</span>
			 <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Audit_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="n">mls_level_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					     <span class="n">level</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_not_equal</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="o">!</span><span class="n">mls_level_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					      <span class="n">level</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_lt</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">mls_level_dom</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					       <span class="n">level</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="n">mls_level_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					       <span class="n">level</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_le</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="n">mls_level_dom</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					      <span class="n">level</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_gt</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">mls_level_dom</span><span class="p">(</span><span class="n">level</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="n">mls_level_eq</span><span class="p">(</span><span class="n">level</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Audit_ge</span>:
			<span class="n">match</span> <span class="o">=</span> <span class="n">mls_level_dom</span><span class="p">(</span><span class="n">level</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">au_ctxt</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aurule_callback</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">audit_update_lsm_rules</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">aurule_avc_callback</span><span class="p">(</span><span class="n">u32</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">AVC_CALLBACK_RESET</span> <span class="o">&amp;&amp;</span> <span class="n">aurule_callback</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">aurule_callback</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">aurule_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">avc_add_callback</span><span class="p">(</span><span class="n">aurule_avc_callback</span><span class="p">,</span> <span class="n">AVC_CALLBACK_RESET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;avc_add_callback() failed, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">aurule_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NETLABEL</span>
<span class="cm">/**</span>
<span class="cm"> * security_netlbl_cache_add - Add an entry to the NetLabel cache</span>
<span class="cm"> * @secattr: the NetLabel packet security attributes</span>
<span class="cm"> * @sid: the SELinux SID</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Attempt to cache the context in @ctx, which was derived from the packet in</span>
<span class="cm"> * @skb, in the NetLabel subsystem cache.  This function assumes @secattr has</span>
<span class="cm"> * already been initialized.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">security_netlbl_cache_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">sid_cache</span><span class="p">;</span>

	<span class="n">sid_cache</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sid_cache</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span> <span class="o">=</span> <span class="n">netlbl_secattr_cache_alloc</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sid_cache</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">sid_cache</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">kfree</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">sid_cache</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETLBL_SECATTR_CACHE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_netlbl_secattr_to_sid - Convert a NetLabel secattr to a SELinux SID</span>
<span class="cm"> * @secattr: the NetLabel packet security attributes</span>
<span class="cm"> * @sid: the SELinux SID</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Convert the given NetLabel security attributes in @secattr into a</span>
<span class="cm"> * SELinux SID.  If the @secattr field does not contain a full SELinux</span>
<span class="cm"> * SID/context then use SECINITSID_NETMSG as the foundation.  If possible the</span>
<span class="cm"> * &#39;cache&#39; field of @secattr is set and the CACHE flag is set; this is to</span>
<span class="cm"> * allow the @secattr to be used by NetLabel to cache the secattr to SID</span>
<span class="cm"> * conversion for future lookups.  Returns zero on success, negative values on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_netlbl_secattr_to_sid</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">ctx_new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_CACHE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_SECID</span><span class="p">)</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">secid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_MLS_LVL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">SECINITSID_NETMSG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">);</span>
		<span class="n">ctx_new</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
		<span class="n">ctx_new</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">;</span>
		<span class="n">ctx_new</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">mls_import_netlbl_lvl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_MLS_CAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ebitmap_netlbl_import</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span>
						   <span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cat</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mls_context_isvalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">sidtab_context_to_sid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">security_netlbl_cache_add</span><span class="p">(</span><span class="n">secattr</span><span class="p">,</span> <span class="o">*</span><span class="n">sid</span><span class="p">);</span>

		<span class="n">ebitmap_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cat</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="n">SECSID_NULL</span><span class="p">;</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">ebitmap_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_new</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cat</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * security_netlbl_sid_to_secattr - Convert a SELinux SID to a NetLabel secattr</span>
<span class="cm"> * @sid: the SELinux SID</span>
<span class="cm"> * @secattr: the NetLabel packet security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Convert the given SELinux SID in @sid into a NetLabel security attribute.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_netlbl_sid_to_secattr</span><span class="p">(</span><span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">sidtab_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidtab</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">sym_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="n">SYM_TYPES</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				  <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">secid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETLBL_SECATTR_DOMAIN_CPY</span> <span class="o">|</span> <span class="n">NETLBL_SECATTR_SECID</span><span class="p">;</span>
	<span class="n">mls_export_netlbl_lvl</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mls_export_netlbl_cat</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NETLABEL */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * security_read_policy - read the policy.</span>
<span class="cm"> * @data: binary policy data</span>
<span class="cm"> * @len: length of data in bytes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">security_read_policy</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">policy_file</span> <span class="n">fp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">security_policydb_len</span><span class="p">();</span>

	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">vmalloc_user</span><span class="p">(</span><span class="o">*</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">policydb_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policydb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy_rwlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fp</span><span class="p">.</span><span class="n">data</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
