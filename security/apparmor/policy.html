<!DOCTYPE html>
<html><head><title>joekychen/linux » security › apparmor › policy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>policy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * AppArmor security module</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains AppArmor policy manipulation functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2008 Novell/SUSE</span>
<span class="cm"> * Copyright 2009-2010 Canonical Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation, version 2 of the</span>
<span class="cm"> * License.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * AppArmor policy is based around profiles, which contain the rules a</span>
<span class="cm"> * task is confined by.  Every task in the system has a profile attached</span>
<span class="cm"> * to it determined either by matching &quot;unconfined&quot; tasks against the</span>
<span class="cm"> * visible set of profiles or by following a profiles attachment rules.</span>
<span class="cm"> *</span>
<span class="cm"> * Each profile exists in a profile namespace which is a container of</span>
<span class="cm"> * visible profiles.  Each namespace contains a special &quot;unconfined&quot; profile,</span>
<span class="cm"> * which doesn&#39;t enforce any confinement on a task beyond DAC.</span>
<span class="cm"> *</span>
<span class="cm"> * Namespace and profile names can be written together in either</span>
<span class="cm"> * of two syntaxes.</span>
<span class="cm"> *	:namespace:profile - used by kernel interfaces for easy detection</span>
<span class="cm"> *	namespace://profile - used by policy</span>
<span class="cm"> *</span>
<span class="cm"> * Profile names can not start with : or @ or ^ and may not contain \0</span>
<span class="cm"> *</span>
<span class="cm"> * Reserved profile names</span>
<span class="cm"> *	unconfined - special automatically generated unconfined profile</span>
<span class="cm"> *	inherit - special name to indicate profile inheritance</span>
<span class="cm"> *	null-XXXX-YYYY - special automatically generated learning profiles</span>
<span class="cm"> *</span>
<span class="cm"> * Namespace names may not start with / or @ and may not contain \0 or :</span>
<span class="cm"> * Reserved namespace names</span>
<span class="cm"> *	user-XXXX - user defined profiles</span>
<span class="cm"> *</span>
<span class="cm"> * a // in a profile or namespace name indicates a hierarchical name with the</span>
<span class="cm"> * name before the // being the parent and the name after the child.</span>
<span class="cm"> *</span>
<span class="cm"> * Profile and namespace hierarchies serve two different but similar purposes.</span>
<span class="cm"> * The namespace contains the set of visible profiles that are considered</span>
<span class="cm"> * for attachment.  The hierarchy of namespaces allows for virtualizing</span>
<span class="cm"> * the namespace so that for example a chroot can have its own set of profiles</span>
<span class="cm"> * which may define some local user namespaces.</span>
<span class="cm"> * The profile hierarchy severs two distinct purposes,</span>
<span class="cm"> * -  it allows for sub profiles or hats, which allows an application to run</span>
<span class="cm"> *    subprograms under its own profile with different restriction than it</span>
<span class="cm"> *    self, and not have it use the system profile.</span>
<span class="cm"> *    eg. if a mail program starts an editor, the policy might make the</span>
<span class="cm"> *        restrictions tighter on the editor tighter than the mail program,</span>
<span class="cm"> *        and definitely different than general editor restrictions</span>
<span class="cm"> * - it allows for binary hierarchy of profiles, so that execution history</span>
<span class="cm"> *   is preserved.  This feature isn&#39;t exploited by AppArmor reference policy</span>
<span class="cm"> *   but is allowed.  NOTE: this is currently suboptimal because profile</span>
<span class="cm"> *   aliasing is not currently implemented so that a profile for each</span>
<span class="cm"> *   level must be defined.</span>
<span class="cm"> *   eg. /bin/bash///bin/ls as a name would indicate /bin/ls was started</span>
<span class="cm"> *       from /bin/bash</span>
<span class="cm"> *</span>
<span class="cm"> *   A profile or namespace name that can contain one or more // separators</span>
<span class="cm"> *   is referred to as an hname (hierarchical).</span>
<span class="cm"> *   eg.  /bin/bash//bin/ls</span>
<span class="cm"> *</span>
<span class="cm"> *   An fqname is a name that may contain both namespace and profile hnames.</span>
<span class="cm"> *   eg. :ns:/bin/bash//bin/ls</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *   - locking of profile lists is currently fairly coarse.  All profile</span>
<span class="cm"> *     lists within a namespace use the namespace lock.</span>
<span class="cm"> * FIXME: move profile lists to using rcu_lists</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>

<span class="cp">#include &quot;include/apparmor.h&quot;</span>
<span class="cp">#include &quot;include/capability.h&quot;</span>
<span class="cp">#include &quot;include/context.h&quot;</span>
<span class="cp">#include &quot;include/file.h&quot;</span>
<span class="cp">#include &quot;include/ipc.h&quot;</span>
<span class="cp">#include &quot;include/match.h&quot;</span>
<span class="cp">#include &quot;include/path.h&quot;</span>
<span class="cp">#include &quot;include/policy.h&quot;</span>
<span class="cp">#include &quot;include/policy_unpack.h&quot;</span>
<span class="cp">#include &quot;include/resource.h&quot;</span>
<span class="cp">#include &quot;include/sid.h&quot;</span>


<span class="cm">/* root profile namespace */</span>
<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">root_ns</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">profile_mode_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;enforce&quot;</span><span class="p">,</span>
	<span class="s">&quot;complain&quot;</span><span class="p">,</span>
	<span class="s">&quot;kill&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * hname_tail - find the last component of an hname</span>
<span class="cm"> * @name: hname to find the base profile name component of  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: the tail (base profile name) name component of an hname</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">hname_tail</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>
	<span class="n">hname</span> <span class="o">=</span> <span class="n">strim</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hname</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">);</span> <span class="n">split</span><span class="p">;</span> <span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">))</span>
		<span class="n">hname</span> <span class="o">=</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hname</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * policy_init - initialize a policy structure</span>
<span class="cm"> * @policy: policy to initialize  (NOT NULL)</span>
<span class="cm"> * @prefix: prefix name if any is required.  (MAYBE NULL)</span>
<span class="cm"> * @name: name of the policy, init will make a copy of it  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this fn creates a copy of strings passed in</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: true if policy init successful</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">policy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* freed by policy_free */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;%s//%s&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* base.name is a substring of fqname */</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hname_tail</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * policy_destroy - free the elements referenced by @policy</span>
<span class="cm"> * @policy: policy that is to have its elements freed  (NOT NULL)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">policy_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* still contains profiles -- invalid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: internal error, &quot;</span>
			 <span class="s">&quot;policy &#39;%s&#39; still contains profiles</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: internal error, policy &#39;%s&#39; still on list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t free name as its a subset of hname */</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">hname</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __policy_find - find a policy by @name on a policy list</span>
<span class="cm"> * @head: list to search  (NOT NULL)</span>
<span class="cm"> * @name: name to search for  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: correct locks for the @head list be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted policy that match @name or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="nf">__policy_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">policy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __policy_strn_find - find a policy that&#39;s name matches @len chars of @str</span>
<span class="cm"> * @head: list to search  (NOT NULL)</span>
<span class="cm"> * @str: string to search for  (NOT NULL)</span>
<span class="cm"> * @len: length of match required</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: correct locks for the @head list be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted policy that match @str or NULL if not found</span>
<span class="cm"> *</span>
<span class="cm"> * if @len == strlen(@strlen) then this is equiv to __policy_find</span>
<span class="cm"> * other wise it allows searching for policy by a partial match of name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="nf">__policy_strn_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">aa_strneq</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">policy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Routines for AppArmor namespaces</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hidden_ns_name</span> <span class="o">=</span> <span class="s">&quot;---&quot;</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * aa_ns_visible - test if @view is visible from @curr</span>
<span class="cm"> * @curr: namespace to treat as the parent (NOT NULL)</span>
<span class="cm"> * @view:  namespace to test if visible from @curr (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: true if @view is visible from @curr else false</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">aa_ns_visible</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">view</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">view</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">view</span><span class="p">;</span> <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">curr</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_na_name - Find the ns name to display for @view from @curr</span>
<span class="cm"> * @curr - current namespace (NOT NULL)</span>
<span class="cm"> * @view - namespace attempting to view (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: name of @view visible from @curr</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">aa_ns_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">view</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if view == curr then the namespace name isn&#39;t displayed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">view</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aa_ns_visible</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">view</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* at this point if a ns is visible it is in a view ns</span>
<span class="cm">		 * thus the curr ns.hname is a prefix of its name.</span>
<span class="cm">		 * Only output the virtualized portion of the name</span>
<span class="cm">		 * Add + 2 to skip over // separating curr hname prefix</span>
<span class="cm">		 * from the visible tail of the views hname</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">hidden_ns_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_namespace - allocate, initialize and return a new namespace</span>
<span class="cm"> * @prefix: parent namespace name (MAYBE NULL)</span>
<span class="cm"> * @name: a preallocated name  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: refcounted namespace or NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="nf">alloc_namespace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">AA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_ns</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* released by free_namespace */</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span> <span class="o">=</span> <span class="n">aa_alloc_profile</span><span class="p">(</span><span class="s">&quot;unconfined&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_unconfined</span><span class="p">;</span>

	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">aa_alloc_sid</span><span class="p">();</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PFLAG_UNCONFINED</span> <span class="o">|</span> <span class="n">PFLAG_IX_ON_NAME_ERROR</span> <span class="o">|</span>
	    <span class="n">PFLAG_IMMUTABLE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * released by free_namespace, however __remove_namespace breaks</span>
<span class="cm">	 * the cyclic references (ns-&gt;unconfined, and unconfined-&gt;ns) and</span>
<span class="cm">	 * replaces with refs to parent namespace unconfined</span>
<span class="cm">	 */</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>

<span class="nl">fail_unconfined:</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">);</span>
<span class="nl">fail_ns:</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_namespace - free a profile namespace</span>
<span class="cm"> * @ns: the namespace to free  (MAYBE NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: All references to the namespace must have been put, if the</span>
<span class="cm"> *           namespace was referenced by a profile confining a task,</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">policy_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span> <span class="o">&amp;&amp;</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">==</span> <span class="n">ns</span><span class="p">)</span>
		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">);</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_free_namespace_kref - free aa_namespace by kref (see aa_put_namespace)</span>
<span class="cm"> * @kr: kref callback for freeing of a namespace  (NOT NULL)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">aa_free_namespace_kref</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_namespace</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_namespace</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __aa_find_namespace - find a namespace on a list by @name</span>
<span class="cm"> * @head: list to search for namespace on  (NOT NULL)</span>
<span class="cm"> * @name: name of namespace to look for  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted namespace</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns lock be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="nf">__aa_find_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="p">)</span><span class="n">__policy_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_find_namespace  -  look up a profile namespace on the namespace list</span>
<span class="cm"> * @root: namespace to search in  (NOT NULL)</span>
<span class="cm"> * @name: name of namespace to find  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: a refcounted namespace on the list, or NULL if no namespace</span>
<span class="cm"> *          called @name exists.</span>
<span class="cm"> *</span>
<span class="cm"> * refcount released by caller</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="nf">aa_find_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">__aa_find_namespace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_prepare_namespace - find an existing or create a new namespace of @name</span>
<span class="cm"> * @name: the namespace to find or add  (MAYBE NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: refcounted namespace or NULL if failed to create one</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="nf">aa_prepare_namespace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">aa_current_profile</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* if name isn&#39;t specified the profile is loaded to the current ns */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* released by caller */</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try and find the specified ns and if it doesn&#39;t exist create it */</span>
	<span class="cm">/* released by caller */</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">__aa_find_namespace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* namespace not found */</span>
		<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">new_ns</span><span class="p">;</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">new_ns</span> <span class="o">=</span> <span class="n">alloc_namespace</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ns</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* test for race when new_ns was allocated */</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">__aa_find_namespace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* add parent ref */</span>
			<span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">);</span>
			<span class="cm">/* add list ref */</span>
			<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">new_ns</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* raced so free the new one */</span>
			<span class="n">free_namespace</span><span class="p">(</span><span class="n">new_ns</span><span class="p">);</span>
			<span class="cm">/* get reference on namespace */</span>
			<span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* return ref */</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __list_add_profile - add a profile to a list</span>
<span class="cm"> * @list: list to add it to  (NOT NULL)</span>
<span class="cm"> * @profile: the profile to add  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * refcount @profile, should be put by __list_remove_profile</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace lock be held, or list not be shared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__list_add_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="cm">/* get list reference */</span>
	<span class="n">aa_get_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __list_remove_profile - remove a profile from the list it is on</span>
<span class="cm"> * @profile: the profile to remove  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * remove a profile from the list, warning generally removal should</span>
<span class="cm"> * be done with __replace_profile as most profile removals are</span>
<span class="cm"> * replacements to the unconfined profile.</span>
<span class="cm"> *</span>
<span class="cm"> * put @profile list refcount</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace lock be held, or list not have been live</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__list_remove_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PFLAG_NO_LIST_REF</span><span class="p">))</span>
		<span class="cm">/* release list reference */</span>
		<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __replace_profile - replace @old with @new on a list</span>
<span class="cm"> * @old: profile to be replaced  (NOT NULL)</span>
<span class="cm"> * @new: profile to replace @old with  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Will duplicate and refcount elements that @new inherits from @old</span>
<span class="cm"> * and will inherit @old children.</span>
<span class="cm"> *</span>
<span class="cm"> * refcount @new for list, put @old list refcount</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace list lock be held, or list not be shared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__replace_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">policy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">policy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* released when @new is freed */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">;</span>
	<span class="n">__list_add_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="cm">/* inherit children */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="cm">/* list refcount transferred to @new*/</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* released by free_profile */</span>
	<span class="n">old</span><span class="o">-&gt;</span><span class="n">replacedby</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">__list_remove_profile</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__profile_list_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __remove_profile - remove old profile, and children</span>
<span class="cm"> * @profile: profile to be replaced  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace list lock be held, or list not be shared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__remove_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* release any children lists first */</span>
	<span class="n">__profile_list_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">);</span>
	<span class="cm">/* released by free_profile */</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">replacedby</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">);</span>
	<span class="n">__list_remove_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __profile_list_release - remove all profiles on the list and put refs</span>
<span class="cm"> * @head: list of profiles  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace lock be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__profile_list_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
		<span class="n">__remove_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__ns_list_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_namespace - remove everything contained by @ns</span>
<span class="cm"> * @ns: namespace to have it contents removed  (NOT NULL)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* release all profiles in this namespace */</span>
	<span class="n">__profile_list_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">);</span>

	<span class="cm">/* release all sub namespaces */</span>
	<span class="n">__ns_list_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">sub_ns</span><span class="p">);</span>

	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __remove_namespace - remove a namespace and all its children</span>
<span class="cm"> * @ns: namespace to be removed  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns-&gt;parent-&gt;lock be held and ns removed from parent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__remove_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">unconfined</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">;</span>

	<span class="cm">/* remove ns from namespace list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * break the ns, unconfined profile cyclic reference and forward</span>
<span class="cm">	 * all new unconfined profiles requests to the parent namespace</span>
<span class="cm">	 * This will result in all confined tasks that have a profile</span>
<span class="cm">	 * being removed, inheriting the parent-&gt;unconfined profile.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">);</span>

	<span class="n">destroy_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="cm">/* release original ns-&gt;unconfined ref */</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">unconfined</span><span class="p">);</span>
	<span class="cm">/* release ns-&gt;base.list ref, from removal above */</span>
	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ns_list_release - remove all profile namespaces on the list put refs</span>
<span class="cm"> * @head: list of profile namespaces  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: namespace lock be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ns_list_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
		<span class="n">__remove_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_alloc_root_ns - allocate the root profile namespace</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: %0 on success else error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">aa_alloc_root_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* released by aa_free_root_ns - used as list ref*/</span>
	<span class="n">root_ns</span> <span class="o">=</span> <span class="n">alloc_namespace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;root&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm">  * aa_free_root_ns - free the root profile namespace</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">aa_free_root_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
 <span class="p">{</span>
	 <span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">root_ns</span><span class="p">;</span>
	 <span class="n">root_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	 <span class="n">destroy_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	 <span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_alloc_profile - allocate, initialize and return a new profile</span>
<span class="cm"> * @hname: name of the profile  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: refcount profile or NULL on failure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">aa_alloc_profile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">;</span>

	<span class="cm">/* freed by free_profile - usually through aa_put_profile */</span>
	<span class="n">profile</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">profile</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hname</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kzfree</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* refcount released by caller */</span>
	<span class="k">return</span> <span class="n">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_new_null_profile - create a new null-X learning profile</span>
<span class="cm"> * @parent: profile that caused this profile to be created (NOT NULL)</span>
<span class="cm"> * @hat: true if the null- learning profile is a hat</span>
<span class="cm"> *</span>
<span class="cm"> * Create a null- complain mode profile used in learning mode.  The name of</span>
<span class="cm"> * the profile is unique and follows the format of parent//null-sid.</span>
<span class="cm"> *</span>
<span class="cm"> * null profiles are added to the profile list but the list does not</span>
<span class="cm"> * hold a count on them so that they are automatically released when</span>
<span class="cm"> * not in use.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: new refcounted profile else NULL on failure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">aa_new_null_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">aa_alloc_sid</span><span class="p">();</span>

	<span class="cm">/* freed below */</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s//null-%x&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

	<span class="n">profile</span> <span class="o">=</span> <span class="n">aa_alloc_profile</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">APPARMOR_COMPLAIN</span><span class="p">;</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PFLAG_NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hat</span><span class="p">)</span>
		<span class="n">profile</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PFLAG_HAT</span><span class="p">;</span>

	<span class="cm">/* released on free_profile */</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__list_add_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">,</span> <span class="n">profile</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* refcount released by caller */</span>
	<span class="k">return</span> <span class="n">profile</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">aa_free_sid</span><span class="p">(</span><span class="n">sid</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_profile - free a profile</span>
<span class="cm"> * @profile: the profile to free  (MAYBE NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Free a profile, its hats and null_profile. All references to the profile,</span>
<span class="cm"> * its hats and null_profile must have been put.</span>
<span class="cm"> *</span>
<span class="cm"> * If the profile was referenced from a task context, free_profile() will</span>
<span class="cm"> * be called from an rcu callback routine, so we must not sleep here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">profile</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">AA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: internal error, &quot;</span>
			 <span class="s">&quot;profile &#39;%s&#39; still on ns list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* free children profiles */</span>
	<span class="n">policy_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">kzfree</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">);</span>

	<span class="n">aa_free_file_rules</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
	<span class="n">aa_free_cap_rules</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">caps</span><span class="p">);</span>
	<span class="n">aa_free_rlimit_rules</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">rlimits</span><span class="p">);</span>

	<span class="n">aa_free_sid</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
	<span class="n">aa_put_dfa</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">xmatch</span><span class="p">);</span>
	<span class="n">aa_put_dfa</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">.</span><span class="n">dfa</span><span class="p">);</span>

	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">replacedby</span><span class="p">);</span>

	<span class="n">kzfree</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_free_profile_kref - free aa_profile by kref (called by aa_put_profile)</span>
<span class="cm"> * @kr: kref callback for freeing of a profile  (NOT NULL)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">aa_free_profile_kref</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_profile</span><span class="p">,</span>
					    <span class="n">base</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

	<span class="n">free_profile</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO: profile accounting - setup in remove */</span>

<span class="cm">/**</span>
<span class="cm"> * __find_child - find a profile on @head list with a name matching @name</span>
<span class="cm"> * @head: list to search  (NOT NULL)</span>
<span class="cm"> * @name: name of profile (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns lock protecting list be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted profile ptr, or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">__find_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="p">)</span><span class="n">__policy_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __strn_find_child - find a profile on @head list using substring of @name</span>
<span class="cm"> * @head: list to search  (NOT NULL)</span>
<span class="cm"> * @name: name of profile (NOT NULL)</span>
<span class="cm"> * @len: length of @name substring to match</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns lock protecting list be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted profile ptr, or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">__strn_find_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="p">)</span><span class="n">__policy_strn_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_find_child - find a profile by @name in @parent</span>
<span class="cm"> * @parent: profile to search  (NOT NULL)</span>
<span class="cm"> * @name: profile name to search for  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: a refcounted profile or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">aa_find_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">profile</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">__find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">profiles</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* refcount released by caller */</span>
	<span class="k">return</span> <span class="n">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lookup_parent - lookup the parent of a profile of name @hname</span>
<span class="cm"> * @ns: namespace to lookup profile in  (NOT NULL)</span>
<span class="cm"> * @hname: hierarchical profile name to find parent of  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Lookups up the parent of a fully qualified profile name, the profile</span>
<span class="cm"> * that matches hname does not need to exist, in general this</span>
<span class="cm"> * is used to load a new profile.</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns-&gt;lock be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted policy or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="nf">__lookup_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>

	<span class="n">policy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">);</span> <span class="n">split</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">profile</span> <span class="o">=</span> <span class="n">__strn_find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">hname</span><span class="p">,</span>
					    <span class="n">split</span> <span class="o">-</span> <span class="n">hname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">policy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">hname</span> <span class="o">=</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lookup_profile - lookup the profile matching @hname</span>
<span class="cm"> * @base: base list to start looking up profile name from  (NOT NULL)</span>
<span class="cm"> * @hname: hierarchical profile name  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Requires: ns-&gt;lock be held</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: unrefcounted profile pointer or NULL if not found</span>
<span class="cm"> *</span>
<span class="cm"> * Do a relative name lookup, recursing through profile tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">__lookup_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">);</span> <span class="n">split</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">profile</span> <span class="o">=</span> <span class="n">__strn_find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">hname</span><span class="p">,</span>
					    <span class="n">split</span> <span class="o">-</span> <span class="n">hname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">hname</span> <span class="o">=</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">split</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;//&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">profile</span> <span class="o">=</span> <span class="n">__find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">hname</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_lookup_profile - find a profile by its full or partial name</span>
<span class="cm"> * @ns: the namespace to start from (NOT NULL)</span>
<span class="cm"> * @hname: name to do lookup on.  Does not contain namespace prefix (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: refcounted profile or NULL if not found</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="nf">aa_lookup_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">profile</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">__lookup_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">hname</span><span class="p">));</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* the unconfined profile is not in the regular profile list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">hname</span><span class="p">,</span> <span class="s">&quot;unconfined&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">profile</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">unconfined</span><span class="p">);</span>

	<span class="cm">/* refcount released by caller */</span>
	<span class="k">return</span> <span class="n">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replacement_allowed - test to see if replacement is allowed</span>
<span class="cm"> * @profile: profile to test if it can be replaced  (MAYBE NULL)</span>
<span class="cm"> * @noreplace: true if replacement shouldn&#39;t be allowed but addition is okay</span>
<span class="cm"> * @info: Returns - info about why replacement failed (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: %0 if replacement allowed else error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replacement_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">noreplace</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PFLAG_IMMUTABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="s">&quot;cannot replace immutible profile&quot;</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">noreplace</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="s">&quot;profile already exists&quot;</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __add_new_profile - simple wrapper around __list_add_profile</span>
<span class="cm"> * @ns: namespace that profile is being added to  (NOT NULL)</span>
<span class="cm"> * @policy: the policy container to add the profile to  (NOT NULL)</span>
<span class="cm"> * @profile: profile to add  (NOT NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * add a profile to a list and do other required basic allocations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__add_new_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
		<span class="cm">/* released on profile replacement or free_profile */</span>
		<span class="n">profile</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">((</span><span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="p">)</span> <span class="n">policy</span><span class="p">);</span>
	<span class="n">__list_add_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">profile</span><span class="p">);</span>
	<span class="cm">/* released on free_profile */</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">sid</span> <span class="o">=</span> <span class="n">aa_alloc_sid</span><span class="p">();</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_audit_policy - Do auditing of policy changes</span>
<span class="cm"> * @op: policy operation being performed</span>
<span class="cm"> * @gfp: memory allocation flags</span>
<span class="cm"> * @name: name of profile being manipulated (NOT NULL)</span>
<span class="cm"> * @info: any extra information to be audited (MAYBE NULL)</span>
<span class="cm"> * @error: error code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: the error to be returned after audit is done</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_policy</span><span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">common_audit_data</span> <span class="n">sa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apparmor_audit_data</span> <span class="n">aad</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LSM_AUDIT_DATA_NONE</span><span class="p">;</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">aad</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">aad</span><span class="p">;</span>
	<span class="n">aad</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">aad</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">aad</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">aad</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">aa_audit</span><span class="p">(</span><span class="n">AUDIT_APPARMOR_STATUS</span><span class="p">,</span> <span class="n">__aa_current_profile</span><span class="p">(),</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_may_manage_policy - can the current task manage policy</span>
<span class="cm"> * @op: the policy manipulation operation being done</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: true if the task is allowed to manipulate policy</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">aa_may_manage_policy</span><span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* check if loading policy is locked out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aa_g_lock_policy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_policy</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;policy_locked&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">audit_policy</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;not policy admin&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_replace_profiles - replace profile(s) on the profile list</span>
<span class="cm"> * @udata: serialized data stream  (NOT NULL)</span>
<span class="cm"> * @size: size of the serialized data stream</span>
<span class="cm"> * @noreplace: true if only doing addition, no replacement allowed</span>
<span class="cm"> *</span>
<span class="cm"> * unpack and replace a profile on the profile list and uses of that profile</span>
<span class="cm"> * by any aa_task_cxt.  If the profile does not exist on the profile list</span>
<span class="cm"> * it is added.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of data consumed else error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">aa_replace_profiles</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">udata</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noreplace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">old_profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">new_profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">rename_profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ns_name</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="n">OP_PROF_REPL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* released below */</span>
	<span class="n">new_profile</span> <span class="o">=</span> <span class="n">aa_unpack</span><span class="p">(</span><span class="n">udata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_profile</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_profile</span><span class="p">);</span>
		<span class="n">new_profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* released below */</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_prepare_namespace</span><span class="p">(</span><span class="n">ns_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;failed to prepare namespace&quot;</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ns_name</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* no ref on policy only use inside lock */</span>
	<span class="n">policy</span> <span class="o">=</span> <span class="n">__lookup_parent</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;parent does not exist&quot;</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">audit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">old_profile</span> <span class="o">=</span> <span class="n">__find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">profiles</span><span class="p">,</span> <span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* released below */</span>
	<span class="n">aa_get_profile</span><span class="p">(</span><span class="n">old_profile</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rename_profile</span> <span class="o">=</span> <span class="n">__lookup_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
						  <span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">);</span>
		<span class="cm">/* released below */</span>
		<span class="n">aa_get_profile</span><span class="p">(</span><span class="n">rename_profile</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rename_profile</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;profile to rename does not exist&quot;</span><span class="p">;</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">audit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">replacement_allowed</span><span class="p">(</span><span class="n">old_profile</span><span class="p">,</span> <span class="n">noreplace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">audit</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">replacement_allowed</span><span class="p">(</span><span class="n">rename_profile</span><span class="p">,</span> <span class="n">noreplace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">audit</span><span class="p">;</span>

<span class="nl">audit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_profile</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rename_profile</span><span class="p">)</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">OP_PROF_LOAD</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">audit_policy</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rename_profile</span><span class="p">)</span>
			<span class="n">__replace_profile</span><span class="p">(</span><span class="n">rename_profile</span><span class="p">,</span> <span class="n">new_profile</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_profile</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* when there are both rename and old profiles</span>
<span class="cm">			 * inherit old profiles sid</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rename_profile</span><span class="p">)</span>
				<span class="n">aa_free_sid</span><span class="p">(</span><span class="n">new_profile</span><span class="o">-&gt;</span><span class="n">sid</span><span class="p">);</span>
			<span class="n">__replace_profile</span><span class="p">(</span><span class="n">old_profile</span><span class="p">,</span> <span class="n">new_profile</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_profile</span> <span class="o">||</span> <span class="n">rename_profile</span><span class="p">))</span>
			<span class="n">__add_new_profile</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">new_profile</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">rename_profile</span><span class="p">);</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">old_profile</span><span class="p">);</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">new_profile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">audit_policy</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * aa_remove_profiles - remove profile(s) from the system</span>
<span class="cm"> * @fqname: name of the profile or namespace to remove  (NOT NULL)</span>
<span class="cm"> * @size: size of the name</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a profile or sub namespace from the current namespace, so that</span>
<span class="cm"> * they can not be found anymore and mark them as replaced by unconfined</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: removing confinement does not restore rlimits to preconfinemnet values</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of data consume else error code if fails</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">aa_remove_profiles</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">fqname</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aa_namespace</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aa_profile</span> <span class="o">*</span><span class="n">profile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">fqname</span><span class="p">,</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">fqname</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;no profile specified&quot;</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">aa_current_profile</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fqname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ns_name</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">aa_split_fqname</span><span class="p">(</span><span class="n">fqname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ns_name</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* released below */</span>
			<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_find_namespace</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ns_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;namespace does not exist&quot;</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* released below */</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">aa_get_namespace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* remove namespace - can only happen if fqname[0] == &#39;:&#39; */</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__remove_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* remove profile */</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">profile</span> <span class="o">=</span> <span class="n">aa_get_profile</span><span class="p">(</span><span class="n">__lookup_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="n">info</span> <span class="o">=</span> <span class="s">&quot;profile does not exist&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_ns_lock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">profile</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hname</span><span class="p">;</span>
		<span class="n">__remove_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t fail removal if audit fails */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">audit_policy</span><span class="p">(</span><span class="n">OP_PROF_RM</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">aa_put_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">fail_ns_lock:</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">aa_put_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">audit_policy</span><span class="p">(</span><span class="n">OP_PROF_RM</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
