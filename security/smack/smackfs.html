<!DOCTYPE html>
<html><head><title>joekychen/linux » security › smack › smackfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>smackfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Casey Schaufler &lt;casey@schaufler-ca.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> * 	Casey Schaufler &lt;casey@schaufler-ca.com&gt;</span>
<span class="cm"> * 	Ahmed S. Darwish &lt;darwish.07@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Special thanks to the authors of selinuxfs.</span>
<span class="cm"> *</span>
<span class="cm"> *	Karl MacMillan &lt;kmacmillan@tresys.com&gt;</span>
<span class="cm"> *	James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/cipso_ipv4.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &quot;smack.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * smackfs pseudo filesystem.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">smk_inos</span> <span class="p">{</span>
	<span class="n">SMK_ROOT_INO</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SMK_LOAD</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* load policy */</span>
	<span class="n">SMK_CIPSO</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* load label -&gt; CIPSO mapping */</span>
	<span class="n">SMK_DOI</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* CIPSO DOI */</span>
	<span class="n">SMK_DIRECT</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* CIPSO level indicating direct label */</span>
	<span class="n">SMK_AMBIENT</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* internet ambient label */</span>
	<span class="n">SMK_NETLBLADDR</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* single label hosts */</span>
	<span class="n">SMK_ONLYCAP</span>	<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/* the only &quot;capable&quot; label */</span>
	<span class="n">SMK_LOGGING</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* logging */</span>
	<span class="n">SMK_LOAD_SELF</span>	<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* task specific rules */</span>
	<span class="n">SMK_ACCESSES</span>	<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>	<span class="cm">/* access policy */</span>
	<span class="n">SMK_MAPPED</span>	<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>	<span class="cm">/* CIPSO level indicating mapped label */</span>
	<span class="n">SMK_LOAD2</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>	<span class="cm">/* load policy with long labels */</span>
	<span class="n">SMK_LOAD_SELF2</span>	<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/* load task specific rules with long labels */</span>
	<span class="n">SMK_ACCESS2</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>	<span class="cm">/* make an access check with long labels */</span>
	<span class="n">SMK_CIPSO2</span>	<span class="o">=</span> <span class="mi">17</span><span class="p">,</span>	<span class="cm">/* load long label -&gt; CIPSO mapping */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * List locks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smack_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smack_cipso_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smack_ambient_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smk_netlbladdr_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is the &quot;ambient&quot; label for network traffic.</span>
<span class="cm"> * If it isn&#39;t somehow marked, use this.</span>
<span class="cm"> * It can be reset via smackfs/ambient</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">smack_net_ambient</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the level in a CIPSO header that indicates a</span>
<span class="cm"> * smack label is contained directly in the category set.</span>
<span class="cm"> * It can be reset via smackfs/direct</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">smack_cipso_direct</span> <span class="o">=</span> <span class="n">SMACK_CIPSO_DIRECT_DEFAULT</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the level in a CIPSO header that indicates a</span>
<span class="cm"> * secid is contained directly in the category set.</span>
<span class="cm"> * It can be reset via smackfs/mapped</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">smack_cipso_mapped</span> <span class="o">=</span> <span class="n">SMACK_CIPSO_MAPPED_DEFAULT</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Unless a process is running with this label even</span>
<span class="cm"> * having CAP_MAC_OVERRIDE isn&#39;t enough to grant</span>
<span class="cm"> * privilege to violate MAC policy. If no label is</span>
<span class="cm"> * designated (the NULL case) capabilities apply to</span>
<span class="cm"> * everyone. It is expected that the hat (^) label</span>
<span class="cm"> * will be used if any label is used.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">smack_onlycap</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Certain IP addresses may be designated as single label hosts.</span>
<span class="cm"> * Packets are sent there unlabeled, but only from tasks that</span>
<span class="cm"> * can write to the specified label.</span>
<span class="cm"> */</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">smk_netlbladdr_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Rule lists are maintained for each label.</span>
<span class="cm"> * This master list is just for reading /smack/load and /smack/load2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smack_master_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span>	<span class="o">*</span><span class="n">smk_rule</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">smack_rule_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">smk_cipso_doi_value</span> <span class="o">=</span> <span class="n">SMACK_CIPSO_DOI_DEFAULT</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">smack_cipso_option</span> <span class="o">=</span> <span class="n">SMACK_CIPSO_OPTION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Values for parsing cipso rules</span>
<span class="cm"> * SMK_DIGITLEN: Length of a digit field in a rule.</span>
<span class="cm"> * SMK_CIPSOMIN: Minimum possible cipso rule length.</span>
<span class="cm"> * SMK_CIPSOMAX: Maximum possible cipso rule length.</span>
<span class="cm"> */</span>
<span class="cp">#define SMK_DIGITLEN 4</span>
<span class="cp">#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)</span>
<span class="cp">#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)</span>

<span class="cm">/*</span>
<span class="cm"> * Values for parsing MAC rules</span>
<span class="cm"> * SMK_ACCESS: Maximum possible combination of access permissions</span>
<span class="cm"> * SMK_ACCESSLEN: Maximum length for a rule access field</span>
<span class="cm"> * SMK_LOADLEN: Smack rule length</span>
<span class="cm"> */</span>
<span class="cp">#define SMK_OACCESS	&quot;rwxa&quot;</span>
<span class="cp">#define SMK_ACCESS	&quot;rwxat&quot;</span>
<span class="cp">#define SMK_OACCESSLEN	(sizeof(SMK_OACCESS) - 1)</span>
<span class="cp">#define SMK_ACCESSLEN	(sizeof(SMK_ACCESS) - 1)</span>
<span class="cp">#define SMK_OLOADLEN	(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)</span>
<span class="cp">#define SMK_LOADLEN	(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)</span>

<span class="cm">/*</span>
<span class="cm"> * Stricly for CIPSO level manipulation.</span>
<span class="cm"> * Set the category bit number in a smack label sized buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smack_catset_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">catsetp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cat</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">SMK_CIPSOLEN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">catsetp</span><span class="p">[(</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_netlabel_audit_set - fill a netlbl_audit struct</span>
<span class="cm"> * @nap: structure to fill</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_netlabel_audit_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">nap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nap</span><span class="o">-&gt;</span><span class="n">loginuid</span> <span class="o">=</span> <span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">nap</span><span class="o">-&gt;</span><span class="n">sessionid</span> <span class="o">=</span> <span class="n">audit_get_sessionid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">nap</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">smk_of_current</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Value for parsing single label host rules</span>
<span class="cm"> * &quot;1.2.3.4 X&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define SMK_NETLBLADDRMIN	9</span>

<span class="cm">/**</span>
<span class="cm"> * smk_set_access - add a rule to the rule list</span>
<span class="cm"> * @srp: the new rule to add</span>
<span class="cm"> * @rule_list: the list of rules</span>
<span class="cm"> * @rule_lock: the rule list lock</span>
<span class="cm"> *</span>
<span class="cm"> * Looks through the current subject/object/access list for</span>
<span class="cm"> * the subject/object pair and replaces the access that was</span>
<span class="cm"> * there. If the pair isn&#39;t found add it with the specified</span>
<span class="cm"> * access.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if a rule was found to exist already, 0 if it is new</span>
<span class="cm"> * Returns 0 if nothing goes wrong or -ENOMEM if it fails</span>
<span class="cm"> * during the allocation of the new pair to add.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_set_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">srp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rule_list</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">rule_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">rule_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because the object label is less likely to match</span>
<span class="cm">	 * than the subject label check it first</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_object</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_object</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_subject</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_subject</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">rule_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_fill_rule - Fill Smack rule from strings</span>
<span class="cm"> * @subject: subject label string</span>
<span class="cm"> * @object: object label string</span>
<span class="cm"> * @access: access string</span>
<span class="cm"> * @rule: Smack rule</span>
<span class="cm"> * @import: if non-zero, import labels</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_fill_rule</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">subject</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">access</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">import</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">import</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_subject</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_subject</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_object</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">smk_parse_smack</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_subject</span> <span class="o">=</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">;</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="n">smk_parse_smack</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_object</span> <span class="o">=</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">access</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">;</span> <span class="n">cp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;r&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">|=</span> <span class="n">MAY_READ</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;w&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;W&#39;</span>:
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">|=</span> <span class="n">MAY_WRITE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;x&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;X&#39;</span>:
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">|=</span> <span class="n">MAY_EXEC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;A&#39;</span>:
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">|=</span> <span class="n">MAY_APPEND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;t&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;T&#39;</span>:
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">|=</span> <span class="n">MAY_TRANSMUTE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_parse_rule - parse Smack rule from load string</span>
<span class="cm"> * @data: string to be parsed whose size is SMK_LOADLEN</span>
<span class="cm"> * @rule: Smack rule</span>
<span class="cm"> * @import: if non-zero, import labels</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_parse_rule</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span> <span class="kt">int</span> <span class="n">import</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_fill_rule</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">SMK_LABELLEN</span><span class="p">,</span>
			   <span class="n">data</span> <span class="o">+</span> <span class="n">SMK_LABELLEN</span> <span class="o">+</span> <span class="n">SMK_LABELLEN</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">import</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_parse_long_rule - parse Smack rule from rule string</span>
<span class="cm"> * @data: string to be parsed, null terminated</span>
<span class="cm"> * @rule: Smack rule</span>
<span class="cm"> * @import: if non-zero, import labels</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_parse_long_rule</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">import</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">subject</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">access</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is probably inefficient, but safe.</span>
<span class="cm">	 */</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">subject</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">datalen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subject</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">datalen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_out_s</span><span class="p">;</span>
	<span class="n">access</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">datalen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_out_o</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%s %s %s&quot;</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">access</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_fill_rule</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">import</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">access</span><span class="p">);</span>
<span class="nl">free_out_o:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="nl">free_out_s:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">subject</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SMK_FIXED24_FMT	0	</span><span class="cm">/* Fixed 24byte label format */</span><span class="cp"></span>
<span class="cp">#define SMK_LONG_FMT	1	</span><span class="cm">/* Variable long label format */</span><span class="cp"></span>
<span class="cm">/**</span>
<span class="cm"> * smk_write_rules_list - write() for any /smack rule file</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> * @rule_list: the list of rules to write to</span>
<span class="cm"> * @rule_lock: lock for the rule list</span>
<span class="cm"> * @format: /smack/load or /smack/load2 format.</span>
<span class="cm"> *</span>
<span class="cm"> * Get one smack access rule from above.</span>
<span class="cm"> * The format for SMK_LONG_FMT is:</span>
<span class="cm"> *	&quot;subject&lt;whitespace&gt;object&lt;whitespace&gt;access[&lt;whitespace&gt;...]&quot;</span>
<span class="cm"> * The format for SMK_FIXED24_FMT is exactly:</span>
<span class="cm"> *	&quot;subject                 object                  rwxat&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_rules_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rule_list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">rule_lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_master_list</span> <span class="o">*</span><span class="n">smlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No partial writes.</span>
<span class="cm">	 * Enough data must be present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Minor hack for backward compatibility</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">SMK_OLOADLEN</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">SMK_LOADLEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="n">SMK_LOADLEN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">datalen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rule</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rule</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rule</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_LONG_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Be sure the data string is terminated.</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smk_parse_long_rule</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free_rule</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * More on the minor hack for backward compatibility</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="p">(</span><span class="n">SMK_OLOADLEN</span><span class="p">))</span>
			<span class="n">data</span><span class="p">[</span><span class="n">SMK_OLOADLEN</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smk_parse_rule</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free_rule</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">rule_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">load</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">smk_subject</span><span class="p">);</span>
		<span class="n">rule_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">;</span>
		<span class="n">rule_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_rules_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is a global as opposed to self and a new rule</span>
<span class="cm">	 * it needs to get added for reporting.</span>
<span class="cm">	 * smk_set_access returns true if there was already a rule</span>
<span class="cm">	 * for the subject/object pair, and false if it was new.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smk_set_access</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">,</span> <span class="n">rule_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smlp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">smlp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smlp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">smlp</span><span class="o">-&gt;</span><span class="n">smk_rule</span> <span class="o">=</span> <span class="n">rule</span><span class="p">;</span>
				<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smlp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_rule_list</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_free_rule:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rule</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Core logic for smackfs seq list operations.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">smk_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is 0 the first time through.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">smk_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* No-op */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_rule_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">srp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t show any rules with label names too long for</span>
<span class="cm">	 * interface file (/smack/load or /smack/load2)</span>
<span class="cm">	 * because you should expect to be able to write</span>
<span class="cm">	 * anything you read back.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_subject</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max</span> <span class="o">||</span> <span class="n">strlen</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_object</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s %s&quot;</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_subject</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_object</span><span class="p">);</span>

	<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">&amp;</span> <span class="n">MAY_READ</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">&amp;</span> <span class="n">MAY_APPEND</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">&amp;</span> <span class="n">MAY_TRANSMUTE</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>

	<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/load</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load2_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_start</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_rule_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load2_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_rule_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_master_list</span> <span class="o">*</span><span class="n">smlp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_master_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">smk_rule_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">smlp</span><span class="o">-&gt;</span><span class="n">smk_rule</span><span class="p">,</span> <span class="n">SMK_LABELLEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">load_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">load2_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">load2_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">load_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_load - open() for /smack/load</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;load&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * For reading, use load_seq_* seq_file reading operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">load_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_load - write() for /smack/load</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must have privilege.</span>
<span class="cm">	 * No partial writes.</span>
<span class="cm">	 * Enough data must be present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smk_write_rules_list</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">SMK_FIXED24_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_load_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_cipso_doi - initialize the CIPSO domain</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_cipso_doi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">doip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">nai</span><span class="p">;</span>

	<span class="n">smk_netlabel_audit_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_map_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d remove rc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">doip</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cipso_v4_doi</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;smack:  Failed to initialize cipso DOI.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">doip</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">.</span><span class="n">std</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">doip</span><span class="o">-&gt;</span><span class="n">doi</span> <span class="o">=</span> <span class="n">smk_cipso_doi_value</span><span class="p">;</span>
	<span class="n">doip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">CIPSO_V4_MAP_PASS</span><span class="p">;</span>
	<span class="n">doip</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CIPSO_V4_TAG_RBITMAP</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="n">CIPSO_V4_TAG_MAXCNT</span><span class="p">;</span> <span class="n">rc</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doip</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span> <span class="o">=</span> <span class="n">CIPSO_V4_TAG_INVALID</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_cipsov4_add</span><span class="p">(</span><span class="n">doip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d cipso add rc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">doip</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_cipsov4_map_add</span><span class="p">(</span><span class="n">doip</span><span class="o">-&gt;</span><span class="n">doi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d map add rc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">doip</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_unlbl_ambient - initialize the unlabeled domain</span>
<span class="cm"> * @oldambient: previous domain string</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_unlbl_ambient</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">oldambient</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">nai</span><span class="p">;</span>

	<span class="n">smk_netlabel_audit_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldambient</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_map_del</span><span class="p">(</span><span class="n">oldambient</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d remove rc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack_net_ambient</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">smack_net_ambient</span> <span class="o">=</span> <span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_unlbl_map_add</span><span class="p">(</span><span class="n">smack_net_ambient</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span>
				      <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nai</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d add rc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/cipso</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cipso_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_start</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cipso_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print cipso labels in format:</span>
<span class="cm"> * label level[/cat[,cat]]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cipso_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_known</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">cmp</span> <span class="o">=</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t show a label that could not have been set using</span>
<span class="cm">	 * /smack/cipso. This is in support of the notion that</span>
<span class="cm">	 * anything read from /smack/cipso ought to be writeable</span>
<span class="cm">	 * to /smack/cipso.</span>
<span class="cm">	 *</span>
<span class="cm">	 * /smack/cipso2 should be used instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">SMK_LABELLEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s %3d&quot;</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c%d&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cipso_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cipso_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">cipso_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">cipso_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_cipso - open() for /smack/cipso</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;cipso&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Connect our cipso_seq_* operations with /smack/cipso</span>
<span class="cm"> * file_operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_cipso</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cipso_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_set_cipso - do the work for write() for cipso and cipso2</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> * @format: /smack/cipso or /smack/cipso2</span>
<span class="cm"> *</span>
<span class="cm"> * Accepts only one cipso rule per write call.</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_set_cipso</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="n">ncats</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">mapcatset</span><span class="p">[</span><span class="n">SMK_CIPSOLEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">maplevel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">catlen</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must have privilege.</span>
<span class="cm">	 * No partial writes.</span>
<span class="cm">	 * Enough data must be present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SMK_CIPSOMIN</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">SMK_CIPSOMAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlockedout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">rule</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only allow one writer at a time. Writes should be</span>
<span class="cm">	 * quite rare and small in any case.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_cipso_lock</span><span class="p">);</span>

	<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_import_entry</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">)</span>
		<span class="n">rule</span> <span class="o">+=</span> <span class="n">SMK_LABELLEN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rule</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maplevel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">maplevel</span> <span class="o">&gt;</span> <span class="n">SMACK_CIPSO_MAXLEVEL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rule</span> <span class="o">+=</span> <span class="n">SMK_DIGITLEN</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">catlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">catlen</span> <span class="o">&gt;</span> <span class="n">SMACK_CIPSO_MAXCATNUM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">count</span> <span class="o">!=</span> <span class="p">(</span><span class="n">SMK_CIPSOMIN</span> <span class="o">+</span> <span class="n">catlen</span> <span class="o">*</span> <span class="n">SMK_DIGITLEN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mapcatset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mapcatset</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">catlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rule</span> <span class="o">+=</span> <span class="n">SMK_DIGITLEN</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">cat</span> <span class="o">&gt;</span> <span class="n">SMACK_CIPSO_MAXCATVAL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">smack_catset_bit</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">mapcatset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_netlbl_mls</span><span class="p">(</span><span class="n">maplevel</span><span class="p">,</span> <span class="n">mapcatset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ncats</span><span class="p">,</span> <span class="n">SMK_CIPSOLEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlbl_secattr_catmap_free</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">);</span>
		<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span> <span class="o">=</span> <span class="n">ncats</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">;</span>
		<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">=</span> <span class="n">ncats</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_cipso_lock</span><span class="p">);</span>
<span class="nl">unlockedout:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_cipso - write() for /smack/cipso</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Accepts only one cipso rule per write call.</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_cipso</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_set_cipso</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_cipso_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_cipso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_cipso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/cipso2</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Print cipso labels in format:</span>
<span class="cm"> * label level[/cat[,cat]]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cipso2_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_known</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">cmp</span> <span class="o">=</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s %3d&quot;</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c%d&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_putc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cipso2_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cipso_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">cipso_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">cipso2_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_cipso2 - open() for /smack/cipso2</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;cipso2&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Connect our cipso_seq_* operations with /smack/cipso2</span>
<span class="cm"> * file_operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_cipso2</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cipso2_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_cipso2 - write() for /smack/cipso2</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Accepts only one cipso rule per write call.</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_cipso2</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_set_cipso</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">SMK_LONG_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_cipso2_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_cipso2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_cipso2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/netlabel</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">netlbladdr_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_start</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">netlbladdr_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_seq_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define BEBITS	(sizeof(__be32) * 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Print host/label pairs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbladdr_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_netlbladdr</span> <span class="o">*</span><span class="n">skp</span> <span class="o">=</span>
			 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smk_netlbladdr</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maskn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">maskn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">temp_mask</span><span class="p">;</span> <span class="n">temp_mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maskn</span><span class="o">++</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%u.%u.%u.%u/%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">hp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">maskn</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_label</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">netlbladdr_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">netlbladdr_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">netlbladdr_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">netlbladdr_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_netlbladdr - open() for /smack/netlabel</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;netlabel&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Connect our netlbladdr_seq_* operations with /smack/netlabel</span>
<span class="cm"> * file_operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_netlbladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netlbladdr_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_netlbladdr_insert</span>
<span class="cm"> * @new : netlabel to insert</span>
<span class="cm"> *</span>
<span class="cm"> * This helper insert netlabel in the smack_netlbladdrs list</span>
<span class="cm"> * sorted by netmask length (longest to smallest)</span>
<span class="cm"> * locked by &amp;smk_netlbladdr_lock in smk_write_netlbladdr</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smk_netlbladdr_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">smk_netlbladdr</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_netlbladdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">m_next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">smk_netlbladdr_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">smk_netlbladdr</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="cm">/* the comparison &#39;&gt;&#39; is a bit hacky, but works */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m_next</span> <span class="o">=</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">smk_netlbladdr</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">&gt;</span> <span class="n">m_next</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * smk_write_netlbladdr - write() for /smack/netlabel</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Accepts only one netlbladdr per write call.</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_netlbladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_netlbladdr</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">newname</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newname</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask_bits</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">);</span>
	<span class="n">__be32</span> <span class="n">nsa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must have privilege.</span>
<span class="cm">	 * No partial writes.</span>
<span class="cm">	 * Enough data must be present.</span>
<span class="cm">	 * &quot;&lt;addr/mask, as a.b.c.d/e&gt;&lt;space&gt;&lt;label&gt;&quot;</span>
<span class="cm">	 * &quot;&lt;addr, as a.b.c.d&gt;&lt;space&gt;&lt;label&gt;&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SMK_NETLBLADDRMIN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_data_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smack</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_data_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%hhd.%hhd.%hhd.%hhd/%d %s&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">smack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;%hhd.%hhd.%hhd.%hhd %s&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">smack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">BEBITS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">BEBITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If smack begins with &#39;-&#39;, it is an option, don&#39;t import it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">smack</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check known options */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">smack</span><span class="p">,</span> <span class="n">smack_cipso_option</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">smack_cipso_option</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">temp_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_mask</span> <span class="o">|=</span> <span class="n">mask_bits</span><span class="p">;</span>
		<span class="n">mask_bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mask</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">);</span>

	<span class="n">newname</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only allow one writer at a time. Writes should be</span>
<span class="cm">	 * quite rare and small in any case.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smk_netlbladdr_lock</span><span class="p">);</span>

	<span class="n">nsa</span> <span class="o">=</span> <span class="n">newname</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="cm">/* try to find if the prefix is already in the list */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">skp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span> <span class="n">nsa</span> <span class="o">&amp;&amp;</span>
		    <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span> <span class="n">mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">smk_netlabel_audit_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">newname</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_label</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
			<span class="n">smk_netlbladdr_insert</span><span class="p">(</span><span class="n">skp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* we delete the unlabeled entry, only if the previous label</span>
<span class="cm">		 * wasn&#39;t the special CIPSO option */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_label</span> <span class="o">!=</span> <span class="n">smack_cipso_option</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_unlbl_static_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">,</span>
					<span class="n">PF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_label</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now tell netlabel about the single label nature of</span>
<span class="cm">	 * this host so that incoming packets get labeled.</span>
<span class="cm">	 * but only if we didn&#39;t get the special CIPSO option</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span> <span class="o">!=</span> <span class="n">smack_cipso_option</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_cfg_unlbl_static_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span>
			<span class="n">smack_to_secid</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_label</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smk_netlbladdr_lock</span><span class="p">);</span>

<span class="nl">free_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">smack</span><span class="p">);</span>
<span class="nl">free_data_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_netlbladdr_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_netlbladdr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_netlbladdr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_doi - read() for /smack/doi</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @count: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_doi</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">smk_cipso_doi_value</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_doi - write() for /smack/doi</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_doi</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">||</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">temp</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">smk_cipso_doi_value</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">smk_cipso_doi</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_doi_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_doi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_doi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_direct - read() for /smack/direct</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @count: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">smack_cipso_direct</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_direct - write() for /smack/direct</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">||</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">temp</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t do anything if the value hasn&#39;t actually changed.</span>
<span class="cm">	 * If it is changing reset the level on entries that were</span>
<span class="cm">	 * set up to be direct when they were created.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack_cipso_direct</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">skp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">==</span>
			    <span class="n">smack_cipso_direct</span><span class="p">)</span>
				<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">smack_cipso_direct</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_direct_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_direct</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_direct</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_mapped - read() for /smack/mapped</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @count: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">smack_cipso_mapped</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_mapped - write() for /smack/mapped</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">||</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">temp</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t do anything if the value hasn&#39;t actually changed.</span>
<span class="cm">	 * If it is changing reset the level on entries that were</span>
<span class="cm">	 * set up to be mapped when they were created.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack_cipso_mapped</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">skp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">==</span>
			    <span class="n">smack_cipso_mapped</span><span class="p">)</span>
				<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">smack_cipso_mapped</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_mapped_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_mapped</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_mapped</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_ambient - read() for /smack/ambient</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @cn: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_ambient</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">cn</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">asize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Being careful to avoid a problem in the case where</span>
<span class="cm">	 * smack_net_ambient gets changed in midstream.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ambient_lock</span><span class="p">);</span>

	<span class="n">asize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">smack_net_ambient</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">&gt;=</span> <span class="n">asize</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
					     <span class="n">smack_net_ambient</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ambient_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_ambient - write() for /smack/ambient</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_ambient</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">oldambient</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smack</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ambient_lock</span><span class="p">);</span>

	<span class="n">oldambient</span> <span class="o">=</span> <span class="n">smack_net_ambient</span><span class="p">;</span>
	<span class="n">smack_net_ambient</span> <span class="o">=</span> <span class="n">smack</span><span class="p">;</span>
	<span class="n">smk_unlbl_ambient</span><span class="p">(</span><span class="n">oldambient</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ambient_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_ambient_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_ambient</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_ambient</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_onlycap - read() for /smack/onlycap</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @cn: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_onlycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">cn</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">asize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smack_onlycap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">smack</span> <span class="o">=</span> <span class="n">smack_onlycap</span><span class="p">;</span>

	<span class="n">asize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">smack</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">&gt;=</span> <span class="n">asize</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">smack</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_onlycap - write() for /smack/onlycap</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_onlycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This can be done using smk_access() but is done</span>
<span class="cm">	 * explicitly for clarity. The smk_access() implementation</span>
<span class="cm">	 * would use smk_access(smack_onlycap, MAY_WRITE)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smack_onlycap</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">smack_onlycap</span> <span class="o">!=</span> <span class="n">sp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should the null string be passed in unset the onlycap value.</span>
<span class="cm">	 * This seems like something to be careful with as usually</span>
<span class="cm">	 * smk_import only expects to return NULL for errors. It</span>
<span class="cm">	 * is usually the case that a nullstring or &quot;\n&quot; would be</span>
<span class="cm">	 * bad to pass to smk_import but in fact this is useful here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * smk_import will also reject a label beginning with &#39;-&#39;,</span>
<span class="cm">	 * so &quot;-usecapabilities&quot; will also work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">smack_onlycap</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_onlycap_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_onlycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_onlycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_read_logging - read() for /smack/logging</span>
<span class="cm"> * @filp: file pointer, not actually used</span>
<span class="cm"> * @buf: where to put the result</span>
<span class="cm"> * @cn: maximum to send along</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_read_logging</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">log_policy</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_logging - write() for /smack/logging</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes written or error code, as appropriate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_logging</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">||</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">temp</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">log_policy</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_logging_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smk_read_logging</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_logging</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/load-self</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load_self_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_seq_start</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load_self_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_seq_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_self_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">srp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">smk_rule_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">srp</span><span class="p">,</span> <span class="n">SMK_LABELLEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">load_self_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">load_self_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">load_self_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">load_self_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * smk_open_load_self - open() for /smack/load-self2</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;load&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * For reading, use load_seq_* seq_file reading operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_load_self</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">load_self_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_load_self - write() for /smack/load-self</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_load_self</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_write_rules_list</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules_lock</span><span class="p">,</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_load_self_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_load_self</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_load_self</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_user_access - handle access check transaction</span>
<span class="cm"> * @file: file pointer</span>
<span class="cm"> * @buf: data from user space</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_user_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="n">rule</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">simple_transaction_get</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SMK_LOADLEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">smk_parse_rule</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rule</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy the data to make sure the string is terminated.</span>
<span class="cm">		 */</span>
		<span class="n">cod</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cod</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cod</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">cod</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">smk_parse_long_rule</span><span class="p">(</span><span class="n">cod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rule</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cod</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">rule</span><span class="p">.</span><span class="n">smk_subject</span><span class="p">,</span> <span class="n">rule</span><span class="p">.</span><span class="n">smk_object</span><span class="p">,</span> <span class="n">rule</span><span class="p">.</span><span class="n">smk_access</span><span class="p">,</span>
			  <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">simple_transaction_set</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SMK_LOADLEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_access - handle access check transaction</span>
<span class="cm"> * @file: file pointer</span>
<span class="cm"> * @buf: data from user space</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_user_access</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">SMK_FIXED24_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_access_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_access</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">simple_transaction_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">simple_transaction_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/load2</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load2_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_master_list</span> <span class="o">*</span><span class="n">smlp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_master_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">smk_rule_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">smlp</span><span class="o">-&gt;</span><span class="n">smk_rule</span><span class="p">,</span> <span class="n">SMK_LONGLABEL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">load2_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">load2_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">load2_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">load2_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_load2 - open() for /smack/load2</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;load2&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * For reading, use load2_seq_* seq_file reading operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_load2</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">load2_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_load2 - write() for /smack/load2</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_load2</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Must have privilege.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smk_write_rules_list</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">SMK_LONG_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_load2_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_load2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_load2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_file read operations for /smack/load-self2</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load_self2_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_seq_start</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">load_self2_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_seq_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_self2_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">srp</span> <span class="o">=</span>
		 <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">smk_rule_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">srp</span><span class="p">,</span> <span class="n">SMK_LONGLABEL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">load_self2_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">load_self2_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">load_self2_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">load_self2_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">smk_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_open_load_self2 - open() for /smack/load-self2</span>
<span class="cm"> * @inode: inode structure representing file</span>
<span class="cm"> * @file: &quot;load&quot; file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * For reading, use load_seq_* seq_file reading operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_open_load_self2</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">load_self2_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_load_self2 - write() for /smack/load-self2</span>
<span class="cm"> * @file: file pointer, not actually used</span>
<span class="cm"> * @buf: where to get the data from</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_load_self2</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">smk_write_rules_list</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules_lock</span><span class="p">,</span> <span class="n">SMK_LONG_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_load_self2_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">smk_open_load_self2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_load_self2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_write_access2 - handle access check transaction</span>
<span class="cm"> * @file: file pointer</span>
<span class="cm"> * @buf: data from user space</span>
<span class="cm"> * @count: bytes sent</span>
<span class="cm"> * @ppos: where to start - must be 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smk_write_access2</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_user_access</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">SMK_LONG_FMT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smk_access2_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smk_write_access2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">simple_transaction_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">simple_transaction_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * smk_fill_super - fill the /smackfs superblock</span>
<span class="cm"> * @sb: the empty superblock</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> * @silent: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Fill in the well known entries for /smack</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, an error code on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root_inode</span><span class="p">;</span>

	<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_descr</span> <span class="n">smack_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">SMK_LOAD</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;load&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_load_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_CIPSO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;cipso&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_cipso_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_DOI</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;doi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_doi_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_DIRECT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;direct&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_direct_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_AMBIENT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;ambient&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_ambient_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_NETLBLADDR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;netlabel&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_ONLYCAP</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;onlycap&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_onlycap_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_LOGGING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;logging&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_logging_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_LOAD_SELF</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;load-self&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_load_self_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_ACCESSES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;access&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_access_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_MAPPED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;mapped&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_mapped_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_LOAD2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;load2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_load2_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_LOAD_SELF2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;load-self2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_load_self2_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_ACCESS2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;access2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_access2_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">SMK_CIPSO2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;cipso2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_cipso2_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">},</span>
		<span class="cm">/* last one */</span>
			<span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">}</span>
	<span class="p">};</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">simple_fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SMACK_MAGIC</span><span class="p">,</span> <span class="n">smack_files</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s failed %d while creating inodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root_inode</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">root_inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="n">new_inode_smack</span><span class="p">(</span><span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_mount - get the smackfs superblock</span>
<span class="cm"> * @fs_type: passed along without comment</span>
<span class="cm"> * @flags: passed along without comment</span>
<span class="cm"> * @dev_name: passed along without comment</span>
<span class="cm"> * @data: passed along without comment</span>
<span class="cm"> *</span>
<span class="cm"> * Just passes everything along.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns what the lower level code does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">smk_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_single</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">smk_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">smk_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;smackfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">smk_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">smackfs_mount</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smk_preset_netlabel</span><span class="p">(</span><span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span>
		<span class="n">NETLBL_SECATTR_DOMAIN</span> <span class="o">|</span> <span class="n">NETLBL_SECATTR_MLS_LVL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">smk_netlbl_mls</span><span class="p">(</span><span class="n">smack_cipso_direct</span><span class="p">,</span> <span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_smk_fs - get the smackfs superblock</span>
<span class="cm"> *</span>
<span class="cm"> * register the smackfs</span>
<span class="cm"> *</span>
<span class="cm"> * Do not register smackfs if Smack wasn&#39;t enabled</span>
<span class="cm"> * on boot. We can not put this method normally under the</span>
<span class="cm"> * smack_init() code path since the security subsystem get</span>
<span class="cm"> * initialized before the vfs caches.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if we were not chosen on boot or if</span>
<span class="cm"> * we were chosen and filesystem registration succeeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_smk_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">security_module_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smk_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smackfs_mount</span> <span class="o">=</span> <span class="n">kern_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smk_fs_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">smackfs_mount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;smackfs:  could not mount!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">smackfs_mount</span><span class="p">);</span>
			<span class="n">smackfs_mount</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">smk_cipso_doi</span><span class="p">();</span>
	<span class="n">smk_unlbl_ambient</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_floor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_hat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_huh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_invalid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_star</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_preset_netlabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_web</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">init_smk_fs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
