<!DOCTYPE html>
<html><head><title>joekychen/linux » security › smack › smack_lsm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>smack_lsm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Simplified MAC Kernel (smack) security module</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the smack hook function implementations.</span>
<span class="cm"> *</span>
<span class="cm"> *  Authors:</span>
<span class="cm"> *	Casey Schaufler &lt;casey@schaufler-ca.com&gt;</span>
<span class="cm"> *	Jarkko Sakkinen &lt;jarkko.sakkinen@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007 Casey Schaufler &lt;casey@schaufler-ca.com&gt;</span>
<span class="cm"> *  Copyright (C) 2009 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> *                Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *  Copyright (C) 2010 Nokia Corporation</span>
<span class="cm"> *  Copyright (C) 2011 Intel Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License version 2,</span>
<span class="cm"> *      as published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/kd.h&gt;</span>
<span class="cp">#include &lt;asm/ioctls.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/pipe_fs_i.h&gt;</span>
<span class="cp">#include &lt;net/cipso_ipv4.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/msg.h&gt;</span>
<span class="cp">#include &lt;linux/shm.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &quot;smack.h&quot;</span>

<span class="cp">#define task_security(task)	(task_cred_xxx((task), security))</span>

<span class="cp">#define TRANS_TRUE	&quot;TRUE&quot;</span>
<span class="cp">#define TRANS_TRUE_SIZE	4</span>

<span class="cm">/**</span>
<span class="cm"> * smk_fetch - Fetch the smack label from a file.</span>
<span class="cm"> * @ip: a pointer to the inode</span>
<span class="cm"> * @dp: a pointer to the dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the master list entry for the Smack label</span>
<span class="cm"> * or NULL if there was no label to fetch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smk_fetch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SMK_LONGLABEL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">SMK_LONGLABEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * new_inode_smack - allocate an inode security blob</span>
<span class="cm"> * @smack: a pointer to the Smack label to use in the blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the new blob or NULL if there&#39;s no memory available</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="nf">new_inode_smack</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">smack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode_smack</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">smack</span><span class="p">;</span>
	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">isp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * new_task_smack - allocate a task security blob</span>
<span class="cm"> * @smack: a pointer to the Smack label to use in the blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the new blob or NULL if there&#39;s no memory available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="nf">new_task_smack</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">forked</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_smack</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
	<span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span> <span class="o">=</span> <span class="n">forked</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tsp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_copy_rules - copy a rule set</span>
<span class="cm"> * @nhead - new rules header pointer</span>
<span class="cm"> * @ohead - old rules header pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ENOMEM on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_copy_rules</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">nhead</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ohead</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">nrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">orp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">nhead</span><span class="p">);</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">orp</span><span class="p">,</span> <span class="n">ohead</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nrp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smack_rule</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nrp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">nrp</span> <span class="o">=</span> <span class="o">*</span><span class="n">orp</span><span class="p">;</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nrp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">nhead</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LSM hooks.</span>
<span class="cm"> * We he, that is fun!</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_ptrace_access_check - Smack approval on PTRACE_ATTACH</span>
<span class="cm"> * @ctp: child task pointer</span>
<span class="cm"> * @mode: ptrace attachment mode</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is OK, an error code otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Do the capability checks, and require read and write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ctp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_ptrace_access_check</span><span class="p">(</span><span class="n">ctp</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">ctp</span><span class="p">));</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">ctp</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">tsp</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_ptrace_traceme - Smack approval on PTRACE_TRACEME</span>
<span class="cm"> * @ptp: parent task pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is OK, an error code otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Do the capability checks, and require read and write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ptp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_ptrace_traceme</span><span class="p">(</span><span class="n">ptp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">ptp</span><span class="p">));</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">ptp</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">tsp</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_syslog - Smack approval on syslog</span>
<span class="cm"> * @type: message type</span>
<span class="cm"> *</span>
<span class="cm"> * Require that the task has the floor label</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">typefrom_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_OVERRIDE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	 <span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Superblock Hooks.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_alloc_security - allocate a superblock blob</span>
<span class="cm"> * @sb: the superblock getting the blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or -ENOMEM on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sbsp</span><span class="p">;</span>

	<span class="n">sbsp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">superblock_smack</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_root</span> <span class="o">=</span> <span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_default</span> <span class="o">=</span> <span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_floor</span> <span class="o">=</span> <span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_hat</span> <span class="o">=</span> <span class="n">smack_known_hat</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_sblock</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span> <span class="o">=</span> <span class="n">sbsp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_free_security - free a superblock blob</span>
<span class="cm"> * @sb: the superblock getting the blob</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_sb_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_copy_data - copy mount options data for processing</span>
<span class="cm"> * @orig: where to start</span>
<span class="cm"> * @smackopts: mount options string</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or -ENOMEM on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy the Smack specific mount options out of the mount</span>
<span class="cm"> * options list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_copy_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">smackopts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="o">*</span><span class="n">commap</span><span class="p">,</span> <span class="o">*</span><span class="n">otheropts</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="n">otheropts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otheropts</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">orig</span><span class="p">,</span> <span class="n">commap</span> <span class="o">=</span> <span class="n">orig</span><span class="p">;</span> <span class="n">commap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">commap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">SMK_FSDEFAULT</span><span class="p">)</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
			<span class="n">dp</span> <span class="o">=</span> <span class="n">smackopts</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">SMK_FSFLOOR</span><span class="p">)</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
			<span class="n">dp</span> <span class="o">=</span> <span class="n">smackopts</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">SMK_FSHAT</span><span class="p">)</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
			<span class="n">dp</span> <span class="o">=</span> <span class="n">smackopts</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">SMK_FSROOT</span><span class="p">)</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
			<span class="n">dp</span> <span class="o">=</span> <span class="n">smackopts</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dp</span> <span class="o">=</span> <span class="n">otheropts</span><span class="p">;</span>

		<span class="n">commap</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">commap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">commap</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">otheropts</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">otheropts</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_kern_mount - Smack specific mount processing</span>
<span class="cm"> * @sb: the file system superblock</span>
<span class="cm"> * @flags: the mount flags</span>
<span class="cm"> * @data: the smack mount options</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, an error code on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">commap</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nsp</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_sblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_initialized</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_sblock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_sblock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">op</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span> <span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">op</span> <span class="o">=</span> <span class="n">commap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">commap</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">commap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">commap</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SMK_FSHAT</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSHAT</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSHAT</span><span class="p">);</span>
			<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_hat</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SMK_FSFLOOR</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSFLOOR</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSFLOOR</span><span class="p">);</span>
			<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_floor</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SMK_FSDEFAULT</span><span class="p">,</span>
				   <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSDEFAULT</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSDEFAULT</span><span class="p">);</span>
			<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_default</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SMK_FSROOT</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSROOT</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">SMK_FSROOT</span><span class="p">);</span>
			<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_root</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the root inode.</span>
<span class="cm">	 */</span>
	<span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="n">new_inode_smack</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_root</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">smk_root</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_statfs - Smack check on statfs</span>
<span class="cm"> * @dentry: identifies the file system in question</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can read the floor of the filesystem,</span>
<span class="cm"> * and error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">smk_floor</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_mount - Smack check for mounting</span>
<span class="cm"> * @dev_name: unused</span>
<span class="cm"> * @path: mount point</span>
<span class="cm"> * @type: unused</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can write the floor of the filesystem</span>
<span class="cm"> * being mounted on, an error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">smk_floor</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sb_umount - Smack check for unmounting</span>
<span class="cm"> * @mnt: file system to unmount</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can write the floor of the filesystem</span>
<span class="cm"> * being unmounted, an error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sb_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">smk_floor</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * BPRM hooks</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_bprm_set_creds - set creds for exec</span>
<span class="cm"> * @bprm: the exec information</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if it gets a blob, -ENOMEM otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">bsp</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_bprm_set_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred_prepared</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">==</span> <span class="n">bsp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">bsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_bprm_committing_creds - Prepare to install the new credentials</span>
<span class="cm"> * from bprm.</span>
<span class="cm"> *</span>
<span class="cm"> * @bprm: binprm for exec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_bprm_committing_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">bsp</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">!=</span> <span class="n">bsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_bprm_secureexec - Return the decision to use secureexec.</span>
<span class="cm"> * @bprm: binprm for exec</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cap_bprm_secureexec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">!=</span> <span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inode hooks</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_alloc_security - allocate an inode blob</span>
<span class="cm"> * @inode: the inode in need of a blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if it gets a blob, -ENOMEM otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="n">new_inode_smack</span><span class="p">(</span><span class="n">smk_of_current</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_free_security - free an inode blob</span>
<span class="cm"> * @inode: the inode with a blob</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer in inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_inode_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_init_security - copy out the smack from an inode</span>
<span class="cm"> * @inode: the inode</span>
<span class="cm"> * @dir: unused</span>
<span class="cm"> * @qstr: unused</span>
<span class="cm"> * @name: where to put the attribute name</span>
<span class="cm"> * @value: where to put the attribute value</span>
<span class="cm"> * @len: where to put the length of the attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if it all works out, -ENOMEM if there&#39;s no memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">issp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">csp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dsp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">XATTR_SMACK_SUFFIX</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">csp</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">may</span> <span class="o">=</span> <span class="n">smk_access_entry</span><span class="p">(</span><span class="n">csp</span><span class="p">,</span> <span class="n">dsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the access rule allows transmutation and</span>
<span class="cm">		 * the directory requests transmutation then</span>
<span class="cm">		 * by all means transmute.</span>
<span class="cm">		 * Mark the inode as changed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">may</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">may</span> <span class="o">&amp;</span> <span class="n">MAY_TRANSMUTE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">smk_inode_transmutable</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">isp</span> <span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
			<span class="n">issp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">|=</span> <span class="n">SMK_INODE_CHANGED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">isp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_link - Smack check on link</span>
<span class="cm"> * @old_dentry: the existing object</span>
<span class="cm"> * @dir: unused</span>
<span class="cm"> * @new_dentry: the new object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">);</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_unlink - Smack check on inode deletion</span>
<span class="cm"> * @dir: containing directory object</span>
<span class="cm"> * @dentry: file to unlink</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can write the containing directory</span>
<span class="cm"> * and the object, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * You need write access to the thing you&#39;re unlinking</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * You also need write access to the containing directory</span>
<span class="cm">		 */</span>
		<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">smk_ad_setfield_u_fs_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_rmdir - Smack check on directory deletion</span>
<span class="cm"> * @dir: containing directory object</span>
<span class="cm"> * @dentry: directory to unlink</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can write the containing directory</span>
<span class="cm"> * and the directory, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * You need write access to the thing you&#39;re removing</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * You also need write access to the containing directory</span>
<span class="cm">		 */</span>
		<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">smk_ad_setfield_u_fs_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_rename - Smack check on rename</span>
<span class="cm"> * @old_inode: the old directory</span>
<span class="cm"> * @old_dentry: unused</span>
<span class="cm"> * @new_inode: the new directory</span>
<span class="cm"> * @new_dentry: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Read and write access is required on both the old and</span>
<span class="cm"> * new directories.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">);</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_permission - Smack version of permission()</span>
<span class="cm"> * @inode: the inode in question</span>
<span class="cm"> * @mask: the access requested</span>
<span class="cm"> *</span>
<span class="cm"> * This is the important Smack hook.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, -EACCES otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_block</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_NOT_BLOCK</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">MAY_READ</span><span class="o">|</span><span class="n">MAY_WRITE</span><span class="o">|</span><span class="n">MAY_EXEC</span><span class="o">|</span><span class="n">MAY_APPEND</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * No permission to check. Existence test. Yup, it&#39;s there.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* May be droppable after audit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">no_block</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_INODE</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_setattr - Smack check for setting attributes</span>
<span class="cm"> * @dentry: the object</span>
<span class="cm"> * @iattr: for the force flag</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need to allow for clearing the setuid bit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_FORCE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_getattr - Smack check for getting attributes</span>
<span class="cm"> * @mnt: unused</span>
<span class="cm"> * @dentry: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_setxattr - Smack check for setting xattrs</span>
<span class="cm"> * @dentry: the object</span>
<span class="cm"> * @name: name of the attribute</span>
<span class="cm"> * @value: unused</span>
<span class="cm"> * @size: unused</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> *</span>
<span class="cm"> * This protects the Smack attribute explicitly.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKIPIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKIPOUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKEXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKMMAP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * check label validity here so import wont fail on</span>
<span class="cm">		 * post_setxattr</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">SMK_LONGLABEL</span> <span class="o">||</span>
		    <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKTRANSMUTE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">TRANS_TRUE_SIZE</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TRANS_TRUE</span><span class="p">,</span> <span class="n">TRANS_TRUE_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_inode_setxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_post_setxattr - Apply the Smack update approved above</span>
<span class="cm"> * @dentry: object</span>
<span class="cm"> * @name: attribute name</span>
<span class="cm"> * @value: attribute value</span>
<span class="cm"> * @size: attribute size</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Set the pointer in the inode blob to the entry found</span>
<span class="cm"> * in the master label list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_inode_post_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKEXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKMMAP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span> <span class="o">=</span> <span class="n">nsp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span> <span class="o">=</span> <span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKTRANSMUTE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">|=</span> <span class="n">SMK_INODE_TRANSMUTE</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_getxattr - Smack check on getxattr</span>
<span class="cm"> * @dentry: the object</span>
<span class="cm"> * @name: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_removexattr - Smack check on removexattr</span>
<span class="cm"> * @dentry: the object</span>
<span class="cm"> * @name: name of the attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Removing the Smack attribute requires CAP_MAC_ADMIN</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is permitted, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKIPIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKIPOUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKEXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKTRANSMUTE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACKMMAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_inode_removexattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_DENTRY</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path_dentry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_getsecurity - get smack xattrs</span>
<span class="cm"> * @inode: the object</span>
<span class="cm"> * @name: attribute name</span>
<span class="cm"> * @buffer: where to put the result</span>
<span class="cm"> * @alloc: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of the attribute or an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_getsecurity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ilen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_SUFFIX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">smk_of_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">isp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">isp</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ilen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The rest of the Smack xattrs are only on sockets.</span>
<span class="cm">	 */</span>
	<span class="n">sbp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">!=</span> <span class="n">SOCKFS_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">SOCKET_I</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_IPIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_IPOUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">isp</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">ilen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">isp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">isp</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ilen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * smack_inode_listsecurity - list the Smack attributes</span>
<span class="cm"> * @inode: the object</span>
<span class="cm"> * @buffer: where they go</span>
<span class="cm"> * @buffer_size: size of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EINVAL otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_listsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">XATTR_NAME_SMACK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACK</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_getsecid - Extract inode&#39;s security id</span>
<span class="cm"> * @inode: inode to extract the info from</span>
<span class="cm"> * @secid: where result will be saved</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_inode_getsecid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * File Hooks</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_permission - Smack check on file operations</span>
<span class="cm"> * @file: unused</span>
<span class="cm"> * @mask: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> *</span>
<span class="cm"> * Should access checks be done on each read or write?</span>
<span class="cm"> * UNICOS and SELinux say yes.</span>
<span class="cm"> * Trusted Solaris, Trusted Irix, and just about everyone else says no.</span>
<span class="cm"> *</span>
<span class="cm"> * I&#39;ll say no for now. Smack does not do the frequent</span>
<span class="cm"> * label changing that SELinux does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_alloc_security - assign a file security blob</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> *</span>
<span class="cm"> * The security blob for a file is a pointer to the master</span>
<span class="cm"> * label list, so no allocation is done.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_free_security - clear a file security blob</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> *</span>
<span class="cm"> * The security blob for a file is a pointer to the master</span>
<span class="cm"> * label list, so no memory is freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_file_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_ioctl - Smack check on ioctls</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> * @cmd: what to do</span>
<span class="cm"> * @arg: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Relies heavily on the correct use of the ioctl command conventions.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if allowed, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_WRITE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_READ</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_lock - Smack check on file locking</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> * @cmd: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has write access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_fcntl - Smack check on fcntl</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> * @cmd: what action to check</span>
<span class="cm"> * @arg: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Generally these operations are harmless.</span>
<span class="cm"> * File locking operations present an obvious mechanism</span>
<span class="cm"> * for passing information, so they require write access.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_fcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_GETLK</span>:
	<span class="k">case</span> <span class="n">F_SETLK</span>:
	<span class="k">case</span> <span class="n">F_SETLKW</span>:
	<span class="k">case</span> <span class="n">F_SETOWN</span>:
	<span class="k">case</span> <span class="n">F_SETSIG</span>:
		<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_PATH</span><span class="p">);</span>
		<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_mmap_file :</span>
<span class="cm"> * Check permissions for a mmap operation.  The @file may be NULL, e.g.</span>
<span class="cm"> * if mapping anonymous memory.</span>
<span class="cm"> * @file contains the file structure for file to map (may be NULL).</span>
<span class="cm"> * @reqprot contains the protection requested by the application.</span>
<span class="cm"> * @prot contains the protection that will be applied by the kernel.</span>
<span class="cm"> * @flags contains the operational flags.</span>
<span class="cm"> * Return 0 if permission is granted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msmack</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">osmack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msmack</span> <span class="o">=</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">current_security</span><span class="p">();</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * For each Smack rule associated with the subject</span>
<span class="cm">	 * label verify that the SMACK64MMAP also has access</span>
<span class="cm">	 * to that rule&#39;s object label.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">srp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osmack</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_object</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Matching labels always allows access.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msmack</span> <span class="o">==</span> <span class="n">osmack</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is a matching local rule take</span>
<span class="cm">		 * that into account as well.</span>
<span class="cm">		 */</span>
		<span class="n">may</span> <span class="o">=</span> <span class="n">smk_access_entry</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_subject</span><span class="p">,</span> <span class="n">osmack</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">may</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">may</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">may</span> <span class="o">&amp;=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">smk_access</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If may is zero the SMACK64MMAP subject can&#39;t</span>
<span class="cm">		 * possibly have less access.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">may</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fetch the global list entry.</span>
<span class="cm">		 * If there isn&#39;t one a SMACK64MMAP subject</span>
<span class="cm">		 * can&#39;t have as much access as current.</span>
<span class="cm">		 */</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">msmack</span><span class="p">);</span>
		<span class="n">mmay</span> <span class="o">=</span> <span class="n">smk_access_entry</span><span class="p">(</span><span class="n">msmack</span><span class="p">,</span> <span class="n">osmack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmay</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is a local entry it modifies the</span>
<span class="cm">		 * potential access, too.</span>
<span class="cm">		 */</span>
		<span class="n">tmay</span> <span class="o">=</span> <span class="n">smk_access_entry</span><span class="p">(</span><span class="n">msmack</span><span class="p">,</span> <span class="n">osmack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmay</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">mmay</span> <span class="o">&amp;=</span> <span class="n">tmay</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is any access available to current that is</span>
<span class="cm">		 * not available to a SMACK64MMAP subject</span>
<span class="cm">		 * deny access.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">may</span> <span class="o">|</span> <span class="n">mmay</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mmay</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_set_fowner - set the file security blob value</span>
<span class="cm"> * @file: object in question</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> * Further research may be required on this one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_set_fowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_send_sigiotask - Smack on sigio</span>
<span class="cm"> * @tsk: The target task</span>
<span class="cm"> * @fown: the object the signal come from</span>
<span class="cm"> * @signum: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Allow a privileged task to get signals even if it shouldn&#39;t</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if a subject with the object&#39;s smack could</span>
<span class="cm"> * write to the task, an error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_send_sigiotask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * struct fown_struct is never outside the context of a struct file</span>
<span class="cm">	 */</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fown</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span><span class="p">,</span> <span class="n">f_owner</span><span class="p">);</span>

	<span class="cm">/* we don&#39;t log here as rc can be overriden */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">has_capability</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">CAP_MAC_OVERRIDE</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">smack_log</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_receive - Smack file receive check</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_fs_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This code relies on bitmasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">may</span> <span class="o">|=</span> <span class="n">MAY_WRITE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span><span class="p">,</span> <span class="n">may</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_file_open - Smack dentry open processing</span>
<span class="cm"> * @file: the object</span>
<span class="cm"> * @cred: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Set the security blob in the file structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_security</span> <span class="o">=</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Task hooks</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_cred_alloc_blank - &quot;allocate&quot; blank task-level security credentials</span>
<span class="cm"> * @new: the new credentials</span>
<span class="cm"> * @gfp: the atomicity of any memory allocations</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare a blank set of credentials for modification.  This must allocate all</span>
<span class="cm"> * the memory the LSM module might require such that cred_transfer() can</span>
<span class="cm"> * complete without error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_cred_alloc_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">new_task_smack</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * smack_cred_free - &quot;free&quot; task-level security credentials</span>
<span class="cm"> * @cred: the credentials in question</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_cred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_rule</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smack_rule</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_cred_prepare - prepare new set of credentials for modification</span>
<span class="cm"> * @new: the new credentials</span>
<span class="cm"> * @old: the original credentials</span>
<span class="cm"> * @gfp: the atomicity of any memory allocations</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare a new set of credentials for modification.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_cred_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">old_tsp</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">new_tsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">new_tsp</span> <span class="o">=</span> <span class="n">new_task_smack</span><span class="p">(</span><span class="n">old_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">,</span> <span class="n">old_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_copy_rules</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">new_tsp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_cred_transfer - Transfer the old credentials to the new credentials</span>
<span class="cm"> * @new: the new credentials</span>
<span class="cm"> * @old: the original credentials</span>
<span class="cm"> *</span>
<span class="cm"> * Fill in a set of blank credentials from another set of credentials.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_cred_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">old_tsp</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">new_tsp</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">old_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">;</span>
	<span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span> <span class="o">=</span> <span class="n">old_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">);</span>


	<span class="cm">/* cbs copy rule list */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_kernel_act_as - Set the subjective context in a set of credentials</span>
<span class="cm"> * @new: points to the set of credentials to be modified.</span>
<span class="cm"> * @secid: specifies the security ID to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Set the security data for a kernel service.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_kernel_act_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">new_tsp</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span> <span class="o">=</span> <span class="n">smack_from_secid</span><span class="p">(</span><span class="n">secid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">new_tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">smack</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_kernel_create_files_as - Set the file creation label in a set of creds</span>
<span class="cm"> * @new: points to the set of credentials to be modified</span>
<span class="cm"> * @inode: points to the inode to use as a reference</span>
<span class="cm"> *</span>
<span class="cm"> * Set the file creation context in a set of credentials to the same</span>
<span class="cm"> * as the objective context of the specified inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_kernel_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span> <span class="o">=</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span><span class="p">;</span>
	<span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_curacc_on_task - helper to log task related access</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @access: the access requested</span>
<span class="cm"> * @caller: name of the calling function for audit</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_curacc_on_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">caller</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">access</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_setpgid - Smack check on setting pgid</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @pgid: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if write access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_setpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_getpgid - Smack access check for getpgid</span>
<span class="cm"> * @p: the object task</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can read the object task, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_getpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_getsid - Smack access check for getsid</span>
<span class="cm"> * @p: the object task</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can read the object task, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_getsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_getsecid - get the secid of the task</span>
<span class="cm"> * @p: the object task</span>
<span class="cm"> * @secid: where to put the result</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the secid to contain a u32 version of the smack label.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_task_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_setnice - Smack check on setting nice</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @nice: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if write access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setnice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_setioprio - Smack check on setting ioprio</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @ioprio: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if write access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setioprio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ioprio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_getioprio - Smack check on reading ioprio</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if read access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_getioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_setscheduler - Smack check on setting scheduler</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @policy: unused</span>
<span class="cm"> * @lp: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if read access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cap_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_getscheduler - Smack check on reading scheduler</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if read access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_getscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_movememory - Smack check on moving memory</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if write access is permitted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_movememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_on_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_kill - Smack check on signal delivery</span>
<span class="cm"> * @p: the task object</span>
<span class="cm"> * @info: unused</span>
<span class="cm"> * @sig: unused</span>
<span class="cm"> * @secid: identifies the smack to use in lieu of current&#39;s</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if write access is permitted</span>
<span class="cm"> *</span>
<span class="cm"> * The secid behavior is an artifact of an SELinux hack</span>
<span class="cm"> * in the USB code. Someday it may go away.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sending a signal requires that the sender</span>
<span class="cm">	 * can write the receiver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">MAY_WRITE</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the secid isn&#39;t 0 we&#39;re dealing with some USB IO</span>
<span class="cm">	 * specific behavior. This is not clean. For one thing</span>
<span class="cm">	 * we can&#39;t take privilege into account.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">smack_from_secid</span><span class="p">(</span><span class="n">secid</span><span class="p">),</span>
			  <span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_wait - Smack access check for waiting</span>
<span class="cm"> * @p: task to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current can wait for p, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_task_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">smk_of_forked</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t log here, we can be overriden */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">tsp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_log</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the operation to succeed if either task</span>
<span class="cm">	 * has privilege to perform operations that might</span>
<span class="cm">	 * account for the smack labels having gotten to</span>
<span class="cm">	 * be different in the first place.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This breaks the strict subject/object access</span>
<span class="cm">	 * control ideal, taking the object&#39;s privilege</span>
<span class="cm">	 * state into account in the decision as well as</span>
<span class="cm">	 * the smack value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_OVERRIDE</span><span class="p">)</span> <span class="o">||</span> <span class="n">has_capability</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CAP_MAC_OVERRIDE</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* we log only if we didn&#39;t get overriden */</span>
 <span class="nl">out_log:</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_TASK</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_tsk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">smack_log</span><span class="p">(</span><span class="n">tsp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_task_to_inode - copy task smack into the inode blob</span>
<span class="cm"> * @p: task to copy from</span>
<span class="cm"> * @inode: inode to copy to</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the smack pointer in the inode security blob</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_task_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Socket hooks.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sk_alloc_security - Allocate a socket blob</span>
<span class="cm"> * @sk: the socket</span>
<span class="cm"> * @family: unused</span>
<span class="cm"> * @gfp_flags: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Assign Smack pointers to current</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ENOMEM is there&#39;s no memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sk_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">csp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket_smack</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span> <span class="o">=</span> <span class="n">csp</span><span class="p">;</span>
	<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span> <span class="o">=</span> <span class="n">csp</span><span class="p">;</span>
	<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sk_free_security - Free a socket blob</span>
<span class="cm"> * @sk: the socket</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_sk_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* smack_host_label - check host based restrictions</span>
<span class="cm">* @sip: the object end</span>
<span class="cm">*</span>
<span class="cm">* looks for host based access restrictions</span>
<span class="cm">*</span>
<span class="cm">* This version will only be appropriate for really small sets of single label</span>
<span class="cm">* hosts.  The caller is responsible for ensuring that the RCU read lock is</span>
<span class="cm">* taken before calling this function.</span>
<span class="cm">*</span>
<span class="cm">* Returns the label of the far end or NULL if it&#39;s not special.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smack_host_label</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smk_netlbladdr</span> <span class="o">*</span><span class="n">snp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">siap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sip</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">siap</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">snp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smk_netlbladdr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		* we break after finding the first match because</span>
<span class="cm">		* the list is sorted from longest to shortest mask</span>
<span class="cm">		* so we have found the most specific match</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">&amp;</span><span class="n">snp</span><span class="o">-&gt;</span><span class="n">smk_host</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">==</span>
		    <span class="p">(</span><span class="n">siap</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">snp</span><span class="o">-&gt;</span><span class="n">smk_mask</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we have found the special CIPSO option */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snp</span><span class="o">-&gt;</span><span class="n">smk_label</span> <span class="o">==</span> <span class="n">smack_cipso_option</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">snp</span><span class="o">-&gt;</span><span class="n">smk_label</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_netlabel - Set the secattr on a socket</span>
<span class="cm"> * @sk: the socket</span>
<span class="cm"> * @labeled: socket label scheme</span>
<span class="cm"> *</span>
<span class="cm"> * Convert the outbound smack value (smk_out) to a</span>
<span class="cm"> * secattr and attach it to the socket.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_netlabel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">labeled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Usually the netlabel code will handle changing the</span>
<span class="cm">	 * packet labeling based on the label.</span>
<span class="cm">	 * The case of a single label host is different, because</span>
<span class="cm">	 * a single label host should never get a labeled packet</span>
<span class="cm">	 * even though the label is usually associated with a packet</span>
<span class="cm">	 * label.</span>
<span class="cm">	 */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">bh_lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span> <span class="o">==</span> <span class="n">smack_net_ambient</span> <span class="o">||</span>
	    <span class="n">labeled</span> <span class="o">==</span> <span class="n">SMACK_UNLABELED_SOCKET</span><span class="p">)</span>
		<span class="n">netlbl_sock_delattr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_sock_setattr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_netlbel_send - Set the secattr on a socket and perform access checks</span>
<span class="cm"> * @sk: the socket</span>
<span class="cm"> * @sap: the destination address</span>
<span class="cm"> *</span>
<span class="cm"> * Set the correct secattr for the given socket based on the destination</span>
<span class="cm"> * address and perform any outbound access checks needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or an error code.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_netlabel_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sk_lbl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hostsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">hostsp</span> <span class="o">=</span> <span class="n">smack_host_label</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostsp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
		<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span><span class="p">;</span>

		<span class="n">smk_ad_init_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">);</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">sin_family</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dport</span> <span class="o">=</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">;</span>
		<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">v4info</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">sk_lbl</span> <span class="o">=</span> <span class="n">SMACK_UNLABELED_SOCKET</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">,</span> <span class="n">hostsp</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sk_lbl</span> <span class="o">=</span> <span class="n">SMACK_CIPSO_SOCKET</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smack_netlabel</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk_lbl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inode_setsecurity - set smack xattrs</span>
<span class="cm"> * @inode: the object</span>
<span class="cm"> * @name: attribute name</span>
<span class="cm"> * @value: attribute value</span>
<span class="cm"> * @size: size of the attribute</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the named attribute in the appropriate blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, or an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_setsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">nsp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">SMK_LONGLABEL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_SUFFIX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
		<span class="n">nsp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">|=</span> <span class="n">SMK_INODE_INSTANT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The rest of the Smack xattrs are only on sockets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">!=</span> <span class="n">SOCKFS_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_IPIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SMACK_IPOUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_UNIX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">smack_netlabel</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SMACK_CIPSO_SOCKET</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;Smack: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> netlbl error %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_socket_post_create - finish socket setup</span>
<span class="cm"> * @sock: the socket</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @type: unused</span>
<span class="cm"> * @protocol: unused</span>
<span class="cm"> * @kern: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the netlabel information on the socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, and error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">!=</span> <span class="n">PF_INET</span> <span class="o">||</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the outbound netlbl.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">smack_netlabel</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SMACK_CIPSO_SOCKET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_socket_connect - connect access check</span>
<span class="cm"> * @sock: the socket</span>
<span class="cm"> * @sap: the other end</span>
<span class="cm"> * @addrlen: size of sap</span>
<span class="cm"> *</span>
<span class="cm"> * Verifies that a connection may be possible</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, and error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_INET</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smack_netlabel_send</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">sap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_flags_to_may - convert S_ to MAY_ values</span>
<span class="cm"> * @flags: the S_ value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the equivalent MAY_ value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_flags_to_may</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_IRUGO</span><span class="p">)</span>
		<span class="n">may</span> <span class="o">|=</span> <span class="n">MAY_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_IWUGO</span><span class="p">)</span>
		<span class="n">may</span> <span class="o">|=</span> <span class="n">MAY_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_IXUGO</span><span class="p">)</span>
		<span class="n">may</span> <span class="o">|=</span> <span class="n">MAY_EXEC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">may</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_msg_alloc_security - Set the security blob for msg_msg</span>
<span class="cm"> * @msg: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_msg_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_msg_free_security - Clear the security blob for msg_msg</span>
<span class="cm"> * @msg: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_msg_msg_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_of_shm - the smack pointer for the shm</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the smack value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smack_of_shm</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_shm_alloc_security - Set the security blob for shm</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_shm_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_shm_free_security - Clear the security blob for shm</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_shm_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_curacc_shm : check if current has access on shm</span>
<span class="cm"> * @shp : the object</span>
<span class="cm"> * @access : access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_curacc_shm</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">smack_of_shm</span><span class="p">(</span><span class="n">shp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_shm_associate - Smack access check for shm</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> * @shmflg: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_shm_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">shmflg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc_shm</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_shm_shmctl - Smack access check for shm</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> * @cmd: what it wants to do</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_shm_shmctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SHM_STAT</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
	<span class="k">case</span> <span class="n">SHM_LOCK</span>:
	<span class="k">case</span> <span class="n">SHM_UNLOCK</span>:
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READWRITE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SHM_INFO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * System level information.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">smk_curacc_shm</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_shm_shmat - Smack access for shmat</span>
<span class="cm"> * @shp: the object</span>
<span class="cm"> * @shmaddr: unused</span>
<span class="cm"> * @shmflg: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_shm_shmat</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">shmflg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc_shm</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_of_sem - the smack pointer for the sem</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the smack value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smack_of_sem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sem_alloc_security - Set the security blob for sem</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sem_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sem_free_security - Clear the security blob for sem</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_sem_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_curacc_sem : check if current has access on sem</span>
<span class="cm"> * @sma : the object</span>
<span class="cm"> * @access : access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_curacc_sem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">smack_of_sem</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sem_associate - Smack access check for sem</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> * @semflg: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sem_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">semflg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc_sem</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sem_shmctl - Smack access check for sem</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> * @cmd: what it wants to do</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sem_semctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GETPID</span>:
	<span class="k">case</span> <span class="n">GETNCNT</span>:
	<span class="k">case</span> <span class="n">GETZCNT</span>:
	<span class="k">case</span> <span class="n">GETVAL</span>:
	<span class="k">case</span> <span class="n">GETALL</span>:
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SEM_STAT</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SETVAL</span>:
	<span class="k">case</span> <span class="n">SETALL</span>:
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READWRITE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SEM_INFO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * System level information</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">smk_curacc_sem</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sem_semop - Smack checks of semaphore operations</span>
<span class="cm"> * @sma: the object</span>
<span class="cm"> * @sops: unused</span>
<span class="cm"> * @nsops: unused</span>
<span class="cm"> * @alter: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Treated as read and write in all cases.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if access is allowed, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_sem_semop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_sem</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_alloc_security - Set the security blob for msg</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_queue_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">kisp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">;</span>

	<span class="n">kisp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_free_security - Clear the security blob for msg</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_msg_queue_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">kisp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">;</span>

	<span class="n">kisp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_of_msq - the smack pointer for the msq</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the smack value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smack_of_msq</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">security</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smk_curacc_msq : helper to check if current has access on msq</span>
<span class="cm"> * @msq : the msq</span>
<span class="cm"> * @access : access requested</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 if current has access, error otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smk_curacc_msq</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msp</span> <span class="o">=</span> <span class="n">smack_of_msq</span><span class="p">(</span><span class="n">msq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">msp</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_queue_associate - Smack access check for msg_queue</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> * @msqflg: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_queue_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">msqflg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc_msq</span><span class="p">(</span><span class="n">msq</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_queue_msgctl - Smack access check for msg_queue</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> * @cmd: what it wants to do</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_queue_msgctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">MSG_STAT</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">may</span> <span class="o">=</span> <span class="n">MAY_READWRITE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">MSG_INFO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * System level information</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">smk_curacc_msq</span><span class="p">(</span><span class="n">msq</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_queue_msgsnd - Smack access check for msg_queue</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> * @msg: unused</span>
<span class="cm"> * @msqflg: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has the requested access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_queue_msgsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may</span><span class="p">;</span>

	<span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">msqflg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">smk_curacc_msq</span><span class="p">(</span><span class="n">msq</span><span class="p">,</span> <span class="n">may</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_msg_queue_msgsnd - Smack access check for msg_queue</span>
<span class="cm"> * @msq: the object</span>
<span class="cm"> * @msg: unused</span>
<span class="cm"> * @target: unused</span>
<span class="cm"> * @type: unused</span>
<span class="cm"> * @mode: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has read and write access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_msg_queue_msgrcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smk_curacc_msq</span><span class="p">(</span><span class="n">msq</span><span class="p">,</span> <span class="n">MAY_READWRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_ipc_permission - Smack access for ipc_permission()</span>
<span class="cm"> * @ipp: the object permissions</span>
<span class="cm"> * @flag: access requested</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if current has read and write access, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_ipc_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipp</span><span class="p">,</span> <span class="kt">short</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">isp</span> <span class="o">=</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may</span> <span class="o">=</span> <span class="n">smack_flags_to_may</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_IPC</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ipc_id</span> <span class="o">=</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smk_curacc</span><span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="n">may</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_ipc_getsecid - Extract smack security id</span>
<span class="cm"> * @ipp: the object permissions</span>
<span class="cm"> * @secid: where result will be saved</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_ipc_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span> <span class="o">=</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>

	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">smack</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_d_instantiate - Make sure the blob is correct on an inode</span>
<span class="cm"> * @opt_dentry: dentry where inode will be attached</span>
<span class="cm"> * @inode: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Set the inode&#39;s security blob if it hasn&#39;t been done already.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">opt_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">superblock_smack</span> <span class="o">*</span><span class="n">sbsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_smack</span> <span class="o">*</span><span class="n">isp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">csp</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fetched</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">final</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">trattr</span><span class="p">[</span><span class="n">TRANS_TRUE_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">transflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">isp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_security</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the inode is already instantiated</span>
<span class="cm">	 * take the quick way out</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">&amp;</span> <span class="n">SMK_INODE_INSTANT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlockandout</span><span class="p">;</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">sbsp</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_security</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re going to use the superblock default label</span>
<span class="cm">	 * if there&#39;s no label on the file.</span>
<span class="cm">	 */</span>
	<span class="n">final</span> <span class="o">=</span> <span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_default</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the root inode the superblock</span>
<span class="cm">	 * may be in the process of initialization.</span>
<span class="cm">	 * If that is the case use the root value out</span>
<span class="cm">	 * of the superblock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opt_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">==</span> <span class="n">opt_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">sbsp</span><span class="o">-&gt;</span><span class="n">smk_root</span><span class="p">;</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">|=</span> <span class="n">SMK_INODE_INSTANT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlockandout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is pretty hackish.</span>
<span class="cm">	 * Casey says that we shouldn&#39;t have to do</span>
<span class="cm">	 * file system specific code, but it does help</span>
<span class="cm">	 * with keeping it simple.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_magic</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMACK_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Casey says that it&#39;s a little embarrassing</span>
<span class="cm">		 * that the smack file system doesn&#39;t do</span>
<span class="cm">		 * extended attributes.</span>
<span class="cm">		 */</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PIPEFS_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Casey says pipes are easy (?)</span>
<span class="cm">		 */</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVPTS_SUPER_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * devpts seems content with the label of the task.</span>
<span class="cm">		 * Programs that change smack have to treat the</span>
<span class="cm">		 * pty with respect.</span>
<span class="cm">		 */</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">csp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCKFS_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Socket access is controlled by the socket</span>
<span class="cm">		 * structures associated with the task involved.</span>
<span class="cm">		 */</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PROC_SUPER_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Casey says procfs appears not to care.</span>
<span class="cm">		 * The superblock default suffices.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TMPFS_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Device labels should come from the filesystem,</span>
<span class="cm">		 * but watch out, because they&#39;re volitile,</span>
<span class="cm">		 * getting recreated on every reboot.</span>
<span class="cm">		 */</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * No break.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If a smack value has been set we want to use it,</span>
<span class="cm">		 * but since tmpfs isn&#39;t giving us the opportunity</span>
<span class="cm">		 * to set mount options simulate setting the</span>
<span class="cm">		 * superblock default.</span>
<span class="cm">		 */</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * This isn&#39;t an understood special case.</span>
<span class="cm">		 * Get the value from the xattr.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * UNIX domain sockets use lower level socket data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">final</span> <span class="o">=</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * No xattr support means, alas, no SMACK label.</span>
<span class="cm">		 * Use the aforeapplied default.</span>
<span class="cm">		 * It would be curious if the label of the task</span>
<span class="cm">		 * does not match that assigned.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get the dentry for xattr.</span>
<span class="cm">		 */</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">opt_dentry</span><span class="p">);</span>
		<span class="n">fetched</span> <span class="o">=</span> <span class="n">smk_fetch</span><span class="p">(</span><span class="n">XATTR_NAME_SMACK</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fetched</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">final</span> <span class="o">=</span> <span class="n">fetched</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Transmuting directory</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this is a new directory and the label was</span>
<span class="cm">			 * transmuted when the inode was initialized</span>
<span class="cm">			 * set the transmute attribute on the directory</span>
<span class="cm">			 * and mark the inode.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If there is a transmute attribute on the</span>
<span class="cm">			 * directory mark the inode.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">&amp;</span> <span class="n">SMK_INODE_CHANGED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SMK_INODE_CHANGED</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">setxattr</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span>
					<span class="n">XATTR_NAME_SMACKTRANSMUTE</span><span class="p">,</span>
					<span class="n">TRANS_TRUE</span><span class="p">,</span> <span class="n">TRANS_TRUE_SIZE</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span>
					<span class="n">XATTR_NAME_SMACKTRANSMUTE</span><span class="p">,</span> <span class="n">trattr</span><span class="p">,</span>
					<span class="n">TRANS_TRUE_SIZE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">trattr</span><span class="p">,</span> <span class="n">TRANS_TRUE</span><span class="p">,</span>
						       <span class="n">TRANS_TRUE_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">transflag</span> <span class="o">=</span> <span class="n">SMK_INODE_TRANSMUTE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_task</span> <span class="o">=</span> <span class="n">smk_fetch</span><span class="p">(</span><span class="n">XATTR_NAME_SMACKEXEC</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_mmap</span> <span class="o">=</span> <span class="n">smk_fetch</span><span class="p">(</span><span class="n">XATTR_NAME_SMACKMMAP</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>

		<span class="n">dput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">final</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">csp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_inode</span> <span class="o">=</span> <span class="n">final</span><span class="p">;</span>

	<span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SMK_INODE_INSTANT</span> <span class="o">|</span> <span class="n">transflag</span><span class="p">);</span>

<span class="nl">unlockandout:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isp</span><span class="o">-&gt;</span><span class="n">smk_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_getprocattr - Smack process attribute access</span>
<span class="cm"> * @p: the object task</span>
<span class="cm"> * @name: the name of the attribute in /proc/.../attr</span>
<span class="cm"> * @value: where to put the result</span>
<span class="cm"> *</span>
<span class="cm"> * Places a copy of the task Smack into value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the length of the smack label or an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_getprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;current&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">smk_of_task</span><span class="p">(</span><span class="n">task_security</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">slen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">slen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_setprocattr - Smack process attribute setting</span>
<span class="cm"> * @p: the object task</span>
<span class="cm"> * @name: the name of the attribute in /proc/.../attr</span>
<span class="cm"> * @value: the value to set</span>
<span class="cm"> * @size: the size of the value</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the Smack value of the task. Only setting self</span>
<span class="cm"> * is permitted and only with privilege</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the length of the smack label or an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_setprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">oldtsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">newsmack</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Changing another process&#39; Smack value is too dangerous</span>
<span class="cm">	 * and supports no sane use case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">SMK_LONGLABEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;current&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">newsmack</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsmack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No process is ever allowed the web (&quot;@&quot;) label.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsmack</span> <span class="o">==</span> <span class="n">smack_known_web</span><span class="p">.</span><span class="n">smk_known</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">oldtsp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">new_task_smack</span><span class="p">(</span><span class="n">newsmack</span><span class="p">,</span> <span class="n">oldtsp</span><span class="o">-&gt;</span><span class="n">smk_forked</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_copy_rules</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldtsp</span><span class="o">-&gt;</span><span class="n">smk_rules</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsp</span><span class="p">;</span>
	<span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_unix_stream_connect - Smack access on UDS</span>
<span class="cm"> * @sock: one sock</span>
<span class="cm"> * @other: the other sock</span>
<span class="cm"> * @newsk: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if a subject with the smack of sock could access</span>
<span class="cm"> * an object with the smack of other, otherwise an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">osp</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">nsp</span> <span class="o">=</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span><span class="p">;</span>

	<span class="n">smk_ad_init_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_net_sk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_OVERRIDE</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">,</span> <span class="n">osp</span><span class="o">-&gt;</span><span class="n">smk_in</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cross reference the peer labels for SO_PEERSEC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">;</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">=</span> <span class="n">osp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_unix_may_send - Smack access on UDS</span>
<span class="cm"> * @sock: one socket</span>
<span class="cm"> * @other: the other socket</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if a subject with the smack of sock could access</span>
<span class="cm"> * an object with the smack of other, otherwise an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">osp</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span><span class="p">;</span>

	<span class="n">smk_ad_init_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">smk_ad_setfield_u_net_sk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MAC_OVERRIDE</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">,</span> <span class="n">osp</span><span class="o">-&gt;</span><span class="n">smk_in</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_socket_sendmsg - Smack check based on destination host</span>
<span class="cm"> * @sock: the socket</span>
<span class="cm"> * @msg: the message</span>
<span class="cm"> * @size: the size of the message</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the current subject can write to the destination</span>
<span class="cm"> * host. This is only a question if the destination is a single</span>
<span class="cm"> * label host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perfectly reasonable for this to be NULL</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sip</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sip</span><span class="o">-&gt;</span><span class="n">sin_family</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smack_netlabel_send</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">sip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_from_secattr - Convert a netlabel attr.mls.lvl/attr.mls.cat pair to smack</span>
<span class="cm"> * @sap: netlabel secattr</span>
<span class="cm"> * @ssp: socket security information</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a Smack label found on the label list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">smack_from_secattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_MLS_LVL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Looks like a CIPSO packet.</span>
<span class="cm">		 * If there are flags but no level netlabel isn&#39;t</span>
<span class="cm">		 * behaving the way we expect it to.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Look it up in the label table</span>
<span class="cm">		 * Without guidance regarding the smack value</span>
<span class="cm">		 * for the packet fall back on the network</span>
<span class="cm">		 * ambient value.</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span> <span class="o">!=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">lvl</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">,</span>
				<span class="n">kp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">,</span>
				<span class="n">SMK_CIPSOLEN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">smk_known</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span> <span class="o">==</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">smack_known_web</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_SECID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Looks like a fallback, which gives us a secid.</span>
<span class="cm">		 */</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">smack_from_secid</span><span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">secid</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This has got to be a bug because it is</span>
<span class="cm">		 * impossible to specify a fallback without</span>
<span class="cm">		 * specifying the label, which will ensure</span>
<span class="cm">		 * it has a secid, and the only way to get a</span>
<span class="cm">		 * secid is from a fallback.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Without guidance regarding the smack value</span>
<span class="cm">	 * for the packet fall back on the network</span>
<span class="cm">	 * ambient value.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">smack_net_ambient</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_socket_sock_rcv_skb - Smack packet delivery access check</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> * @skb: packet</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the packet should be delivered, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_sock_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="n">secattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">csp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_INET6</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Translate what netlabel gave us.</span>
<span class="cm">	 */</span>
	<span class="n">netlbl_secattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_skbuff_getattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">csp</span> <span class="o">=</span> <span class="n">smack_from_secattr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">,</span> <span class="n">ssp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">csp</span> <span class="o">=</span> <span class="n">smack_net_ambient</span><span class="p">;</span>

	<span class="n">netlbl_secattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">;</span>
	<span class="n">ipv4_skb_to_auditdata</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Receiving a packet requires that the other end</span>
<span class="cm">	 * be able to write here. Read access is not required.</span>
<span class="cm">	 * This is the simplist possible security model</span>
<span class="cm">	 * for networking.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">csp</span><span class="p">,</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">netlbl_skbuff_err</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_socket_getpeersec_stream - pull in packet label</span>
<span class="cm"> * @sock: the socket</span>
<span class="cm"> * @optval: user&#39;s destination</span>
<span class="cm"> * @optlen: size thereof</span>
<span class="cm"> * @len: max thereof</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero on success, an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_getpeersec_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rcp</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcp</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span><span class="p">;</span>
		<span class="n">slen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rcp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">rcp</span><span class="p">,</span> <span class="n">slen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">slen</span><span class="p">,</span> <span class="n">optlen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * smack_socket_getpeersec_dgram - pull in packet label</span>
<span class="cm"> * @sock: the peer socket</span>
<span class="cm"> * @skb: packet data</span>
<span class="cm"> * @secid: pointer to where to put the secid of the packet</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the netlabel socket state on sk from parent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_socket_getpeersec_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="n">secattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">family</span> <span class="o">=</span> <span class="n">PF_UNSPEC</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 0 is the invalid secid */</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
			<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span>
			<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_UNSPEC</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_UNIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">||</span> <span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Translate what netlabel gave us.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ssp</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
		<span class="n">netlbl_secattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_skbuff_getattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">smack_from_secattr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">,</span> <span class="n">ssp</span><span class="p">);</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">netlbl_secattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_sock_graft - Initialize a newly created socket with an existing sock</span>
<span class="cm"> * @sk: child sock</span>
<span class="cm"> * @parent: parent socket</span>
<span class="cm"> *</span>
<span class="cm"> * Set the smk_{in,out} state of an existing sock based on the process that</span>
<span class="cm"> * is creating the new socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">PF_INET6</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_out</span> <span class="o">=</span> <span class="n">smk_of_current</span><span class="p">();</span>
	<span class="cm">/* cssp-&gt;smk_packet is already set in smack_inet_csk_clone() */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inet_conn_request - Smack access check on connect</span>
<span class="cm"> * @sk: socket involved</span>
<span class="cm"> * @skb: packet</span>
<span class="cm"> * @req: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if a task with the packet label could write to</span>
<span class="cm"> * the socket, otherwise an error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inet_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smack_known</span> <span class="o">*</span><span class="n">skp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="n">secattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="k">struct</span> <span class="n">lsm_network_audit</span> <span class="n">net</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* handle mapped IPv4 packets arriving via IPv6 sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>

	<span class="n">netlbl_secattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_skbuff_getattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">smack_from_secattr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">,</span> <span class="n">ssp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">smack_known_huh</span><span class="p">.</span><span class="n">smk_known</span><span class="p">;</span>
	<span class="n">netlbl_secattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secattr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_NET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">netif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">;</span>
	<span class="n">ipv4_skb_to_auditdata</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Receiving a packet requires that the other end be able to write</span>
<span class="cm">	 * here. Read access is not required.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_in</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the peer&#39;s label in the request_sock so we can later setup</span>
<span class="cm">	 * smk_packet in the child socket so that SO_PEERCRED can report it.</span>
<span class="cm">	 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to decide if we want to label the incoming connection here</span>
<span class="cm">	 * if we do we only need to label the request_sock and the stack will</span>
<span class="cm">	 * propagate the wire-label to the sock when it is created.</span>
<span class="cm">	 */</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">hsp</span> <span class="o">=</span> <span class="n">smack_host_label</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skp</span> <span class="o">=</span> <span class="n">smk_find_entry</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">netlbl_req_setattr</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skp</span><span class="o">-&gt;</span><span class="n">smk_netlabel</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">netlbl_req_delattr</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_inet_csk_clone - Copy the connection information to the new socket</span>
<span class="cm"> * @sk: the new socket</span>
<span class="cm"> * @req: the connection&#39;s request_sock</span>
<span class="cm"> *</span>
<span class="cm"> * Transfer the connection&#39;s peer label to the newly created socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_inet_csk_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_smack</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">=</span> <span class="n">smack_from_secid</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">peer_secid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">smk_packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Key management security hooks</span>
<span class="cm"> *</span>
<span class="cm"> * Casey has not tested key support very heavily.</span>
<span class="cm"> * The permission check is most likely too restrictive.</span>
<span class="cm"> * If you care about keys please have a look.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_KEYS</span>

<span class="cm">/**</span>
<span class="cm"> * smack_key_alloc - Set the key security blob</span>
<span class="cm"> * @key: object</span>
<span class="cm"> * @cred: the credentials to use</span>
<span class="cm"> * @flags: unused</span>
<span class="cm"> *</span>
<span class="cm"> * No allocation required</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_key_free - Clear the key security blob</span>
<span class="cm"> * @key: the object</span>
<span class="cm"> *</span>
<span class="cm"> * Clear the blob pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_key_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * smack_key_permission - Smack access on a key</span>
<span class="cm"> * @key_ref: gets to the object</span>
<span class="cm"> * @cred: the credentials to use</span>
<span class="cm"> * @perm: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the task has read and write to the object,</span>
<span class="cm"> * an error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_key_permission</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smk_audit_info</span> <span class="n">ad</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tsp</span> <span class="o">=</span> <span class="n">smk_of_task</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">);</span>

	<span class="n">keyp</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the key hasn&#39;t been initialized give it access so that</span>
<span class="cm">	 * it may do so.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This should not occur</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">smk_ad_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ad</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">LSM_AUDIT_DATA_KEY</span><span class="p">);</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">key_struct</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">keyp</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="n">ad</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">key_struct</span><span class="p">.</span><span class="n">key_desc</span> <span class="o">=</span> <span class="n">keyp</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smk_access</span><span class="p">(</span><span class="n">tsp</span><span class="p">,</span> <span class="n">keyp</span><span class="o">-&gt;</span><span class="n">security</span><span class="p">,</span>
				 <span class="n">MAY_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Smack Audit hooks</span>
<span class="cm"> *</span>
<span class="cm"> * Audit requires a unique representation of each Smack specific</span>
<span class="cm"> * rule. This unique representation is used to distinguish the</span>
<span class="cm"> * object to be audited from remaining kernel objects and also</span>
<span class="cm"> * works as a glue between the audit hooks.</span>
<span class="cm"> *</span>
<span class="cm"> * Since repository entries are added but never deleted, we&#39;ll use</span>
<span class="cm"> * the smack_known label address related to the given audit rule as</span>
<span class="cm"> * the needed unique representation. This also better fits the smack</span>
<span class="cm"> * model where nearly everything is a label.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>

<span class="cm">/**</span>
<span class="cm"> * smack_audit_rule_init - Initialize a smack audit rule</span>
<span class="cm"> * @field: audit rule fields given from user-space (audit.h)</span>
<span class="cm"> * @op: required testing operator (=, !=, &gt;, &lt;, ...)</span>
<span class="cm"> * @rulestr: smack label to be audited</span>
<span class="cm"> * @vrule: pointer to save our own audit rule representation</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare to audit cases where (@field @op @rulestr) is true.</span>
<span class="cm"> * The label to be audited is created if necessay.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_audit_rule_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">vrule</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">!=</span> <span class="n">AUDIT_SUBJ_USER</span> <span class="o">&amp;&amp;</span> <span class="n">field</span> <span class="o">!=</span> <span class="n">AUDIT_OBJ_USER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_equal</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="n">smk_import</span><span class="p">(</span><span class="n">rulestr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_audit_rule_known - Distinguish Smack audit rules</span>
<span class="cm"> * @krule: rule of interest, in Audit kernel representation format</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to filter Smack rules from remaining Audit ones.</span>
<span class="cm"> * If it&#39;s proved that this rule belongs to us, the</span>
<span class="cm"> * audit_rule_match hook will be called to do the final judgement.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_audit_rule_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_SUBJ_USER</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_OBJ_USER</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_audit_rule_match - Audit given object ?</span>
<span class="cm"> * @secid: security id for identifying the object to test</span>
<span class="cm"> * @field: audit rule flags given from user-space</span>
<span class="cm"> * @op: required testing operator</span>
<span class="cm"> * @vrule: smack internal rule presentation</span>
<span class="cm"> * @actx: audit context associated with the check</span>
<span class="cm"> *</span>
<span class="cm"> * The core Audit hook. It&#39;s used to take the decision of</span>
<span class="cm"> * whether to audit or not to audit a given object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_audit_rule_match</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vrule</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smack</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rule</span> <span class="o">=</span> <span class="n">vrule</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rule</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log</span><span class="p">(</span><span class="n">actx</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">AUDIT_SELINUX_ERR</span><span class="p">,</span>
			  <span class="s">&quot;Smack: missing rule</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">!=</span> <span class="n">AUDIT_SUBJ_USER</span> <span class="o">&amp;&amp;</span> <span class="n">field</span> <span class="o">!=</span> <span class="n">AUDIT_OBJ_USER</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smack</span> <span class="o">=</span> <span class="n">smack_from_secid</span><span class="p">(</span><span class="n">secid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to do string comparisons. If a match occurs,</span>
<span class="cm">	 * both pointers will point to the same smack_known</span>
<span class="cm">	 * label.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_equal</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rule</span> <span class="o">==</span> <span class="n">smack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rule</span> <span class="o">!=</span> <span class="n">smack</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_audit_rule_free - free smack rule representation</span>
<span class="cm"> * @vrule: rule to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * No memory was allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_audit_rule_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* No-op */</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDIT */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * smack_secid_to_secctx - return the smack label for a secid</span>
<span class="cm"> * @secid: incoming integer</span>
<span class="cm"> * @secdata: destination</span>
<span class="cm"> * @seclen: how long it is</span>
<span class="cm"> *</span>
<span class="cm"> * Exists for networking code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_secid_to_secctx</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">smack_from_secid</span><span class="p">(</span><span class="n">secid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secdata</span><span class="p">)</span>
		<span class="o">*</span><span class="n">secdata</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">seclen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_secctx_to_secid - return the secid for a smack label</span>
<span class="cm"> * @secdata: smack label</span>
<span class="cm"> * @seclen: how long result is</span>
<span class="cm"> * @secid: outgoing integer</span>
<span class="cm"> *</span>
<span class="cm"> * Exists for audit and networking code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_secctx_to_secid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="n">smack_to_secid</span><span class="p">(</span><span class="n">secdata</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_release_secctx - don&#39;t do anything.</span>
<span class="cm"> * @secdata: unused</span>
<span class="cm"> * @seclen: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Exists to make sure nothing gets done, and properly</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smack_release_secctx</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_notifysecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smack_inode_setsecurity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">XATTR_SMACK_SUFFIX</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctxlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_setsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vfs_setxattr_noperm</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_SMACK</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctxlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smack_inode_getsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">smack_inode_getsecurity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">XATTR_SMACK_SUFFIX</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ctxlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">security_operations</span> <span class="n">smack_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>				<span class="s">&quot;smack&quot;</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ptrace_access_check</span> <span class="o">=</span>		<span class="n">smack_ptrace_access_check</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ptrace_traceme</span> <span class="o">=</span>		<span class="n">smack_ptrace_traceme</span><span class="p">,</span>
	<span class="p">.</span><span class="n">syslog</span> <span class="o">=</span> 			<span class="n">smack_syslog</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sb_alloc_security</span> <span class="o">=</span> 		<span class="n">smack_sb_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_free_security</span> <span class="o">=</span> 		<span class="n">smack_sb_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_copy_data</span> <span class="o">=</span> 		<span class="n">smack_sb_copy_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_kern_mount</span> <span class="o">=</span> 		<span class="n">smack_sb_kern_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_statfs</span> <span class="o">=</span> 			<span class="n">smack_sb_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_mount</span> <span class="o">=</span> 			<span class="n">smack_sb_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sb_umount</span> <span class="o">=</span> 			<span class="n">smack_sb_umount</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bprm_set_creds</span> <span class="o">=</span>		<span class="n">smack_bprm_set_creds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bprm_committing_creds</span> <span class="o">=</span>	<span class="n">smack_bprm_committing_creds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bprm_secureexec</span> <span class="o">=</span>		<span class="n">smack_bprm_secureexec</span><span class="p">,</span>

	<span class="p">.</span><span class="n">inode_alloc_security</span> <span class="o">=</span> 	<span class="n">smack_inode_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_free_security</span> <span class="o">=</span> 		<span class="n">smack_inode_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_init_security</span> <span class="o">=</span> 		<span class="n">smack_inode_init_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_link</span> <span class="o">=</span> 			<span class="n">smack_inode_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_unlink</span> <span class="o">=</span> 		<span class="n">smack_inode_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_rmdir</span> <span class="o">=</span> 			<span class="n">smack_inode_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_rename</span> <span class="o">=</span> 		<span class="n">smack_inode_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_permission</span> <span class="o">=</span> 		<span class="n">smack_inode_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setattr</span> <span class="o">=</span> 		<span class="n">smack_inode_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getattr</span> <span class="o">=</span> 		<span class="n">smack_inode_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setxattr</span> <span class="o">=</span> 		<span class="n">smack_inode_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_post_setxattr</span> <span class="o">=</span> 		<span class="n">smack_inode_post_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getxattr</span> <span class="o">=</span> 		<span class="n">smack_inode_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_removexattr</span> <span class="o">=</span> 		<span class="n">smack_inode_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecurity</span> <span class="o">=</span> 		<span class="n">smack_inode_getsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setsecurity</span> <span class="o">=</span> 		<span class="n">smack_inode_setsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_listsecurity</span> <span class="o">=</span> 		<span class="n">smack_inode_listsecurity</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecid</span> <span class="o">=</span>		<span class="n">smack_inode_getsecid</span><span class="p">,</span>

	<span class="p">.</span><span class="n">file_permission</span> <span class="o">=</span> 		<span class="n">smack_file_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_alloc_security</span> <span class="o">=</span> 		<span class="n">smack_file_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_free_security</span> <span class="o">=</span> 		<span class="n">smack_file_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_ioctl</span> <span class="o">=</span> 			<span class="n">smack_file_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_lock</span> <span class="o">=</span> 			<span class="n">smack_file_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_fcntl</span> <span class="o">=</span> 			<span class="n">smack_file_fcntl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap_file</span> <span class="o">=</span>			<span class="n">smack_mmap_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap_addr</span> <span class="o">=</span>			<span class="n">cap_mmap_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_set_fowner</span> <span class="o">=</span> 		<span class="n">smack_file_set_fowner</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_send_sigiotask</span> <span class="o">=</span> 		<span class="n">smack_file_send_sigiotask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">file_receive</span> <span class="o">=</span> 		<span class="n">smack_file_receive</span><span class="p">,</span>

	<span class="p">.</span><span class="n">file_open</span> <span class="o">=</span>			<span class="n">smack_file_open</span><span class="p">,</span>

	<span class="p">.</span><span class="n">cred_alloc_blank</span> <span class="o">=</span>		<span class="n">smack_cred_alloc_blank</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_free</span> <span class="o">=</span>			<span class="n">smack_cred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_prepare</span> <span class="o">=</span>			<span class="n">smack_cred_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cred_transfer</span> <span class="o">=</span>		<span class="n">smack_cred_transfer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_act_as</span> <span class="o">=</span>		<span class="n">smack_kernel_act_as</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_create_files_as</span> <span class="o">=</span>	<span class="n">smack_kernel_create_files_as</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setpgid</span> <span class="o">=</span> 		<span class="n">smack_task_setpgid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getpgid</span> <span class="o">=</span> 		<span class="n">smack_task_getpgid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getsid</span> <span class="o">=</span> 			<span class="n">smack_task_getsid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getsecid</span> <span class="o">=</span> 		<span class="n">smack_task_getsecid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setnice</span> <span class="o">=</span> 		<span class="n">smack_task_setnice</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setioprio</span> <span class="o">=</span> 		<span class="n">smack_task_setioprio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getioprio</span> <span class="o">=</span> 		<span class="n">smack_task_getioprio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_setscheduler</span> <span class="o">=</span> 		<span class="n">smack_task_setscheduler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_getscheduler</span> <span class="o">=</span> 		<span class="n">smack_task_getscheduler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_movememory</span> <span class="o">=</span> 		<span class="n">smack_task_movememory</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_kill</span> <span class="o">=</span> 			<span class="n">smack_task_kill</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_wait</span> <span class="o">=</span> 			<span class="n">smack_task_wait</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_to_inode</span> <span class="o">=</span> 		<span class="n">smack_task_to_inode</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ipc_permission</span> <span class="o">=</span> 		<span class="n">smack_ipc_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ipc_getsecid</span> <span class="o">=</span>			<span class="n">smack_ipc_getsecid</span><span class="p">,</span>

	<span class="p">.</span><span class="n">msg_msg_alloc_security</span> <span class="o">=</span> 	<span class="n">smack_msg_msg_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_msg_free_security</span> <span class="o">=</span> 	<span class="n">smack_msg_msg_free_security</span><span class="p">,</span>

	<span class="p">.</span><span class="n">msg_queue_alloc_security</span> <span class="o">=</span> 	<span class="n">smack_msg_queue_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_free_security</span> <span class="o">=</span> 	<span class="n">smack_msg_queue_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_associate</span> <span class="o">=</span> 		<span class="n">smack_msg_queue_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgctl</span> <span class="o">=</span> 		<span class="n">smack_msg_queue_msgctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgsnd</span> <span class="o">=</span> 		<span class="n">smack_msg_queue_msgsnd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">msg_queue_msgrcv</span> <span class="o">=</span> 		<span class="n">smack_msg_queue_msgrcv</span><span class="p">,</span>

	<span class="p">.</span><span class="n">shm_alloc_security</span> <span class="o">=</span> 		<span class="n">smack_shm_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_free_security</span> <span class="o">=</span> 		<span class="n">smack_shm_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_associate</span> <span class="o">=</span> 		<span class="n">smack_shm_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_shmctl</span> <span class="o">=</span> 			<span class="n">smack_shm_shmctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shm_shmat</span> <span class="o">=</span> 			<span class="n">smack_shm_shmat</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sem_alloc_security</span> <span class="o">=</span> 		<span class="n">smack_sem_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_free_security</span> <span class="o">=</span> 		<span class="n">smack_sem_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_associate</span> <span class="o">=</span> 		<span class="n">smack_sem_associate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_semctl</span> <span class="o">=</span> 			<span class="n">smack_sem_semctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sem_semop</span> <span class="o">=</span> 			<span class="n">smack_sem_semop</span><span class="p">,</span>

	<span class="p">.</span><span class="n">d_instantiate</span> <span class="o">=</span> 		<span class="n">smack_d_instantiate</span><span class="p">,</span>

	<span class="p">.</span><span class="n">getprocattr</span> <span class="o">=</span> 			<span class="n">smack_getprocattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setprocattr</span> <span class="o">=</span> 			<span class="n">smack_setprocattr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">unix_stream_connect</span> <span class="o">=</span> 		<span class="n">smack_unix_stream_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unix_may_send</span> <span class="o">=</span> 		<span class="n">smack_unix_may_send</span><span class="p">,</span>

	<span class="p">.</span><span class="n">socket_post_create</span> <span class="o">=</span> 		<span class="n">smack_socket_post_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_connect</span> <span class="o">=</span>		<span class="n">smack_socket_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_sendmsg</span> <span class="o">=</span>		<span class="n">smack_socket_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_sock_rcv_skb</span> <span class="o">=</span> 		<span class="n">smack_socket_sock_rcv_skb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getpeersec_stream</span> <span class="o">=</span>	<span class="n">smack_socket_getpeersec_stream</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socket_getpeersec_dgram</span> <span class="o">=</span>	<span class="n">smack_socket_getpeersec_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_alloc_security</span> <span class="o">=</span> 		<span class="n">smack_sk_alloc_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sk_free_security</span> <span class="o">=</span> 		<span class="n">smack_sk_free_security</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sock_graft</span> <span class="o">=</span> 			<span class="n">smack_sock_graft</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inet_conn_request</span> <span class="o">=</span> 		<span class="n">smack_inet_conn_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inet_csk_clone</span> <span class="o">=</span>		<span class="n">smack_inet_csk_clone</span><span class="p">,</span>

 <span class="cm">/* key management security hooks */</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="p">.</span><span class="n">key_alloc</span> <span class="o">=</span> 			<span class="n">smack_key_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_free</span> <span class="o">=</span> 			<span class="n">smack_key_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_permission</span> <span class="o">=</span> 		<span class="n">smack_key_permission</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>

 <span class="cm">/* Audit hooks */</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="p">.</span><span class="n">audit_rule_init</span> <span class="o">=</span>		<span class="n">smack_audit_rule_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_known</span> <span class="o">=</span>		<span class="n">smack_audit_rule_known</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_match</span> <span class="o">=</span>		<span class="n">smack_audit_rule_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">audit_rule_free</span> <span class="o">=</span>		<span class="n">smack_audit_rule_free</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDIT */</span><span class="cp"></span>

	<span class="p">.</span><span class="n">secid_to_secctx</span> <span class="o">=</span> 		<span class="n">smack_secid_to_secctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">secctx_to_secid</span> <span class="o">=</span> 		<span class="n">smack_secctx_to_secid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_secctx</span> <span class="o">=</span> 		<span class="n">smack_release_secctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_notifysecctx</span> <span class="o">=</span>		<span class="n">smack_inode_notifysecctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_setsecctx</span> <span class="o">=</span>		<span class="n">smack_inode_setsecctx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inode_getsecctx</span> <span class="o">=</span>		<span class="n">smack_inode_getsecctx</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">init_smack_known_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize rule list locks</span>
<span class="cm">	 */</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_huh</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_hat</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_web</span><span class="p">.</span><span class="n">smk_rules_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize rule lists</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_huh</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_hat</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_star</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_web</span><span class="p">.</span><span class="n">smk_rules</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create the known labels list</span>
<span class="cm">	 */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_huh</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_hat</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_star</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_floor</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_invalid</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_known_web</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smack_known_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smack_init - initialize the smack system</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">smack_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_smack</span> <span class="o">*</span><span class="n">tsp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">security_module_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tsp</span> <span class="o">=</span> <span class="n">new_task_smack</span><span class="p">(</span><span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">,</span>
				<span class="n">smack_known_floor</span><span class="p">.</span><span class="n">smk_known</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Smack:  Initializing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the security state for the initial task.</span>
<span class="cm">	 */</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">)</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="n">tsp</span><span class="p">;</span>

	<span class="cm">/* initialize the smack_known_list */</span>
	<span class="n">init_smack_known_list</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register with LSM</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_security</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smack_ops</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;smack: Unable to register with kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Smack requires early initialization in order to label</span>
<span class="cm"> * all processes and objects when they are created.</span>
<span class="cm"> */</span>
<span class="n">security_initcall</span><span class="p">(</span><span class="n">smack_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
