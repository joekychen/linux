<!DOCTYPE html>
<html><head><title>joekychen/linux » security › keys › request_key.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>request_key.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Request a key from userspace</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/security/keys-request-key.txt</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/keyctl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define key_negative_timeout	60	</span><span class="cm">/* default timeout on a negative key&#39;s existence */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * wait_on_bit() sleep function for uninterruptible waiting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">key_wait_bit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wait_on_bit() sleep function for interruptible waiting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">key_wait_bit_intr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ERESTARTSYS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * complete_request_key - Complete the construction of a key.</span>
<span class="cm"> * @cons: The key construction record.</span>
<span class="cm"> * @error: The success or failute of the construction.</span>
<span class="cm"> *</span>
<span class="cm"> * Complete the attempt to construct a key.  The key will be negated</span>
<span class="cm"> * if an error is indicated.  The authorisation key will be revoked</span>
<span class="cm"> * unconditionally.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">complete_request_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_construction</span> <span class="o">*</span><span class="n">cons</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;{%d,%d},%d&quot;</span><span class="p">,</span> <span class="n">cons</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key_negate_and_link</span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_negative_timeout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">key_revoke</span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span><span class="p">);</span>

	<span class="n">key_put</span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cons</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">complete_request_key</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise a usermode helper that is going to have a specific session</span>
<span class="cm"> * keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called in context of freshly forked kthread before kernel_execve(),</span>
<span class="cm"> * so we can simply install the desired session_keyring at this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">umh_keys_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">subprocess_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">install_session_keyring_to_cred</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">keyring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up a usermode helper with session keyring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">umh_keys_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">subprocess_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call a usermode helper with a specific session keyring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_usermodehelper_keys</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">session_keyring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">call_usermodehelper_fns</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span>
				       <span class="n">umh_keys_init</span><span class="p">,</span> <span class="n">umh_keys_cleanup</span><span class="p">,</span>
				       <span class="n">key_get</span><span class="p">(</span><span class="n">session_keyring</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request userspace finish the construction of a key</span>
<span class="cm"> * - execute &quot;/sbin/request-key &lt;op&gt; &lt;key&gt; &lt;uid&gt; &lt;gid&gt; &lt;keyring&gt; &lt;keyring&gt; &lt;keyring&gt;&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_sbin_request_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_construction</span> <span class="o">*</span><span class="n">cons</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="n">key_serial_t</span> <span class="n">prkey</span><span class="p">,</span> <span class="n">sskey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">cons</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">authkey</span> <span class="o">=</span> <span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span><span class="p">,</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
		<span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">uid_str</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">gid_str</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">key_str</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">keyring_str</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">desc</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;{%d},{%d},%s&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">authkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">install_user_keyrings</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>

	<span class="cm">/* allocate a new session keyring */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="s">&quot;_req.%u&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="n">cred</span> <span class="o">=</span> <span class="n">get_current_cred</span><span class="p">();</span>
	<span class="n">keyring</span> <span class="o">=</span> <span class="n">keyring_alloc</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span>
				<span class="n">KEY_ALLOC_QUOTA_OVERRUN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">put_cred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* attach the auth key to the session keyring */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_link</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">authkey</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_link</span><span class="p">;</span>

	<span class="cm">/* record the UID and GID */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">uid_str</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">gid_str</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span><span class="p">);</span>

	<span class="cm">/* we say which key is under construction */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">key_str</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* we specify the process&#39;s default keyrings */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">keyring_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span>
		<span class="n">cred</span><span class="o">-&gt;</span><span class="n">thread_keyring</span> <span class="o">?</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">thread_keyring</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">prkey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">process_keyring</span><span class="p">)</span>
		<span class="n">prkey</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">process_keyring</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">keyring_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">prkey</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span>
		<span class="n">session</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="p">;</span>
	<span class="n">sskey</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">keyring_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">sskey</span><span class="p">);</span>

	<span class="cm">/* set up a minimal environment */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HOME=/&quot;</span><span class="p">;</span>
	<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span><span class="p">;</span>
	<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* set up the argument list */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;/sbin/request-key&quot;</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_str</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uid_str</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">gid_str</span><span class="p">;</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">keyring_str</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">keyring_str</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">keyring_str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* do it */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_usermodehelper_keys</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">keyring</span><span class="p">,</span>
				       <span class="n">UMH_WAIT_PROC</span><span class="p">);</span>
	<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;usermode -&gt; 0x%x&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ret is the exit/wait code */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">key_validate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOKEY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* ignore any errors from userspace if the key was</span>
<span class="cm">			 * instantiated */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error_link:</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

<span class="nl">error_alloc:</span>
	<span class="n">complete_request_key</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call out to userspace for key construction.</span>
<span class="cm"> *</span>
<span class="cm"> * Program failure is ignored in favour of key status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">construct_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_construction</span> <span class="o">*</span><span class="n">cons</span><span class="p">;</span>
	<span class="n">request_key_actor_t</span> <span class="n">actor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">authkey</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,%p,%zu,%p&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">);</span>

	<span class="n">cons</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cons</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cons</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* allocate an authorisation key */</span>
	<span class="n">authkey</span> <span class="o">=</span> <span class="n">request_key_auth_new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span>
				       <span class="n">dest_keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cons</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
		<span class="n">authkey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cons</span><span class="o">-&gt;</span><span class="n">authkey</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
		<span class="n">cons</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

		<span class="cm">/* make the call */</span>
		<span class="n">actor</span> <span class="o">=</span> <span class="n">call_sbin_request_key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">request_key</span><span class="p">)</span>
			<span class="n">actor</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">request_key</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">actor</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="s">&quot;create&quot;</span><span class="p">,</span> <span class="n">aux</span><span class="p">);</span>

		<span class="cm">/* check that the actor called complete_request_key() prior to</span>
<span class="cm">		 * returning an error */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the appropriate destination keyring for the request.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring selected is returned with an extra reference upon it which the</span>
<span class="cm"> * caller must release.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">construct_get_dest_keyring</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">**</span><span class="n">_dest_keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_key_auth</span> <span class="o">*</span><span class="n">rka</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest_keyring</span> <span class="o">=</span> <span class="o">*</span><span class="n">_dest_keyring</span><span class="p">,</span> <span class="o">*</span><span class="n">authkey</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%p&quot;</span><span class="p">,</span> <span class="n">dest_keyring</span><span class="p">);</span>

	<span class="cm">/* find the appropriate keyring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the caller supplied one */</span>
		<span class="n">key_get</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* use a default keyring; falling through the cases until we</span>
<span class="cm">		 * find one that we actually have */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">jit_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_DEFAULT</span>:
		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_REQUESTOR_KEYRING</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">authkey</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">;</span>
				<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
				<span class="n">rka</span> <span class="o">=</span> <span class="n">authkey</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
					<span class="n">dest_keyring</span> <span class="o">=</span>
						<span class="n">key_get</span><span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">dest_keyring</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_THREAD_KEYRING</span>:
			<span class="n">dest_keyring</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">thread_keyring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_PROCESS_KEYRING</span>:
			<span class="n">dest_keyring</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">process_keyring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_SESSION_KEYRING</span>:
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">dest_keyring</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="p">));</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_USER_SESSION_KEYRING</span>:
			<span class="n">dest_keyring</span> <span class="o">=</span>
				<span class="n">key_get</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_USER_KEYRING</span>:
			<span class="n">dest_keyring</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">uid_keyring</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_GROUP_KEYRING</span>:
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">_dest_keyring</span> <span class="o">=</span> <span class="n">dest_keyring</span><span class="p">;</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [dk %d]&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new key in under-construction state and attempt to link it in to</span>
<span class="cm"> * the requested keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * May return a key that&#39;s already under construction instead if there was a</span>
<span class="cm"> * race between two thread calling request_key().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">construct_alloc_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">key</span> <span class="o">**</span><span class="n">_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%s,%s,,,&quot;</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>

	<span class="o">*</span><span class="n">_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span>
			<span class="n">KEY_POS_ALL</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">alloc_failed</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_begin</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">link_prealloc_failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* attach the key to the destination keyring under lock, but we do need</span>
<span class="cm">	 * to do another check just in case someone beat us to it whilst we</span>
<span class="cm">	 * waited for locks */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">search_process_keyrings</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">key_already_present</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
		<span class="n">__key_link</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span>
		<span class="n">__key_link_end</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = 0 [%d]&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the key is now present - we tell the caller that we found it by</span>
<span class="cm">	 * returning -EINPROGRESS  */</span>
<span class="nl">key_already_present:</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_check_live_key</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">__key_link</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
		<span class="n">__key_link_end</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">link_check_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINPROGRESS [%d]&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

<span class="nl">link_check_failed:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d [linkcheck]&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">link_prealloc_failed:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d [prelink]&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">alloc_failed:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %ld&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commence key construction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">construct_key_and_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">user</span> <span class="o">=</span> <span class="n">key_user_lookup</span><span class="p">(</span><span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">current_user_ns</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">construct_get_dest_keyring</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_keyring</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">construct_alloc_key</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">dest_keyring</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_user_put</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">construct_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span>
				    <span class="n">dest_keyring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;cons failed&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">construction_failed</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">couldnt_alloc_key</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_put</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = key %d&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>

<span class="nl">construction_failed:</span>
	<span class="n">key_negate_and_link</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key_negative_timeout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="nl">couldnt_alloc_key:</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * request_key_and_link - Request a key and cache it in a keyring.</span>
<span class="cm"> * @type: The type of key we want.</span>
<span class="cm"> * @description: The searchable description of the key.</span>
<span class="cm"> * @callout_info: The data to pass to the instantiation upcall (or NULL).</span>
<span class="cm"> * @callout_len: The length of callout_info.</span>
<span class="cm"> * @aux: Auxiliary data for the upcall.</span>
<span class="cm"> * @dest_keyring: Where to cache the key.</span>
<span class="cm"> * @flags: Flags to key_alloc().</span>
<span class="cm"> *</span>
<span class="cm"> * A key matching the specified criteria is searched for in the process&#39;s</span>
<span class="cm"> * keyrings and returned with its usage count incremented if found.  Otherwise,</span>
<span class="cm"> * if callout_info is not NULL, a key will be allocated and some service</span>
<span class="cm"> * (probably in userspace) will be asked to instantiate it.</span>
<span class="cm"> *</span>
<span class="cm"> * If successfully found or created, the key will be linked to the destination</span>
<span class="cm"> * keyring if one is provided.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED</span>
<span class="cm"> * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was</span>
<span class="cm"> * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT</span>
<span class="cm"> * if insufficient key quota was available to create a new key; or -ENOMEM if</span>
<span class="cm"> * insufficient memory was available.</span>
<span class="cm"> *</span>
<span class="cm"> * If the returned key was created, then it may still be under construction,</span>
<span class="cm"> * and wait_for_key_construction() should be used to wait for that to complete.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">request_key_and_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%s,%s,%p,%zu,%p,%p,%lx&quot;</span><span class="p">,</span>
	       <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span>
	       <span class="n">dest_keyring</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* search all the process keyrings for a key */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">search_process_keyrings</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dest_keyring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">construct_get_dest_keyring</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_keyring</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">key_link</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
			<span class="n">key_put</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
				<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="cm">/* the search failed, but the keyrings were searchable, so we</span>
<span class="cm">		 * should consult userspace if we can */</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">callout_info</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">key</span> <span class="o">=</span> <span class="n">construct_key_and_link</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span>
					     <span class="n">callout_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span> <span class="n">dest_keyring</span><span class="p">,</span>
					     <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %p&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_key_construction - Wait for construction of a key to complete</span>
<span class="cm"> * @key: The key being waited for.</span>
<span class="cm"> * @intr: Whether to wait interruptibly.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for a key to finish being constructed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY</span>
<span class="cm"> * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was</span>
<span class="cm"> * revoked or expired.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wait_for_key_construction</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">bool</span> <span class="n">intr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">,</span>
			  <span class="n">intr</span> <span class="o">?</span> <span class="n">key_wait_bit_intr</span> <span class="o">:</span> <span class="n">key_wait_bit</span><span class="p">,</span>
			  <span class="n">intr</span> <span class="o">?</span> <span class="n">TASK_INTERRUPTIBLE</span> <span class="o">:</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">reject_error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">key_validate</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_key_construction</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * request_key - Request a key and wait for construction</span>
<span class="cm"> * @type: Type of key.</span>
<span class="cm"> * @description: The searchable description of the key.</span>
<span class="cm"> * @callout_info: The data to pass to the instantiation upcall (or NULL).</span>
<span class="cm"> *</span>
<span class="cm"> * As for request_key_and_link() except that it does not add the returned key</span>
<span class="cm"> * to a keyring if found, new keys are always allocated in the user&#39;s quota,</span>
<span class="cm"> * the callout_info must be a NUL-terminated string and no auxiliary data can</span>
<span class="cm"> * be passed.</span>
<span class="cm"> *</span>
<span class="cm"> * Furthermore, it then works as wait_for_key_construction() to wait for the</span>
<span class="cm"> * completion of keys undergoing construction with a non-interruptible wait.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">request_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">callout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">callout_info</span><span class="p">)</span>
		<span class="n">callout_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">callout_info</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">request_key_and_link</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span>
				   <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_key_construction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">request_key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * request_key_with_auxdata - Request a key with auxiliary data for the upcaller</span>
<span class="cm"> * @type: The type of key we want.</span>
<span class="cm"> * @description: The searchable description of the key.</span>
<span class="cm"> * @callout_info: The data to pass to the instantiation upcall (or NULL).</span>
<span class="cm"> * @callout_len: The length of callout_info.</span>
<span class="cm"> * @aux: Auxiliary data for the upcall.</span>
<span class="cm"> *</span>
<span class="cm"> * As for request_key_and_link() except that it does not add the returned key</span>
<span class="cm"> * to a keyring if found and new keys are always allocated in the user&#39;s quota.</span>
<span class="cm"> *</span>
<span class="cm"> * Furthermore, it then works as wait_for_key_construction() to wait for the</span>
<span class="cm"> * completion of keys undergoing construction with a non-interruptible wait.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">request_key_with_auxdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">request_key_and_link</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span> <span class="n">callout_len</span><span class="p">,</span>
				   <span class="n">aux</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_key_construction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">request_key_with_auxdata</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * request_key_async - Request a key (allow async construction)</span>
<span class="cm"> * @type: Type of key.</span>
<span class="cm"> * @description: The searchable description of the key.</span>
<span class="cm"> * @callout_info: The data to pass to the instantiation upcall (or NULL).</span>
<span class="cm"> * @callout_len: The length of callout_info.</span>
<span class="cm"> *</span>
<span class="cm"> * As for request_key_and_link() except that it does not add the returned key</span>
<span class="cm"> * to a keyring if found, new keys are always allocated in the user&#39;s quota and</span>
<span class="cm"> * no auxiliary data can be passed.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should call wait_for_key_construction() to wait for the</span>
<span class="cm"> * completion of the returned key if it is still undergoing construction.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">request_key_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_key_and_link</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span>
				    <span class="n">callout_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">request_key_async</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * request a key with auxiliary data for the upcaller (allow async construction)</span>
<span class="cm"> * @type: Type of key.</span>
<span class="cm"> * @description: The searchable description of the key.</span>
<span class="cm"> * @callout_info: The data to pass to the instantiation upcall (or NULL).</span>
<span class="cm"> * @callout_len: The length of callout_info.</span>
<span class="cm"> * @aux: Auxiliary data for the upcall.</span>
<span class="cm"> *</span>
<span class="cm"> * As for request_key_and_link() except that it does not add the returned key</span>
<span class="cm"> * to a keyring if found and new keys are always allocated in the user&#39;s quota.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should call wait_for_key_construction() to wait for the</span>
<span class="cm"> * completion of the returned key if it is still undergoing construction.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">request_key_async_with_auxdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">,</span>
					   <span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_key_and_link</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span>
				    <span class="n">callout_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">request_key_async_with_auxdata</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
