<!DOCTYPE html>
<html><head><title>joekychen/linux » security › keys › keyring.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>keyring.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Keyring handling</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;keys/keyring-type.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define rcu_dereference_locked_keyring(keyring)				\</span>
<span class="cp">	(rcu_dereference_protected(					\</span>
<span class="cp">		(keyring)-&gt;payload.subscriptions,			\</span>
<span class="cp">		rwsem_is_locked((struct rw_semaphore *)&amp;(keyring)-&gt;sem)))</span>

<span class="cp">#define rcu_deref_link_locked(klist, index, keyring)			\</span>
<span class="cp">	(rcu_dereference_protected(					\</span>
<span class="cp">		(klist)-&gt;keys[index],					\</span>
<span class="cp">		rwsem_is_locked((struct rw_semaphore *)&amp;(keyring)-&gt;sem)))</span>

<span class="cp">#define MAX_KEYRING_LINKS						\</span>
<span class="cp">	min_t(size_t, USHRT_MAX - 1,					\</span>
<span class="cp">	      ((PAGE_SIZE - sizeof(struct keyring_list)) / sizeof(struct key *)))</span>

<span class="cp">#define KEY_LINK_FIXQUOTA 1UL</span>

<span class="cm">/*</span>
<span class="cm"> * When plumbing the depths of the key tree, this sets a hard limit</span>
<span class="cm"> * set on how deep we&#39;re willing to go.</span>
<span class="cm"> */</span>
<span class="cp">#define KEYRING_SEARCH_MAX_DEPTH 6</span>

<span class="cm">/*</span>
<span class="cm"> * We keep all named keyrings in a hash to speed looking them up.</span>
<span class="cm"> */</span>
<span class="cp">#define KEYRING_NAME_HASH_SIZE	(1 &lt;&lt; 5)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span>	<span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">KEYRING_NAME_HASH_SIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">keyring_name_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">keyring_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span> <span class="n">desc</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bucket</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bucket</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KEYRING_NAME_HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The keyring key type definition.  Keyrings are simply keys of this type and</span>
<span class="cm"> * can be treated as ordinary keys in addition to having their own special</span>
<span class="cm"> * operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">keyring_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">keyring_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">criterion</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">keyring_revoke</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">keyring_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">keyring_describe</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">keyring_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">key_type</span> <span class="n">key_type_keyring</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;keyring&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">def_datalen</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">keyring_list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">instantiate</span>	<span class="o">=</span> <span class="n">keyring_instantiate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">keyring_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revoke</span>		<span class="o">=</span> <span class="n">keyring_revoke</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span> <span class="n">keyring_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">describe</span>	<span class="o">=</span> <span class="n">keyring_describe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">keyring_read</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_type_keyring</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Semaphore to serialise link/link calls to prevent two link calls in parallel</span>
<span class="cm"> * introducing a cycle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">keyring_serialise_link_sem</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Publish the name of a keyring so that it can be found by name (if it has</span>
<span class="cm"> * one).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_publish_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bucket</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">=</span> <span class="n">keyring_hash</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>

		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">next</span><span class="p">)</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">]);</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">link</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">]);</span>

		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise a keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EINVAL if given any data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">keyring_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make the keyring available by name if it has one */</span>
		<span class="n">keyring_publish_name</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Match keyrings on their name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">keyring_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">description</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span> <span class="o">&amp;&amp;</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up a keyring when it is destroyed.  Unpublish its name if it had one</span>
<span class="cm"> * and dispose of its data.</span>
<span class="cm"> *</span>
<span class="cm"> * The garbage collector detects the final key_put(), removes the keyring from</span>
<span class="cm"> * the serial number tree and then does RCU synchronisation before coming here,</span>
<span class="cm"> * so we shouldn&#39;t need to worry about code poking around here with the RCU</span>
<span class="cm"> * readlock held by this time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">link</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">link</span><span class="p">))</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">link</span><span class="p">);</span>

		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span><span class="o">--</span><span class="p">)</span>
			<span class="n">key_put</span><span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span><span class="p">]));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">klist</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Describe a keyring for /proc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_describe</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;[anon]&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key_is_instantiated</span><span class="p">(</span><span class="n">keyring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;: %u/%u&quot;</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;: empty&quot;</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a list of key IDs from the keyring&#39;s contents in binary form</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring&#39;s semaphore is read-locked by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">keyring_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* calculate how much data we could return */</span>
		<span class="n">qty</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key_serial_t</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;&amp;</span> <span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="n">qty</span><span class="p">)</span>
				<span class="n">buflen</span> <span class="o">=</span> <span class="n">qty</span><span class="p">;</span>

			<span class="cm">/* copy the IDs of the subscribed keys into the</span>
<span class="cm">			 * buffer */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_deref_link_locked</span><span class="p">(</span><span class="n">klist</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span>
							    <span class="n">keyring</span><span class="p">);</span>

				<span class="n">tmp</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key_serial_t</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span>
					<span class="n">tmp</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span>
						 <span class="n">tmp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

				<span class="n">buflen</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">buffer</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">qty</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a keyring and link into the destination keyring.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">keyring_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">keyring</span> <span class="o">=</span> <span class="n">key_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span>
			    <span class="n">uid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">KEY_POS_ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KEY_POS_SETATTR</span><span class="p">)</span> <span class="o">|</span> <span class="n">KEY_USR_ALL</span><span class="p">,</span>
			    <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">key_instantiate_and_link</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key_put</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
			<span class="n">keyring</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">keyring</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * keyring_search_aux - Search a keyring tree for a key matching some criteria</span>
<span class="cm"> * @keyring_ref: A pointer to the keyring with possession indicator.</span>
<span class="cm"> * @cred: The credentials to use for permissions checks.</span>
<span class="cm"> * @type: The type of key to search for.</span>
<span class="cm"> * @description: Parameter for @match.</span>
<span class="cm"> * @match: Function to rule on whether or not a key is the one required.</span>
<span class="cm"> * @no_state_check: Don&#39;t check if a matching key is bad</span>
<span class="cm"> *</span>
<span class="cm"> * Search the supplied keyring tree for a key that matches the criteria given.</span>
<span class="cm"> * The root keyring and any linked keyrings must grant Search permission to the</span>
<span class="cm"> * caller to be searchable and keys can only be found if they too grant Search</span>
<span class="cm"> * to the caller. The possession flag on the root keyring pointer controls use</span>
<span class="cm"> * of the possessor bits in permissions checking of the entire tree.  In</span>
<span class="cm"> * addition, the LSM gets to forbid keyring searches and key matches.</span>
<span class="cm"> *</span>
<span class="cm"> * The search is performed as a breadth-then-depth search up to the prescribed</span>
<span class="cm"> * limit (KEYRING_SEARCH_MAX_DEPTH).</span>
<span class="cm"> *</span>
<span class="cm"> * Keys are matched to the type provided and are then filtered by the match</span>
<span class="cm"> * function, which is given the description to use in any way it sees fit.  The</span>
<span class="cm"> * match function may use any attributes of a key that it wishes to to</span>
<span class="cm"> * determine the match.  Normally the match function from the key type would be</span>
<span class="cm"> * used.</span>
<span class="cm"> *</span>
<span class="cm"> * RCU is used to prevent the keyring key lists from disappearing without the</span>
<span class="cm"> * need to take lots of locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the found key and increments the key usage count if</span>
<span class="cm"> * successful; -EAGAIN if no matching keys were found, or if expired or revoked</span>
<span class="cm"> * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the</span>
<span class="cm"> * specified keyring wasn&#39;t a keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a successful return, the possession attribute from</span>
<span class="cm"> * @keyring_ref is propagated to the returned key reference.</span>
<span class="cm"> */</span>
<span class="n">key_ref_t</span> <span class="nf">keyring_search_aux</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			     <span class="n">key_match_func_t</span> <span class="n">match</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">no_state_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Need a separate keylist pointer for RCU purposes */</span>
		<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">keylist</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">kix</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stack</span><span class="p">[</span><span class="n">KEYRING_SEARCH_MAX_DEPTH</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">keylist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">possessed</span><span class="p">,</span> <span class="n">kflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sp</span><span class="p">,</span> <span class="n">nkeys</span><span class="p">,</span> <span class="n">kix</span><span class="p">;</span>

	<span class="n">keyring</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
	<span class="n">possessed</span> <span class="o">=</span> <span class="n">is_key_possessed</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="cm">/* top keyring must have search permission to begin the search */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">key_task_permission</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOTDIR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* firstly we should check to see if this top-level keyring is what we</span>
<span class="cm">	 * are looking for */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="n">kflags</span> <span class="o">=</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">match</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">description</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">keyring</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">no_state_check</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="cm">/* check it isn&#39;t negative and hasn&#39;t expired or been</span>
<span class="cm">		 * revoked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_REVOKED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">&amp;&amp;</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">reject_error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_NEGATIVE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* otherwise, the top keyring must not be revoked, expired, or</span>
<span class="cm">	 * negatively instantiated if we are to search it */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_INVALIDATED</span><span class="p">)</span> <span class="o">|</span>
		      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_REVOKED</span><span class="p">)</span> <span class="o">|</span>
		      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_NEGATIVE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">&amp;&amp;</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;=</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">expiry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>

	<span class="cm">/* start processing a new keyring */</span>
<span class="nl">descend:</span>
	<span class="n">kflags</span> <span class="o">=</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_INVALIDATED</span><span class="p">)</span> <span class="o">|</span>
		      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_REVOKED</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">not_this_keyring</span><span class="p">;</span>

	<span class="n">keylist</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keylist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_this_keyring</span><span class="p">;</span>

	<span class="cm">/* iterate through the keys in this keyring first */</span>
	<span class="n">nkeys</span> <span class="o">=</span> <span class="n">keylist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">kix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kix</span> <span class="o">&lt;</span> <span class="n">nkeys</span><span class="p">;</span> <span class="n">kix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keylist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">kix</span><span class="p">]);</span>
		<span class="n">kflags</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* ignore keys not of this type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* skip invalidated, revoked and expired keys */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_state_check</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_INVALIDATED</span><span class="p">)</span> <span class="o">|</span>
				      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_REVOKED</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">&amp;&amp;</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* keys that don&#39;t match */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">description</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* key must have search permissions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key_task_permission</span><span class="p">(</span><span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possessed</span><span class="p">),</span>
					<span class="n">cred</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">no_state_check</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="cm">/* we set a different error code if we pass a negative key */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_NEGATIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">reject_error</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* search through the keyrings nested in this one */</span>
	<span class="n">kix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">ascend:</span>
	<span class="n">nkeys</span> <span class="o">=</span> <span class="n">keylist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">kix</span> <span class="o">&lt;</span> <span class="n">nkeys</span><span class="p">;</span> <span class="n">kix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keylist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">kix</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* recursively search nested keyrings</span>
<span class="cm">		 * - only search keyrings for which we have search permission</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">KEYRING_SEARCH_MAX_DEPTH</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key_task_permission</span><span class="p">(</span><span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possessed</span><span class="p">),</span>
					<span class="n">cred</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* stack the current position */</span>
		<span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keyring</span> <span class="o">=</span> <span class="n">keyring</span><span class="p">;</span>
		<span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keylist</span> <span class="o">=</span> <span class="n">keylist</span><span class="p">;</span>
		<span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">kix</span> <span class="o">=</span> <span class="n">kix</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* begin again with the new keyring */</span>
		<span class="n">keyring</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">descend</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the keyring we&#39;re looking at was disqualified or didn&#39;t contain a</span>
<span class="cm">	 * matching key */</span>
<span class="nl">not_this_keyring:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* resume the processing of a keyring higher up in the tree */</span>
		<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
		<span class="n">keyring</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keyring</span><span class="p">;</span>
		<span class="n">keylist</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keylist</span><span class="p">;</span>
		<span class="n">kix</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">kix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">ascend</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>

	<span class="cm">/* we found a viable match */</span>
<span class="nl">found:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">keyring</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stack</span><span class="p">[</span><span class="o">--</span><span class="n">sp</span><span class="p">].</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possessed</span><span class="p">);</span>
<span class="nl">error_2:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">key_ref</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * keyring_search - Search the supplied keyring tree for a matching key</span>
<span class="cm"> * @keyring: The root of the keyring tree to be searched.</span>
<span class="cm"> * @type: The type of keyring we want to find.</span>
<span class="cm"> * @description: The name of the keyring we want to find.</span>
<span class="cm"> *</span>
<span class="cm"> * As keyring_search_aux() above, but using the current task&#39;s credentials and</span>
<span class="cm"> * type&#39;s default matching function.</span>
<span class="cm"> */</span>
<span class="n">key_ref_t</span> <span class="nf">keyring_search</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">keyring</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">keyring_search_aux</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">,</span>
				  <span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">keyring_search</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Search the given keyring only (no recursion).</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must guarantee that the keyring is a keyring and that the</span>
<span class="cm"> * permission is granted to search the keyring as no check is made here.</span>
<span class="cm"> *</span>
<span class="cm"> * RCU is used to make it unnecessary to lock the keyring key list here.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the found key with usage count incremented if</span>
<span class="cm"> * successful and returns -ENOKEY if not found.  Revoked keys and keys not</span>
<span class="cm"> * providing the requested permission are skipped over.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the possession indicator is propagated from the keyring ref</span>
<span class="cm"> * to the returned key reference.</span>
<span class="cm"> */</span>
<span class="n">key_ref_t</span> <span class="nf">__keyring_search_one</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			       <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">possessed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nkeys</span><span class="p">,</span> <span class="n">loop</span><span class="p">;</span>

	<span class="n">keyring</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
	<span class="n">possessed</span> <span class="o">=</span> <span class="n">is_key_possessed</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nkeys</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">nkeys</span> <span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ktype</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">||</span>
			     <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">description</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key_permission</span><span class="p">(</span><span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possessed</span><span class="p">),</span>
					   <span class="n">perm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_INVALIDATED</span><span class="p">)</span> <span class="o">|</span>
					    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_REVOKED</span><span class="p">)))</span>
			    <span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>

<span class="nl">found:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="n">keyring</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span>
		<span class="n">current_kernel_time</span><span class="p">().</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possessed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a keyring with the specified name.</span>
<span class="cm"> *</span>
<span class="cm"> * All named keyrings in the current user namespace are searched, provided they</span>
<span class="cm"> * grant Search permission directly to the caller (unless this check is</span>
<span class="cm"> * skipped).  Keyrings whose usage points have reached zero or who have been</span>
<span class="cm"> * revoked are skipped.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the keyring with the keyring&#39;s refcount having being</span>
<span class="cm"> * incremented on success.  -ENOKEY is returned if a key could not be found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">find_keyring_by_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">bool</span> <span class="n">skip_perm_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bucket</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">keyring_hash</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* search this hash bucket for a keyring with a matching name</span>
<span class="cm">		 * that&#39;s readable and that hasn&#39;t been revoked */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">keyring_name_hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">],</span>
				    <span class="n">type_data</span><span class="p">.</span><span class="n">link</span>
				    <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">!=</span> <span class="n">current_user_ns</span><span class="p">())</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_perm_check</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key_permission</span><span class="p">(</span><span class="n">make_key_ref</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					   <span class="n">KEY_SEARCH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* we&#39;ve got a match but we might end up racing with</span>
<span class="cm">			 * key_cleanup() if the keyring is currently &#39;dead&#39;</span>
<span class="cm">			 * (ie. it has a zero usage count) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">keyring</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">().</span><span class="n">tv_sec</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">keyring</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_name_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">keyring</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if a cycle will will be created by inserting acyclic tree B in acyclic</span>
<span class="cm"> * tree A at the topmost level (ie: as a direct child of A).</span>
<span class="cm"> *</span>
<span class="cm"> * Since we are adding B to A at the top level, checking for cycles should just</span>
<span class="cm"> * be a matter of seeing if node A is somewhere in tree B.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">keyring_detect_cycle</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">B</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">keylist</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">kix</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stack</span><span class="p">[</span><span class="n">KEYRING_SEARCH_MAX_DEPTH</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">keylist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">subtree</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sp</span><span class="p">,</span> <span class="n">nkeys</span><span class="p">,</span> <span class="n">kix</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cycle_detected</span><span class="p">;</span>

	<span class="n">subtree</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* start processing a new keyring */</span>
<span class="nl">descend:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subtree</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">not_this_keyring</span><span class="p">;</span>

	<span class="n">keylist</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">subtree</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keylist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_this_keyring</span><span class="p">;</span>
	<span class="n">kix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">ascend:</span>
	<span class="cm">/* iterate through the remaining keys in this keyring */</span>
	<span class="n">nkeys</span> <span class="o">=</span> <span class="n">keylist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">kix</span> <span class="o">&lt;</span> <span class="n">nkeys</span><span class="p">;</span> <span class="n">kix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">keylist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">kix</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cycle_detected</span><span class="p">;</span>

		<span class="cm">/* recursively check nested keyrings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">KEYRING_SEARCH_MAX_DEPTH</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">too_deep</span><span class="p">;</span>

			<span class="cm">/* stack the current position */</span>
			<span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keylist</span> <span class="o">=</span> <span class="n">keylist</span><span class="p">;</span>
			<span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">kix</span> <span class="o">=</span> <span class="n">kix</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* begin again with the new keyring */</span>
			<span class="n">subtree</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">descend</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* the keyring we&#39;re looking at was disqualified or didn&#39;t contain a</span>
<span class="cm">	 * matching key */</span>
<span class="nl">not_this_keyring:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* resume the checking of a keyring higher up in the tree */</span>
		<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
		<span class="n">keylist</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">keylist</span><span class="p">;</span>
		<span class="n">kix</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">kix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">ascend</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no cycles detected */</span>

<span class="nl">error:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">too_deep:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">cycle_detected:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dispose of a keyring list after the RCU grace period, freeing the unlinked</span>
<span class="cm"> * key</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_unlink_rcu_disposal</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">keyring_list</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">!=</span> <span class="n">USHRT_MAX</span><span class="p">)</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">]));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">klist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Preallocate memory so that a key can be linked into to a keyring.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__key_link_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">_prealloc</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">,</span> <span class="o">*</span><span class="n">nklist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">lowest_lru</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">,</span> <span class="n">lru</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,%s,%s,&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">keyring</span><span class="p">),</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EKEYREVOKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_krsem</span><span class="p">;</span>

	<span class="cm">/* serialise link/link calls to prevent parallel calls causing a cycle</span>
<span class="cm">	 * when linking two keyring in opposite orders */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_serialise_link_sem</span><span class="p">);</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="cm">/* see if there&#39;s a matching key we can displace */</span>
	<span class="n">lru</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span> <span class="o">&amp;&amp;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lowest_lru</span> <span class="o">=</span> <span class="n">TIME_T_MAX</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">rcu_deref_link_locked</span><span class="p">(</span><span class="n">klist</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span>
								<span class="n">keyring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Found a match - we&#39;ll replace the link with</span>
<span class="cm">				 * one to the new key.  We record the slot</span>
<span class="cm">				 * position.</span>
<span class="cm">				 */</span>
				<span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">loop</span><span class="p">;</span>
				<span class="n">prealloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">&lt;</span> <span class="n">lowest_lru</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lowest_lru</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">last_used_at</span><span class="p">;</span>
				<span class="n">lru</span> <span class="o">=</span> <span class="n">loop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the keyring is full then do an LRU discard */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span> <span class="o">&amp;&amp;</span>
	    <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">==</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span> <span class="o">&amp;&amp;</span>
	    <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span> <span class="o">&gt;=</span> <span class="n">MAX_KEYRING_LINKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;LRU discard %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">lru</span><span class="p">;</span>
		<span class="n">prealloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check that we aren&#39;t going to overrun the user&#39;s quota */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
				  <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">+</span> <span class="n">KEYQUOTA_LINK_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_sem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span> <span class="o">&amp;&amp;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">&lt;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there&#39;s sufficient slack space to append directly */</span>
		<span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
		<span class="n">prealloc</span> <span class="o">=</span> <span class="n">KEY_LINK_FIXQUOTA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* grow the key list */</span>
		<span class="n">max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">+=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">MAX_KEYRING_LINKS</span><span class="p">)</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">MAX_KEYRING_LINKS</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">max</span> <span class="o">&lt;=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">klist</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">max</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">nklist</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nklist</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_quota</span><span class="p">;</span>

		<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">maxkeys</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">);</span>
			<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span>
			<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">USHRT_MAX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* add the key into the new space */</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">prealloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">nklist</span> <span class="o">|</span> <span class="n">KEY_LINK_FIXQUOTA</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="o">*</span><span class="n">_prealloc</span> <span class="o">=</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = 0&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_quota:</span>
	<span class="cm">/* undo the quota changes */</span>
	<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
			    <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">-</span> <span class="n">KEYQUOTA_LINK_BYTES</span><span class="p">);</span>
<span class="nl">error_sem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_serialise_link_sem</span><span class="p">);</span>
<span class="nl">error_krsem:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check already instantiated keys aren&#39;t going to be a problem.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have called __key_link_begin(). Don&#39;t need to call this for</span>
<span class="cm"> * keys that were created since __key_link_begin() was called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__key_link_check_live_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="cm">/* check that we aren&#39;t going to create a cycle by linking one</span>
<span class="cm">		 * keyring to another */</span>
		<span class="k">return</span> <span class="n">keyring_detect_cycle</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link a key into to a keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with __key_link_begin() having being called.  Discards any</span>
<span class="cm"> * already extant link to matching key if there is one, so that each keyring</span>
<span class="cm"> * holds at most one link to any given key of a particular type+description</span>
<span class="cm"> * combination.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__key_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">_prealloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">,</span> <span class="o">*</span><span class="n">nklist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">discard</span><span class="p">;</span>

	<span class="n">nklist</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">_prealloc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KEY_LINK_FIXQUOTA</span><span class="p">);</span>
	<span class="o">*</span><span class="n">_prealloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,%d,%p&quot;</span><span class="p">,</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">nklist</span><span class="p">);</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="n">keyring</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">last_used_at</span> <span class="o">=</span>
		<span class="n">current_kernel_time</span><span class="p">().</span><span class="n">tv_sec</span><span class="p">;</span>

	<span class="cm">/* there&#39;s a matching key we can displace or an empty slot in a newly</span>
<span class="cm">	 * allocated list we can fill */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nklist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;reissue %hu/%hu/%hu&quot;</span><span class="p">,</span>
		       <span class="n">nklist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">,</span> <span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="n">nklist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>

		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">],</span> <span class="n">key</span><span class="p">);</span>

		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span> <span class="n">nklist</span><span class="p">);</span>

		<span class="cm">/* dispose of the old keyring list and, if there was one, the</span>
<span class="cm">		 * displaced key */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;dispose %hu/%hu/%hu&quot;</span><span class="p">,</span>
			       <span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>
			<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">keyring_unlink_rcu_disposal</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">&lt;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;replace %hu/%hu/%hu&quot;</span><span class="p">,</span>
		       <span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>

		<span class="n">discard</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span>
			<span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">],</span>
			<span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">));</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">],</span> <span class="n">key</span><span class="p">);</span>
		<span class="cm">/* The garbage collector will take care of RCU</span>
<span class="cm">		 * synchronisation */</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">discard</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* there&#39;s sufficient slack space to append directly */</span>
		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;append %hu/%hu/%hu&quot;</span><span class="p">,</span>
		       <span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">);</span>

		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span><span class="p">],</span> <span class="n">key</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finish linking a key into to a keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with __key_link_begin() having being called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__key_link_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,%s,%lx&quot;</span><span class="p">,</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring_serialise_link_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prealloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prealloc</span> <span class="o">&amp;</span> <span class="n">KEY_LINK_FIXQUOTA</span><span class="p">)</span>
			<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
					    <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">-</span>
					    <span class="n">KEYQUOTA_LINK_BYTES</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">((</span><span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="p">)(</span><span class="n">prealloc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KEY_LINK_FIXQUOTA</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * key_link - Link a key to a keyring</span>
<span class="cm"> * @keyring: The keyring to make the link in.</span>
<span class="cm"> * @key: The key to link to.</span>
<span class="cm"> *</span>
<span class="cm"> * Make a link in a keyring to a key, such that the keyring holds a reference</span>
<span class="cm"> * on that key and the key can potentially be found by searching that keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will write-lock the keyring&#39;s semaphore and will consume some</span>
<span class="cm"> * of the user&#39;s key data quota to hold the link.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, -ENOTDIR if the keyring isn&#39;t a keyring,</span>
<span class="cm"> * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is</span>
<span class="cm"> * full, -EDQUOT if there is insufficient key data quota remaining to add</span>
<span class="cm"> * another link or -ENOMEM if there&#39;s insufficient memory.</span>
<span class="cm"> *</span>
<span class="cm"> * It is assumed that the caller has checked that it is permitted for a link to</span>
<span class="cm"> * be made (the keyring should have Write permission and the key Link</span>
<span class="cm"> * permission).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_begin</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_check_live_key</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">__key_link</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
		<span class="n">__key_link_end</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_link</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_unlink - Unlink the first link to a key from a keyring.</span>
<span class="cm"> * @keyring: The keyring to remove the link from.</span>
<span class="cm"> * @key: The key the link is to.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a link from a keyring to a key.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will write-lock the keyring&#39;s semaphore.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, -ENOTDIR if the keyring isn&#39;t a keyring, -ENOENT if</span>
<span class="cm"> * the key isn&#39;t linked to by the keyring or -ENOMEM if there&#39;s insufficient</span>
<span class="cm"> * memory.</span>
<span class="cm"> *</span>
<span class="cm"> * It is assumed that the caller has checked that it is permitted for a link to</span>
<span class="cm"> * be removed (the keyring should have Write permission; no permissions are</span>
<span class="cm"> * required on the key).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">,</span> <span class="o">*</span><span class="n">nklist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* search the keyring for the key */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span><span class="p">])</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">key_is_present</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">key_is_present:</span>
	<span class="cm">/* we need to copy the key list for RCU purposes */</span>
	<span class="n">nklist</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">klist</span><span class="p">)</span> <span class="o">+</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">,</span>
			 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nklist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">maxkeys</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">maxkeys</span><span class="p">;</span>
	<span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="n">loop</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&lt;</span> <span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span><span class="p">],</span>
		       <span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
		       <span class="p">(</span><span class="n">nklist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="n">loop</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">));</span>

	<span class="cm">/* adjust the user&#39;s quota */</span>
	<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
			    <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">-</span> <span class="n">KEYQUOTA_LINK_BYTES</span><span class="p">);</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span> <span class="n">nklist</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="cm">/* schedule for later cleanup */</span>
	<span class="n">klist</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="n">loop</span><span class="p">;</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">keyring_unlink_rcu_disposal</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_unlink</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dispose of a keyring list after the RCU grace period, releasing the keys it</span>
<span class="cm"> * links to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_clear_rcu_disposal</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">keyring_list</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span><span class="o">--</span><span class="p">)</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">loop</span><span class="p">]));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">klist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * keyring_clear - Clear a keyring</span>
<span class="cm"> * @keyring: The keyring to clear.</span>
<span class="cm"> *</span>
<span class="cm"> * Clear the contents of the specified keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful or -ENOTDIR if the keyring isn&#39;t a keyring.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">keyring_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* detach the pointer block with the locks held */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

		<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* adjust the quota */</span>
			<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">keyring_list</span><span class="p">));</span>

			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

		<span class="cm">/* free the keys after the locks have been dropped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span>
			<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">keyring_clear_rcu_disposal</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">keyring_clear</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dispose of the links from a revoked keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called with the key sem write-locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">keyring_revoke</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">;</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="cm">/* adjust the quota */</span>
	<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">klist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">keyring_clear_rcu_disposal</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Collect garbage from the contents of a keyring, replacing the old list with</span>
<span class="cm"> * a new one with the pointers all shuffled down.</span>
<span class="cm"> *</span>
<span class="cm"> * Dead keys are classed as oned that are flagged as being dead or are revoked,</span>
<span class="cm"> * expired or negative keys that were revoked or expired before the specified</span>
<span class="cm"> * limit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">keyring_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">keyring_list</span> <span class="o">*</span><span class="n">klist</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">,</span> <span class="n">keep</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;{%x,%s}&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">keyring</span><span class="p">),</span> <span class="n">keyring</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="n">klist</span> <span class="o">=</span> <span class="n">rcu_dereference_locked_keyring</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">klist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_klist</span><span class="p">;</span>

	<span class="cm">/* work out how many subscriptions we&#39;re keeping */</span>
	<span class="n">keep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_is_dead</span><span class="p">(</span><span class="n">rcu_deref_link_locked</span><span class="p">(</span><span class="n">klist</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">keyring</span><span class="p">),</span>
				 <span class="n">limit</span><span class="p">))</span>
			<span class="n">keep</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keep</span> <span class="o">==</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">just_return</span><span class="p">;</span>

	<span class="cm">/* allocate a new keyring payload */</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">keyring_list</span><span class="p">)</span> <span class="o">+</span> <span class="n">max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">),</span>
		      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">maxkeys</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">delkey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* install the live keys</span>
<span class="cm">	 * - must take care as expired keys may be updated back to life</span>
<span class="cm">	 */</span>
	<span class="n">keep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="n">klist</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">rcu_deref_link_locked</span><span class="p">(</span><span class="n">klist</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">keyring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_is_dead</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keep</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">discard_new</span><span class="p">;</span>
			<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">keep</span><span class="o">++</span><span class="p">],</span> <span class="n">key_get</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="n">keep</span><span class="p">;</span>

	<span class="cm">/* adjust the quota */</span>
	<span class="n">key_payload_reserve</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">keyring_list</span><span class="p">)</span> <span class="o">+</span>
			    <span class="n">KEYQUOTA_LINK_BYTES</span> <span class="o">*</span> <span class="n">keep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">subscriptions</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">keyring_clear_rcu_disposal</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [yes]&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">discard_new:</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">nkeys</span> <span class="o">=</span> <span class="n">keep</span><span class="p">;</span>
	<span class="n">keyring_clear_rcu_disposal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [discard]&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">just_return:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [no dead]&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">no_klist:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [no_klist]&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; [oom]&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
