<!DOCTYPE html>
<html><head><title>joekychen/linux » security › keys › key.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>key.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Basic authentication token and access key management</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">key_jar</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">key_serial_tree</span><span class="p">;</span> <span class="cm">/* tree of keys indexed by serial */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">key_serial_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">key_user_tree</span><span class="p">;</span> <span class="cm">/* tree of quota records indexed by UID */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">key_user_lock</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_quota_root_maxkeys</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>	<span class="cm">/* root&#39;s key count quota */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_quota_root_maxbytes</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>	<span class="cm">/* root&#39;s key space quota */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_quota_maxkeys</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>		<span class="cm">/* general key count quota */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_quota_maxbytes</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>	<span class="cm">/* general key space quota */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">key_types_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">key_types_sem</span><span class="p">);</span>

<span class="cm">/* We serialise key instantiation and link */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">key_construction_mutex</span><span class="p">);</span>

<span class="cp">#ifdef KEY_DEBUGGING</span>
<span class="kt">void</span> <span class="nf">__key_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;__key_check: key %p {%08x} should be {%08x}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="n">KEY_DEBUG_MAGIC</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Get the key quota record for a user, allocating a new record if one doesn&#39;t</span>
<span class="cm"> * already exist.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="nf">key_user_lookup</span><span class="p">(</span><span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">candidate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">key_user_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">);</span>

	<span class="cm">/* search the tree for a user record with a matching UID */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">user</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key_user</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">&lt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">&gt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_ns</span> <span class="o">&lt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_ns</span> <span class="o">&gt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we get here, we failed to find a match in the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">candidate</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate a candidate user record if we don&#39;t already have</span>
<span class="cm">		 * one */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">);</span>

		<span class="n">user</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">candidate</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_user</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">candidate</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* the allocation may have scheduled, so we need to repeat the</span>
<span class="cm">		 * search lest someone else added the record whilst we were</span>
<span class="cm">		 * asleep */</span>
		<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we get here, then the user record still hadn&#39;t appeared on the</span>
<span class="cm">	 * second pass - so we use the candidate record */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">nikeys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">candidate</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">candidate</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">=</span> <span class="n">get_user_ns</span><span class="p">(</span><span class="n">user_ns</span><span class="p">);</span>
	<span class="n">candidate</span><span class="o">-&gt;</span><span class="n">qnkeys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">candidate</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">cons_lock</span><span class="p">);</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_user_tree</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">);</span>
	<span class="n">user</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* okay - we found a user record for this UID */</span>
<span class="nl">found:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">user</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dispose of a user structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">key_user_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_user_tree</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_user_lock</span><span class="p">);</span>
		<span class="n">put_user_ns</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a serial number for a key.  These are assigned randomly to avoid</span>
<span class="cm"> * security issues through covert channel problems.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">key_alloc_serial</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">xkey</span><span class="p">;</span>

	<span class="cm">/* propose a random serial number and look for a hole for it in the</span>
<span class="cm">	 * serial number tree */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">));</span>

		<span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* negative numbers are not permitted */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_serial_lock</span><span class="p">);</span>

<span class="nl">attempt_insertion:</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">key_serial_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">xkey</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span><span class="p">,</span> <span class="n">serial_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&lt;</span> <span class="n">xkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&gt;</span> <span class="n">xkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">serial_exists</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ve found a suitable hole - arrange for this key to occupy it */</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_serial_tree</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_serial_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* we found a key with the proposed serial number - walk the tree from</span>
<span class="cm">	 * that point looking for the next unused serial number */</span>
<span class="nl">serial_exists:</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">attempt_insertion</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">attempt_insertion</span><span class="p">;</span>

		<span class="n">xkey</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span><span class="p">,</span> <span class="n">serial_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">&lt;</span> <span class="n">xkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">attempt_insertion</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * key_alloc - Allocate a key of the specified type.</span>
<span class="cm"> * @type: The type of key to allocate.</span>
<span class="cm"> * @desc: The key description to allow the key to be searched out.</span>
<span class="cm"> * @uid: The owner of the new key.</span>
<span class="cm"> * @gid: The group ID for the new key&#39;s group permissions.</span>
<span class="cm"> * @cred: The credentials specifying UID namespace.</span>
<span class="cm"> * @perm: The permissions mask of the new key.</span>
<span class="cm"> * @flags: Flags specifying quota properties.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a key of the specified type with the attributes given.  The key is</span>
<span class="cm"> * returned in an uninstantiated state and the caller needs to instantiate the</span>
<span class="cm"> * key before returning.</span>
<span class="cm"> *</span>
<span class="cm"> * The user&#39;s key count quota is updated to reflect the creation of the key and</span>
<span class="cm"> * the user&#39;s key data quota has the default for the key type reserved.  The</span>
<span class="cm"> * instantiation function should amend this as necessary.  If insufficient</span>
<span class="cm"> * quota is available, -EDQUOT will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The LSM security modules can prevent a key being created, in which case</span>
<span class="cm"> * -EACCES will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the new key if successful and an error code otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the caller needs to ensure the key type isn&#39;t uninstantiated.</span>
<span class="cm"> * Internally this can be done by locking key_types_sem.  Externally, this can</span>
<span class="cm"> * be done by either never unregistering the key type, or making sure</span>
<span class="cm"> * key_alloc() calls don&#39;t race with module unloading.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		      <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
		      <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">desclen</span><span class="p">,</span> <span class="n">quotalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!*</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">vet_description</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">vet_description</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">desclen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">quotalen</span> <span class="o">=</span> <span class="n">desclen</span> <span class="o">+</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">def_datalen</span><span class="p">;</span>

	<span class="cm">/* get hold of the key tracking for this user */</span>
	<span class="n">user</span> <span class="o">=</span> <span class="n">key_user_lookup</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_memory_1</span><span class="p">;</span>

	<span class="cm">/* check that the user&#39;s quota permits allocation of another key and</span>
<span class="cm">	 * its description */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEY_ALLOC_NOT_IN_QUOTA</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">maxkeys</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">key_quota_root_maxkeys</span> <span class="o">:</span> <span class="n">key_quota_maxkeys</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">maxbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">key_quota_root_maxbytes</span> <span class="o">:</span> <span class="n">key_quota_maxbytes</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEY_ALLOC_QUOTA_OVERRUN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnkeys</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">maxkeys</span> <span class="o">||</span>
			    <span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">quotalen</span> <span class="o">&gt;=</span> <span class="n">maxbytes</span> <span class="o">||</span>
			    <span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">quotalen</span> <span class="o">&lt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_quota</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnkeys</span><span class="o">++</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+=</span> <span class="n">quotalen</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* allocate and initialise the key and its description */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">key_jar</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_memory_2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">desclen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_memory_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">lock_class</span><span class="p">);</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span> <span class="o">=</span> <span class="n">quotalen</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">def_datalen</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">gid</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEY_ALLOC_NOT_IN_QUOTA</span><span class="p">))</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KEY_FLAG_IN_QUOTA</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">));</span>

<span class="cp">#ifdef KEY_DEBUGGING</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">KEY_DEBUG_MAGIC</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* let the security module know about the key */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_key_alloc</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">security_error</span><span class="p">;</span>

	<span class="cm">/* publish the key by giving it a serial number */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">);</span>
	<span class="n">key_alloc_serial</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>

<span class="nl">security_error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">key_jar</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEY_ALLOC_NOT_IN_QUOTA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnkeys</span><span class="o">--</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">-=</span> <span class="n">quotalen</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">key_user_put</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">no_memory_3:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">key_jar</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="nl">no_memory_2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEY_ALLOC_NOT_IN_QUOTA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnkeys</span><span class="o">--</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">-=</span> <span class="n">quotalen</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">key_user_put</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
<span class="nl">no_memory_1:</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">no_quota:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">key_user_put</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EDQUOT</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_payload_reserve - Adjust data quota reservation for the key&#39;s payload</span>
<span class="cm"> * @key: The key to make the reservation for.</span>
<span class="cm"> * @datalen: The amount of data payload the caller now wants.</span>
<span class="cm"> *</span>
<span class="cm"> * Adjust the amount of the owning user&#39;s key data quota that a key reserves.</span>
<span class="cm"> * If the amount is increased, then -EDQUOT may be returned if there isn&#39;t</span>
<span class="cm"> * enough free quota available.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_payload_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">datalen</span> <span class="o">-</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* contemplate the quota adjustment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_IN_QUOTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">maxbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">key_quota_root_maxbytes</span> <span class="o">:</span> <span class="n">key_quota_maxbytes</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">&gt;=</span> <span class="n">maxbytes</span> <span class="o">||</span>
		     <span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDQUOT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* change the recorded data length if that didn&#39;t generate an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">=</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_payload_reserve</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Instantiate a key and link it into the target keyring atomically.  Must be</span>
<span class="cm"> * called with the target keyring&#39;s semaphore writelocked.  The target key&#39;s</span>
<span class="cm"> * semaphore need not be locked as instantiation is serialised by</span>
<span class="cm"> * key_construction_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__key_instantiate_and_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">authkey</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">_prealloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">awaken</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="n">awaken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>

	<span class="cm">/* can&#39;t instantiate twice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INSTANTIATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* instantiate the key */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">instantiate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* mark the key as being instantiated */</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">nikeys</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INSTANTIATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">awaken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* and link it into the destination keyring */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="p">)</span>
				<span class="n">__key_link</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_prealloc</span><span class="p">);</span>

			<span class="cm">/* disable the authorisation key */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">authkey</span><span class="p">)</span>
				<span class="n">key_revoke</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>

	<span class="cm">/* wake up anyone waiting for a key to be constructed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">awaken</span><span class="p">)</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * key_instantiate_and_link - Instantiate a key and link it into the keyring.</span>
<span class="cm"> * @key: The key to instantiate.</span>
<span class="cm"> * @data: The data to use to instantiate the keyring.</span>
<span class="cm"> * @datalen: The length of @data.</span>
<span class="cm"> * @keyring: Keyring to create a link in on success (or NULL).</span>
<span class="cm"> * @authkey: The authorisation token permitting instantiation.</span>
<span class="cm"> *</span>
<span class="cm"> * Instantiate a key that&#39;s in the uninstantiated state using the provided data</span>
<span class="cm"> * and, if successful, link it in to the destination keyring if one is</span>
<span class="cm"> * supplied.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned, the authorisation token is revoked and anyone</span>
<span class="cm"> * waiting for the key is woken up.  If the key was already instantiated,</span>
<span class="cm"> * -EBUSY will be returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_instantiate_and_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">authkey</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_begin</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_instantiate_and_link</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">keyring</span><span class="p">,</span> <span class="n">authkey</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="p">)</span>
		<span class="n">__key_link_end</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_instantiate_and_link</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_reject_and_link - Negatively instantiate a key and link it into the keyring.</span>
<span class="cm"> * @key: The key to instantiate.</span>
<span class="cm"> * @timeout: The timeout on the negative key.</span>
<span class="cm"> * @error: The error to return when the key is hit.</span>
<span class="cm"> * @keyring: Keyring to create a link in on success (or NULL).</span>
<span class="cm"> * @authkey: The authorisation token permitting instantiation.</span>
<span class="cm"> *</span>
<span class="cm"> * Negatively instantiate a key that&#39;s in the uninstantiated state and, if</span>
<span class="cm"> * successful, set its timeout and stored error and link it in to the</span>
<span class="cm"> * destination keyring if one is supplied.  The key and any links to the key</span>
<span class="cm"> * will be automatically garbage collected after the timeout expires.</span>
<span class="cm"> *</span>
<span class="cm"> * Negative keys are used to rate limit repeated request_key() calls by causing</span>
<span class="cm"> * them to return the stored error code (typically ENOKEY) until the negative</span>
<span class="cm"> * key expires.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned, the authorisation token is revoked and anyone</span>
<span class="cm"> * waiting for the key is woken up.  If the key was already instantiated,</span>
<span class="cm"> * -EBUSY will be returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_reject_and_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">error</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">authkey</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">awaken</span><span class="p">,</span> <span class="n">link_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="n">awaken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="p">)</span>
		<span class="n">link_ret</span> <span class="o">=</span> <span class="n">__key_link_begin</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
					    <span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>

	<span class="cm">/* can&#39;t instantiate twice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INSTANTIATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* mark the key as being negatively instantiated */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">nikeys</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INSTANTIATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">type_data</span><span class="p">.</span><span class="n">reject_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="n">key_schedule_gc</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">+</span> <span class="n">key_gc_delay</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">awaken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* and link it into the destination keyring */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span> <span class="o">&amp;&amp;</span> <span class="n">link_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">__key_link</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>

		<span class="cm">/* disable the authorisation key */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">authkey</span><span class="p">)</span>
			<span class="n">key_revoke</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_construction_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="p">)</span>
		<span class="n">__key_link_end</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>

	<span class="cm">/* wake up anyone waiting for a key to be constructed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">awaken</span><span class="p">)</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">KEY_FLAG_USER_CONSTRUCT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">link_ret</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_reject_and_link</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_put - Discard a reference to a key.</span>
<span class="cm"> * @key: The key to discard a reference from.</span>
<span class="cm"> *</span>
<span class="cm"> * Discard a reference to a key, and when all the references are gone, we</span>
<span class="cm"> * schedule the cleanup task to come and pull it out of the tree in process</span>
<span class="cm"> * context at some later time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">key_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">))</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">system_nrt_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_gc_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Find a key by its serial number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">key_lookup</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_serial_lock</span><span class="p">);</span>

	<span class="cm">/* search the tree for the specified key */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">key_serial_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span><span class="p">,</span> <span class="n">serial_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">not_found:</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="cm">/* pretend it doesn&#39;t exist if it is awaiting deletion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>

	<span class="cm">/* this races with key_put(), but that doesn&#39;t matter since key_put()</span>
<span class="cm">	 * doesn&#39;t actually change the key</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_serial_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find and lock the specified key type against removal.</span>
<span class="cm"> *</span>
<span class="cm"> * We return with the sem read-locked if successful.  If the type wasn&#39;t</span>
<span class="cm"> * available -ENOKEY is returned instead.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="nf">key_type_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>

	<span class="cm">/* look up the key type to see if it&#39;s one of the registered kernel</span>
<span class="cm">	 * types */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ktype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found_kernel_type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
	<span class="n">ktype</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>

<span class="nl">found_kernel_type:</span>
	<span class="k">return</span> <span class="n">ktype</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">key_set_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">expiry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* make the changes with the locks held to prevent races */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
		<span class="n">expiry</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">=</span> <span class="n">expiry</span><span class="p">;</span>
	<span class="n">key_schedule_gc</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">expiry</span> <span class="o">+</span> <span class="n">key_gc_delay</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">key_set_timeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Unlock a key type locked by key_type_lookup().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">key_type_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to update an existing key.</span>
<span class="cm"> *</span>
<span class="cm"> * The key is given to us with an incremented refcount that we need to discard</span>
<span class="cm"> * if we get an error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">key_ref_t</span> <span class="nf">__key_update</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* need write permission on the key to update it */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_permission</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* updating a negative key instantiates it */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KEY_FLAG_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">key_ref</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * key_create_or_update - Update or create and instantiate a key.</span>
<span class="cm"> * @keyring_ref: A pointer to the destination keyring with possession flag.</span>
<span class="cm"> * @type: The type of key.</span>
<span class="cm"> * @description: The searchable description for the key.</span>
<span class="cm"> * @payload: The data to use to instantiate or update the key.</span>
<span class="cm"> * @plen: The length of @payload.</span>
<span class="cm"> * @perm: The permissions mask for a new key.</span>
<span class="cm"> * @flags: The quota flags for a new key.</span>
<span class="cm"> *</span>
<span class="cm"> * Search the destination keyring for a key of the same description and if one</span>
<span class="cm"> * is found, update it, otherwise create and instantiate a new one and create a</span>
<span class="cm"> * link to it from that keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be</span>
<span class="cm"> * concocted.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the new key if successful, -ENODEV if the key type</span>
<span class="cm"> * wasn&#39;t available, -ENOTDIR if the keyring wasn&#39;t a keyring, -EACCES if the</span>
<span class="cm"> * caller isn&#39;t permitted to modify the keyring or the LSM did not permit</span>
<span class="cm"> * creation of the key.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, the possession flag from the keyring ref will be tacked on to</span>
<span class="cm"> * the key ref before it is returned.</span>
<span class="cm"> */</span>
<span class="n">key_ref_t</span> <span class="nf">key_create_or_update</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">plen</span><span class="p">,</span>
			       <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prealloc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">keyring</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* look up the key type to see if it&#39;s one of the registered kernel</span>
<span class="cm">	 * types */</span>
	<span class="n">ktype</span> <span class="o">=</span> <span class="n">key_type_lookup</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ktype</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">||</span> <span class="o">!</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">instantiate</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>

	<span class="n">keyring</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">keyring</span><span class="p">);</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOTDIR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_link_begin</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_2</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re going to allocate a new key, we&#39;re going to have</span>
<span class="cm">	 * to modify the keyring */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_permission</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if it&#39;s possible to update this type of key, search for an existing</span>
<span class="cm">	 * key of the same type and description in the destination keyring and</span>
<span class="cm">	 * update that instead if possible</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">__keyring_search_one</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found_matching_key</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the client doesn&#39;t provide, decide on the permissions we want */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">perm</span> <span class="o">==</span> <span class="n">KEY_PERM_UNDEF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perm</span> <span class="o">=</span> <span class="n">KEY_POS_VIEW</span> <span class="o">|</span> <span class="n">KEY_POS_SEARCH</span> <span class="o">|</span> <span class="n">KEY_POS_LINK</span> <span class="o">|</span> <span class="n">KEY_POS_SETATTR</span><span class="p">;</span>
		<span class="n">perm</span> <span class="o">|=</span> <span class="n">KEY_USR_VIEW</span> <span class="o">|</span> <span class="n">KEY_USR_SEARCH</span> <span class="o">|</span> <span class="n">KEY_USR_LINK</span> <span class="o">|</span> <span class="n">KEY_USR_SETATTR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
			<span class="n">perm</span> <span class="o">|=</span> <span class="n">KEY_POS_READ</span> <span class="o">|</span> <span class="n">KEY_USR_READ</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ktype</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_keyring</span> <span class="o">||</span> <span class="n">ktype</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span>
			<span class="n">perm</span> <span class="o">|=</span> <span class="n">KEY_USR_WRITE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate a new key */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">key_alloc</span><span class="p">(</span><span class="n">ktype</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsgid</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span>
			<span class="n">perm</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* instantiate it and link it into the target keyring */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__key_instantiate_and_link</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">keyring</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">prealloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">make_key_ref</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">is_key_possessed</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">));</span>

 <span class="nl">error_3:</span>
	<span class="n">__key_link_end</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>
 <span class="nl">error_2:</span>
	<span class="n">key_type_put</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
 <span class="nl">error:</span>
	<span class="k">return</span> <span class="n">key_ref</span><span class="p">;</span>

 <span class="nl">found_matching_key:</span>
	<span class="cm">/* we found a matching key, so we&#39;re going to try to update it</span>
<span class="cm">	 * - we can drop the locks first as we have the key pinned</span>
<span class="cm">	 */</span>
	<span class="n">__key_link_end</span><span class="p">(</span><span class="n">keyring</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">prealloc</span><span class="p">);</span>
	<span class="n">key_type_put</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">__key_update</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_create_or_update</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_update - Update a key&#39;s contents.</span>
<span class="cm"> * @key_ref: The pointer (plus possession flag) to the key.</span>
<span class="cm"> * @payload: The data to be used to update the key.</span>
<span class="cm"> * @plen: The length of @payload.</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to update the contents of a key with the given payload data.  The</span>
<span class="cm"> * caller must be granted Write permission on the key.  Negative keys can be</span>
<span class="cm"> * instantiated by this method.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key</span>
<span class="cm"> * type does not support updating.  The key type may return other errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">key_update</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* the key must be writable */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_permission</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* attempt to update it if supported */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* updating a negative key instantiates it */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">KEY_FLAG_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_update</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_revoke - Revoke a key.</span>
<span class="cm"> * @key: The key to be revoked.</span>
<span class="cm"> *</span>
<span class="cm"> * Mark a key as being revoked and ask the type to free up its resources.  The</span>
<span class="cm"> * revocation timeout is set and the key and all its links will be</span>
<span class="cm"> * automatically garbage collected after key_gc_delay amount of time if they</span>
<span class="cm"> * are not manually dealt with first.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">key_revoke</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* make sure no one&#39;s trying to change or use the key when we mark it</span>
<span class="cm">	 * - we tell lockdep that we might nest because we might be revoking an</span>
<span class="cm">	 *   authorisation key whilst holding the sem on a key we&#39;ve just</span>
<span class="cm">	 *   instantiated</span>
<span class="cm">	 */</span>
	<span class="n">down_write_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_REVOKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revoke</span><span class="p">)</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revoke</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* set the death time to no more than the expiry time */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
	<span class="n">time</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">revoked_at</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">revoked_at</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">revoked_at</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
		<span class="n">key_schedule_gc</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">revoked_at</span> <span class="o">+</span> <span class="n">key_gc_delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_revoke</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * key_invalidate - Invalidate a key.</span>
<span class="cm"> * @key: The key to be invalidated.</span>
<span class="cm"> *</span>
<span class="cm"> * Mark a key as being invalidated and have it cleaned up immediately.  The key</span>
<span class="cm"> * is ignored by all searches and other operations from this point.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">key_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">key_serial</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

	<span class="n">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INVALIDATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INVALIDATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">key_schedule_gc_links</span><span class="p">();</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">key_invalidate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * register_key_type - Register a type of key.</span>
<span class="cm"> * @ktype: The new key type.</span>
<span class="cm"> *</span>
<span class="cm"> * Register a new key type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or -EEXIST if a type of this name already exists.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_key_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">lock_class</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">lock_class</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>

	<span class="cm">/* disallow key types with the same name */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ktype</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* store the type */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">);</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Key type %s registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ktype</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_key_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * unregister_key_type - Unregister a type of key.</span>
<span class="cm"> * @ktype: The key type.</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister a key type and mark all the extant keys of this type as dead.</span>
<span class="cm"> * Those keys of this type are then destroyed to get rid of their payloads and</span>
<span class="cm"> * they and their links will be garbage collected as soon as possible.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_key_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">downgrade_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
	<span class="n">key_gc_keytype</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Key type %s unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ktype</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_types_sem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_key_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the key management state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">key_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* allocate a slab in which we can store keys */</span>
	<span class="n">key_jar</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;key_jar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* add the special key types */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_keyring</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_dead</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_user</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_logon</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_types_list</span><span class="p">);</span>

	<span class="cm">/* record the root user tracking */</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_key_user</span><span class="p">.</span><span class="n">node</span><span class="p">,</span>
		     <span class="nb">NULL</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">key_user_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_key_user</span><span class="p">.</span><span class="n">node</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">key_user_tree</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
