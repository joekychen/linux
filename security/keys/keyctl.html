<!DOCTYPE html>
<html><head><title>joekychen/linux » security › keys › keyctl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>keyctl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Userspace key control operations</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/keyctl.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">key_get_type_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_type</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">type</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Extract the description of a new key from userspace and either add it as a</span>
<span class="cm"> * new key to the specified keyring or update a matching key in that keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring must be writable so that we can attach the key to it.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the new key&#39;s serial number is returned, otherwise an error</span>
<span class="cm"> * code is returned.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">add_key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_description</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_payload</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span>
		<span class="n">key_serial_t</span><span class="p">,</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">vm</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* draw all the data into kernel space */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_get_type_from_user</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">description</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">_description</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pull the payload in if one was supplied */</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vm</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_payload</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">payload</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
			<span class="n">vm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">payload</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">plen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">_payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find the target keyring (which must be writable) */</span>
	<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create or update the requested key and add it to the target</span>
<span class="cm">	 * keyring */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">key_create_or_update</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span>
				       <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">KEY_PERM_UNDEF</span><span class="p">,</span>
				       <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
		<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
 <span class="nl">error3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
 <span class="nl">error2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
 <span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the process keyrings and keyring trees linked from those for a</span>
<span class="cm"> * matching key.  Keyrings must have appropriate Search permission to be</span>
<span class="cm"> * searched.</span>
<span class="cm"> *</span>
<span class="cm"> * If a key is found, it will be attached to the destination keyring if there&#39;s</span>
<span class="cm"> * one specified and the serial number of the key will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If no key is found, /sbin/request-key will be invoked if _callout_info is</span>
<span class="cm"> * non-NULL in an attempt to create a key.  The _callout_info string will be</span>
<span class="cm"> * passed to /sbin/request-key to aid with completing the request.  If the</span>
<span class="cm"> * _callout_info string is &quot;&quot; then it will be changed to &quot;-&quot;.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">request_key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_description</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">_callout_info</span><span class="p">,</span>
		<span class="n">key_serial_t</span><span class="p">,</span> <span class="n">destringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">dest_ref</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">callout_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="o">*</span><span class="n">description</span><span class="p">,</span> <span class="o">*</span><span class="n">callout_info</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* pull the type into kernel space */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_get_type_from_user</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* pull the description into kernel space */</span>
	<span class="n">description</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">_description</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pull the callout info into kernel space */</span>
	<span class="n">callout_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">callout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_callout_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">callout_info</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">_callout_info</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">callout_info</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">callout_info</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">callout_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">callout_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* get the destination keyring if specified */</span>
	<span class="n">dest_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">destringid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dest_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">destringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span>
					   <span class="n">KEY_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* find the key type */</span>
	<span class="n">ktype</span> <span class="o">=</span> <span class="n">key_type_lookup</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ktype</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do the search */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">request_key_and_link</span><span class="p">(</span><span class="n">ktype</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">callout_info</span><span class="p">,</span>
				   <span class="n">callout_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">),</span>
				   <span class="n">KEY_ALLOC_IN_QUOTA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wait for the key to finish being constructed */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_key_construction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error6</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>

<span class="nl">error6:</span>
 	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="nl">error5:</span>
	<span class="n">key_type_put</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
<span class="nl">error4:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">);</span>
<span class="nl">error3:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">callout_info</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the ID of the specified process keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * The requested keyring must have search permission to be found.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the ID of the requested keyring will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_get_keyring_ID</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lflags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">lflags</span> <span class="o">=</span> <span class="n">create</span> <span class="o">?</span> <span class="n">KEY_LOOKUP_CREATE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">lflags</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Join a (named) session keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * Create and join an anonymous session keyring or join a named session</span>
<span class="cm"> * keyring, creating it if necessary.  A named session keyring must have Search</span>
<span class="cm"> * permission for it to be joined.  Session keyrings without this permit will</span>
<span class="cm"> * be skipped over.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the ID of the joined session keyring will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_join_session_keyring</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* fetch the name from userspace */</span>
	<span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* join the session */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">join_session_keyring</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update a key&#39;s data payload from the given data.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller Write permission and the key type must support</span>
<span class="cm"> * updating for this to work.  A negative key can be positively instantiated</span>
<span class="cm"> * with this call.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.  If the key type does not support</span>
<span class="cm"> * updating, then -EOPNOTSUPP will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_update_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_payload</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* pull the payload in if one was supplied */</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_payload</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">payload</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">_payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find the target key (which must be writable) */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* update the key */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_update</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Revoke a key.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must be grant the caller Write or Setattr permission for this to</span>
<span class="cm"> * work.  The key type should give up its quota claim when revoked.  The key</span>
<span class="cm"> * and any links to the key will be automatically garbage collected after a</span>
<span class="cm"> * certain amount of time (/proc/sys/kernel/keys/gc_delay).</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_revoke_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_SETATTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">key_revoke</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate a key.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must be grant the caller Invalidate permission for this to work.</span>
<span class="cm"> * The key and any links to the key will be automatically garbage collected</span>
<span class="cm"> * immediately.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_invalidate_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_invalidate</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %ld&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear the specified keyring, creating an empty process keyring if one of the</span>
<span class="cm"> * special keyring IDs is used.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring must grant the caller Write permission for this to work.  If</span>
<span class="cm"> * successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_keyring_clear</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>

		<span class="cm">/* Root is permitted to invalidate certain special keyrings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_ROOT_CAN_CLEAR</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">clear</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_put</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">clear:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">keyring_clear</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">));</span>
<span class="nl">error_put:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a link from a keyring to a key if there&#39;s no matching key in the</span>
<span class="cm"> * keyring, otherwise replace the link to the matching key with a link to the</span>
<span class="cm"> * new key.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller Link permission and the the keyring must grant</span>
<span class="cm"> * the caller Write permission.  Furthermore, if an additional link is created,</span>
<span class="cm"> * the keyring&#39;s quota will be extended.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_keyring_link</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span> <span class="n">KEY_LINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_link</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">),</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">));</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a key from a keyring.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring must grant the caller Write permission for this to work; the key</span>
<span class="cm"> * itself need not grant the caller anything.  If the last link to a key is</span>
<span class="cm"> * removed then that key will be scheduled for destruction.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_keyring_unlink</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">KEY_LOOKUP_FOR_UNLINK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_unlink</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">),</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">));</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a description of a key to userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller View permission for this to work.</span>
<span class="cm"> *</span>
<span class="cm"> * If there&#39;s a buffer, we place up to buflen bytes of data into it formatted</span>
<span class="cm"> * in the following way:</span>
<span class="cm"> *</span>
<span class="cm"> *	type;uid;gid;perm;description&lt;NUL&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, we return the amount of description available, irrespective</span>
<span class="cm"> * of how much we may have copied into the buffer.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_describe_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">keyid</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">instkey</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuf</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">keyid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span> <span class="n">KEY_VIEW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* viewing a key under construction is permitted if we have the</span>
<span class="cm">		 * authorisation token handy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">instkey</span> <span class="o">=</span> <span class="n">key_get_instantiation_authkey</span><span class="p">(</span><span class="n">keyid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">instkey</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">key_put</span><span class="p">(</span><span class="n">instkey</span><span class="p">);</span>
				<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">keyid</span><span class="p">,</span>
							  <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span>
							  <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">okay</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">okay:</span>
	<span class="cm">/* calculate how much description we&#39;re going to return */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">tmpbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmpbuf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="s">&quot;%s;%d;%d;%08x;%s&quot;</span><span class="p">,</span>
		       <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>
		       <span class="n">key</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span>
		       <span class="n">key</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">,</span>
		       <span class="n">key</span><span class="o">-&gt;</span><span class="n">description</span> <span class="o">?:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/* include a NUL char at the end of the data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tmpbuf</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* consider returning the data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;&amp;</span> <span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">)</span>
			<span class="n">buflen</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">tmpbuf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the specified keyring and any keyrings it links to for a matching</span>
<span class="cm"> * key.  Only keyrings that grant the caller Search permission will be searched</span>
<span class="cm"> * (this includes the starting keyring).  Only keys with Search permission can</span>
<span class="cm"> * be found.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the found key will be linked to the destination keyring if</span>
<span class="cm"> * supplied and the key has Link permission, and the found key ID will be</span>
<span class="cm"> * returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_keyring_search</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_type</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_description</span><span class="p">,</span>
			   <span class="n">key_serial_t</span> <span class="n">destringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_ref</span><span class="p">,</span> <span class="n">key_ref</span><span class="p">,</span> <span class="n">dest_ref</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* pull the type and description into kernel space */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_get_type_from_user</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">description</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">_description</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the keyring at which to begin the search */</span>
	<span class="n">keyring_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_SEARCH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the destination keyring if specified */</span>
	<span class="n">dest_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">destringid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dest_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">destringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span>
					   <span class="n">KEY_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* find the key type */</span>
	<span class="n">ktype</span> <span class="o">=</span> <span class="n">key_type_lookup</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ktype</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do the search */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">keyring_search</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

		<span class="cm">/* treat lack or presence of a negative key the same */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOKEY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* link the resulting key to the destination keyring if we can */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">key_permission</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">KEY_LINK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error6</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">key_link</span><span class="p">(</span><span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">),</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>

<span class="nl">error6:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
<span class="nl">error5:</span>
	<span class="n">key_type_put</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
<span class="nl">error4:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">dest_ref</span><span class="p">);</span>
<span class="nl">error3:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_ref</span><span class="p">);</span>
<span class="nl">error2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a key&#39;s payload.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must either grant the caller Read permission, or it must grant the</span>
<span class="cm"> * caller Search permission when searched for from the process keyrings.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, we place up to buflen bytes of data into the buffer, if one</span>
<span class="cm"> * is provided, and return the amount of data that is available in the key,</span>
<span class="cm"> * irrespective of how much we copied into the buffer.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_read_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">keyid</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* find the key first */</span>
	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">keyid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOKEY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

	<span class="cm">/* see if we can read it directly */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_permission</span><span class="p">(</span><span class="n">key_ref</span><span class="p">,</span> <span class="n">KEY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">can_read_key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* we can&#39;t; see if it&#39;s searchable from this process&#39;s keyrings</span>
<span class="cm">	 * - we automatically take account of the fact that it may be</span>
<span class="cm">	 *   dangling off an instantiation key</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_key_possessed</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the key is probably readable - now try to read it */</span>
<span class="nl">can_read_key:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_validate</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* read the data with the semaphore held (since we</span>
<span class="cm">			 * might sleep) */</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">error2:</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the ownership of a key</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller Setattr permission for this to work, though</span>
<span class="cm"> * the key need not be fully instantiated yet.  For the UID to be changed, or</span>
<span class="cm"> * for the GID to be changed to a group the caller is not a member of, the</span>
<span class="cm"> * caller must have sysadmin capability.  If either uid or gid is -1 then that</span>
<span class="cm"> * attribute is not changed.</span>
<span class="cm"> *</span>
<span class="cm"> * If the UID is to be changed, the new user must have sufficient quota to</span>
<span class="cm"> * accept the key.  The quota deduction will be removed from the old user to</span>
<span class="cm"> * the new user should the attribute be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_chown_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key_user</span> <span class="o">*</span><span class="n">newowner</span><span class="p">,</span> <span class="o">*</span><span class="n">zapowner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">gid</span> <span class="o">==</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span>
				  <span class="n">KEY_SETATTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

	<span class="cm">/* make the changes with the locks held to prevent chown/chown races */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* only the sysadmin can chown a key to some other UID */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">uid</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_put</span><span class="p">;</span>

		<span class="cm">/* only the sysadmin can set the key&#39;s GID to a group other</span>
<span class="cm">		 * than one of those that the current process subscribes to */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">gid</span> <span class="o">!=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">gid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* change the UID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">uid</span> <span class="o">!=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">newowner</span> <span class="o">=</span> <span class="n">key_user_lookup</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">current_user_ns</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newowner</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_put</span><span class="p">;</span>

		<span class="cm">/* transfer the quota burden to the new user */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_IN_QUOTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">maxkeys</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">key_quota_root_maxkeys</span> <span class="o">:</span> <span class="n">key_quota_maxkeys</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">maxbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">key_quota_root_maxbytes</span> <span class="o">:</span> <span class="n">key_quota_maxbytes</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnkeys</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">maxkeys</span> <span class="o">||</span>
			    <span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span> <span class="o">&gt;=</span> <span class="n">maxbytes</span> <span class="o">||</span>
			    <span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span> <span class="o">&lt;</span>
			    <span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnbytes</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">quota_overrun</span><span class="p">;</span>

			<span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnkeys</span><span class="o">++</span><span class="p">;</span>
			<span class="n">newowner</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">+=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnkeys</span><span class="o">--</span><span class="p">;</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">qnbytes</span> <span class="o">-=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">quotalen</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">nkeys</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KEY_FLAG_INSTANTIATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">nikeys</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">nikeys</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">zapowner</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">newowner</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* change the GID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">gid</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_put:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zapowner</span><span class="p">)</span>
		<span class="n">key_user_put</span><span class="p">(</span><span class="n">zapowner</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">quota_overrun:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">zapowner</span> <span class="o">=</span> <span class="n">newowner</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDQUOT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">error_put</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the permission mask on a key.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller Setattr permission for this to work, though</span>
<span class="cm"> * the key need not be fully instantiated yet.  If the caller does not have</span>
<span class="cm"> * sysadmin capability, it may only change the permission on keys that it owns.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_setperm_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">perm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">KEY_POS_ALL</span> <span class="o">|</span> <span class="n">KEY_USR_ALL</span> <span class="o">|</span> <span class="n">KEY_GRP_ALL</span> <span class="o">|</span> <span class="n">KEY_OTH_ALL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span>
				  <span class="n">KEY_SETATTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

	<span class="cm">/* make the changes with the locks held to prevent chown/chmod races */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="cm">/* if we&#39;re not the sysadmin, we can only change a key that we own */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">==</span> <span class="n">current_fsuid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the destination keyring for instantiation and check that the caller has</span>
<span class="cm"> * Write permission on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">get_instantiation_keyring</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">request_key_auth</span> <span class="o">*</span><span class="n">rka</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">key</span> <span class="o">**</span><span class="n">_dest_keyring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key_ref_t</span> <span class="n">dkref</span><span class="p">;</span>

	<span class="o">*</span><span class="n">_dest_keyring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* just return a NULL pointer if we weren&#39;t asked to make a link */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ringid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if a specific keyring is nominated by ID, then use that */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ringid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dkref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span><span class="p">,</span> <span class="n">KEY_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dkref</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dkref</span><span class="p">);</span>
		<span class="o">*</span><span class="n">_dest_keyring</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">dkref</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ringid</span> <span class="o">==</span> <span class="n">KEY_SPEC_REQKEY_AUTH_KEY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* otherwise specify the destination keyring recorded in the</span>
<span class="cm">	 * authorisation key (any KEY_SPEC_*_KEYRING) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ringid</span> <span class="o">&gt;=</span> <span class="n">KEY_SPEC_REQUESTOR_KEYRING</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">_dest_keyring</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">dest_keyring</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOKEY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the request_key authorisation key on the current process.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">keyctl_change_reqkey_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">key_put</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">request_key_auth</span> <span class="o">=</span> <span class="n">key_get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the iovec data from userspace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">copy_from_user_iovec</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">ioc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioc</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">buffer</span> <span class="o">+=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Instantiate a key with the specified payload and link the key into the</span>
<span class="cm"> * destination keyring if one is given.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the appropriate instantiation permit set for this to</span>
<span class="cm"> * work (see keyctl_assume_authority).  No other permissions are required.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_instantiate_key_common</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">payload_iov</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">ioc</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">plen</span><span class="p">,</span>
				   <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">request_key_auth</span> <span class="o">*</span><span class="n">rka</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">instkey</span><span class="p">,</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">vm</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,,%zu,%d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* the appropriate instantiation authorisation key must have been</span>
<span class="cm">	 * assumed before calling this */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">instkey</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instkey</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rka</span> <span class="o">=</span> <span class="n">instkey</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">target_key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* pull the payload in if one was supplied */</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">payload_iov</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">payload</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">vm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">payload</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">plen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user_iovec</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">payload_iov</span><span class="p">,</span> <span class="n">ioc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find the destination keyring amongst those belonging to the</span>
<span class="cm">	 * requesting task */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_instantiation_keyring</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">rka</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>

	<span class="cm">/* instantiate the key and link it into a keyring */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_instantiate_and_link</span><span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">target_key</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span>
				       <span class="n">dest_keyring</span><span class="p">,</span> <span class="n">instkey</span><span class="p">);</span>

	<span class="n">key_put</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>

	<span class="cm">/* discard the assumed authority if it&#39;s just been disabled by</span>
<span class="cm">	 * instantiation of the key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">keyctl_change_reqkey_auth</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="nl">error2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Instantiate a key with the specified payload and link the key into the</span>
<span class="cm"> * destination keyring if one is given.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the appropriate instantiation permit set for this to</span>
<span class="cm"> * work (see keyctl_assume_authority).  No other permissions are required.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_instantiate_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_payload</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">plen</span><span class="p">,</span>
			    <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_payload</span> <span class="o">&amp;&amp;</span> <span class="n">plen</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">_payload</span><span class="p">,</span>
			<span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span>  <span class="o">=</span> <span class="n">plen</span>
		<span class="p">};</span>

		<span class="k">return</span> <span class="n">keyctl_instantiate_key_common</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">keyctl_instantiate_key_common</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Instantiate a key with the specified multipart payload and link the key into</span>
<span class="cm"> * the destination keyring if one is given.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the appropriate instantiation permit set for this to</span>
<span class="cm"> * work (see keyctl_assume_authority).  No other permissions are required.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_instantiate_key_iov</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_payload_iov</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">ioc</span><span class="p">,</span>
				<span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iovstack</span><span class="p">[</span><span class="n">UIO_FASTIOV</span><span class="p">],</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="n">iovstack</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_payload_iov</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ioc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_payload</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_copy_check_uvector</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">_payload_iov</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span>
				    <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">iovstack</span><span class="p">),</span> <span class="n">iovstack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_payload_free</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">keyctl_instantiate_key_common</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span> <span class="o">!=</span> <span class="n">iovstack</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">no_payload_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span> <span class="o">!=</span> <span class="n">iovstack</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>
<span class="nl">no_payload:</span>
	<span class="k">return</span> <span class="n">keyctl_instantiate_key_common</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Negatively instantiate the key with the given timeout (in seconds) and link</span>
<span class="cm"> * the key into the destination keyring if one is given.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the appropriate instantiation permit set for this to</span>
<span class="cm"> * work (see keyctl_assume_authority).  No other permissions are required.</span>
<span class="cm"> *</span>
<span class="cm"> * The key and any links to the key will be automatically garbage collected</span>
<span class="cm"> * after the timeout expires.</span>
<span class="cm"> *</span>
<span class="cm"> * Negative keys are used to rate limit repeated request_key() calls by causing</span>
<span class="cm"> * them to return -ENOKEY until the negative key expires.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_negate_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">keyctl_reject_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">ENOKEY</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Negatively instantiate the key with the given timeout (in seconds) and error</span>
<span class="cm"> * code and link the key into the destination keyring if one is given.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the appropriate instantiation permit set for this to</span>
<span class="cm"> * work (see keyctl_assume_authority).  No other permissions are required.</span>
<span class="cm"> *</span>
<span class="cm"> * The key and any links to the key will be automatically garbage collected</span>
<span class="cm"> * after the timeout expires.</span>
<span class="cm"> *</span>
<span class="cm"> * Negative keys are used to rate limit repeated request_key() calls by causing</span>
<span class="cm"> * them to return the specified error code until the negative key expires.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_reject_key</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">error</span><span class="p">,</span>
		       <span class="n">key_serial_t</span> <span class="n">ringid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">request_key_auth</span> <span class="o">*</span><span class="n">rka</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">instkey</span><span class="p">,</span> <span class="o">*</span><span class="n">dest_keyring</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%d,%u,%u,%d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ringid</span><span class="p">);</span>

	<span class="cm">/* must be a valid error code and mustn&#39;t be a kernel special */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">error</span> <span class="o">&gt;=</span> <span class="n">MAX_ERRNO</span> <span class="o">||</span>
	    <span class="n">error</span> <span class="o">==</span> <span class="n">ERESTARTSYS</span> <span class="o">||</span>
	    <span class="n">error</span> <span class="o">==</span> <span class="n">ERESTARTNOINTR</span> <span class="o">||</span>
	    <span class="n">error</span> <span class="o">==</span> <span class="n">ERESTARTNOHAND</span> <span class="o">||</span>
	    <span class="n">error</span> <span class="o">==</span> <span class="n">ERESTART_RESTARTBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* the appropriate instantiation authorisation key must have been</span>
<span class="cm">	 * assumed before calling this */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">instkey</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instkey</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rka</span> <span class="o">=</span> <span class="n">instkey</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">target_key</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* find the destination keyring if present (which must also be</span>
<span class="cm">	 * writable) */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_instantiation_keyring</span><span class="p">(</span><span class="n">ringid</span><span class="p">,</span> <span class="n">rka</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_keyring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* instantiate the key and link it into a keyring */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">key_reject_and_link</span><span class="p">(</span><span class="n">rka</span><span class="o">-&gt;</span><span class="n">target_key</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span>
				  <span class="n">dest_keyring</span><span class="p">,</span> <span class="n">instkey</span><span class="p">);</span>

	<span class="n">key_put</span><span class="p">(</span><span class="n">dest_keyring</span><span class="p">);</span>

	<span class="cm">/* discard the assumed authority if it&#39;s just been disabled by</span>
<span class="cm">	 * instantiation of the key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">keyctl_change_reqkey_auth</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read or set the default keyring in which request_key() will cache keys and</span>
<span class="cm"> * return the old setting.</span>
<span class="cm"> *</span>
<span class="cm"> * If a process keyring is specified then this will be created if it doesn&#39;t</span>
<span class="cm"> * yet exist.  The old setting will be returned if successful.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_set_reqkey_keyring</span><span class="p">(</span><span class="kt">int</span> <span class="n">reqkey_defl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">old_setting</span><span class="p">;</span>

	<span class="n">old_setting</span> <span class="o">=</span> <span class="n">current_cred_xxx</span><span class="p">(</span><span class="n">jit_keyring</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reqkey_defl</span> <span class="o">==</span> <span class="n">KEY_REQKEY_DEFL_NO_CHANGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">old_setting</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reqkey_defl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_THREAD_KEYRING</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">install_thread_keyring_to_cred</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_PROCESS_KEYRING</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">install_process_keyring_to_cred</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_DEFAULT</span>:
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_SESSION_KEYRING</span>:
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_USER_KEYRING</span>:
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_USER_SESSION_KEYRING</span>:
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_REQUESTOR_KEYRING</span>:
		<span class="k">goto</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_NO_CHANGE</span>:
	<span class="k">case</span> <span class="n">KEY_REQKEY_DEFL_GROUP_KEYRING</span>:
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">set:</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">jit_keyring</span> <span class="o">=</span> <span class="n">reqkey_defl</span><span class="p">;</span>
	<span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">old_setting</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">abort_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set or clear the timeout on a key.</span>
<span class="cm"> *</span>
<span class="cm"> * Either the key must grant the caller Setattr permission or else the caller</span>
<span class="cm"> * must hold an instantiation authorisation token for the key.</span>
<span class="cm"> *</span>
<span class="cm"> * The timeout is either 0 to clear the timeout, or a number of seconds from</span>
<span class="cm"> * the current time.  The key and any links to the key will be automatically</span>
<span class="cm"> * garbage collected after the timeout expires.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 is returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_set_timeout</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">instkey</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">KEY_LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span>
				  <span class="n">KEY_SETATTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* setting the timeout on a key under construction is permitted</span>
<span class="cm">		 * if we have the authorisation token handy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">instkey</span> <span class="o">=</span> <span class="n">key_get_instantiation_authkey</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">instkey</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">key_put</span><span class="p">(</span><span class="n">instkey</span><span class="p">);</span>
				<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span>
							  <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span>
							  <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">okay</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">okay:</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="n">key_set_timeout</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assume (or clear) the authority to instantiate the specified key.</span>
<span class="cm"> *</span>
<span class="cm"> * This sets the authoritative token currently in force for key instantiation.</span>
<span class="cm"> * This must be done for a key to be instantiated.  It has the effect of making</span>
<span class="cm"> * available all the keys from the caller of the request_key() that created a</span>
<span class="cm"> * key to request_key() calls made by the caller of this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the instantiation key in their process keyrings with a</span>
<span class="cm"> * Search permission grant available to the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * If the ID given is 0, then the setting will be cleared and 0 returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If the ID given has a matching an authorisation key, then that key will be</span>
<span class="cm"> * set and its ID will be returned.  The authorisation key can be read to get</span>
<span class="cm"> * the callout information passed to request_key().</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_assume_authority</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">authkey</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* special key IDs aren&#39;t permitted */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* we divest ourselves of authority if given an ID of 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">keyctl_change_reqkey_auth</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* attempt to assume the authority temporarily granted to us whilst we</span>
<span class="cm">	 * instantiate the specified key</span>
<span class="cm">	 * - the authorisation key must be in the current task&#39;s keyrings</span>
<span class="cm">	 *   somewhere</span>
<span class="cm">	 */</span>
	<span class="n">authkey</span> <span class="o">=</span> <span class="n">key_get_instantiation_authkey</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">keyctl_change_reqkey_auth</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">authkey</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a key&#39;s the LSM security label.</span>
<span class="cm"> *</span>
<span class="cm"> * The key must grant the caller View permission for this to work.</span>
<span class="cm"> *</span>
<span class="cm"> * If there&#39;s a buffer, then up to buflen bytes of data will be placed into it.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the amount of information available will be returned,</span>
<span class="cm"> * irrespective of how much was copied (including the terminal NUL).</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_get_security</span><span class="p">(</span><span class="n">key_serial_t</span> <span class="n">keyid</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">instkey</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">keyid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span> <span class="n">KEY_VIEW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>

		<span class="cm">/* viewing a key under construction is also permitted if we</span>
<span class="cm">		 * have the authorisation token handy */</span>
		<span class="n">instkey</span> <span class="o">=</span> <span class="n">key_get_instantiation_authkey</span><span class="p">(</span><span class="n">keyid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">instkey</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">instkey</span><span class="p">);</span>
		<span class="n">key_put</span><span class="p">(</span><span class="n">instkey</span><span class="p">);</span>

		<span class="n">key_ref</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">keyid</span><span class="p">,</span> <span class="n">KEY_LOOKUP_PARTIAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_key_getsecurity</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if no information was returned, give userspace an empty</span>
<span class="cm">		 * string */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;&amp;</span> <span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* return as much data as there&#39;s room for */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;&amp;</span> <span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">)</span>
				<span class="n">buflen</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">buflen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">key_ref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to install the calling process&#39;s session keyring on the process&#39;s</span>
<span class="cm"> * parent process.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring must exist and must grant the caller LINK permission, and the</span>
<span class="cm"> * parent process must be single-threaded and must have the same effective</span>
<span class="cm"> * ownership as this process and mustn&#39;t be SUID/SGID.</span>
<span class="cm"> *</span>
<span class="cm"> * The keyring will be emplaced on the parent when it next resumes userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, 0 will be returned.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">keyctl_session_to_parent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">mycred</span><span class="p">,</span> <span class="o">*</span><span class="n">pcred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_work</span> <span class="o">*</span><span class="n">newwork</span><span class="p">,</span> <span class="o">*</span><span class="n">oldwork</span><span class="p">;</span>
	<span class="n">key_ref_t</span> <span class="n">keyring_r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">keyring_r</span> <span class="o">=</span> <span class="n">lookup_user_key</span><span class="p">(</span><span class="n">KEY_SPEC_SESSION_KEYRING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_LINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">keyring_r</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">keyring_r</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">newwork</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_work</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newwork</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_keyring</span><span class="p">;</span>

	<span class="cm">/* our parent is going to need a new cred struct, a new tgcred struct</span>
<span class="cm">	 * and new security data, so we allocate them here to prevent ENOMEM in</span>
<span class="cm">	 * our parent */</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="n">cred_alloc_blank</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cred</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_newwork</span><span class="p">;</span>

	<span class="n">cred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span> <span class="o">=</span> <span class="n">key_ref_to_ptr</span><span class="p">(</span><span class="n">keyring_r</span><span class="p">);</span>
	<span class="n">init_task_work</span><span class="p">(</span><span class="n">newwork</span><span class="p">,</span> <span class="n">key_change_session_keyring</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">oldwork</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>

	<span class="cm">/* the parent mustn&#39;t be init and mustn&#39;t be a kernel thread */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* the parent must be single threaded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* the parent and the child must have different session keyrings or</span>
<span class="cm">	 * there&#39;s no point */</span>
	<span class="n">mycred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="n">pcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mycred</span> <span class="o">==</span> <span class="n">pcred</span> <span class="o">||</span>
	    <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span> <span class="o">==</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the parent must have the same effective ownership and mustn&#39;t be</span>
<span class="cm">	 * SUID/SGID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcred</span><span class="o">-&gt;</span><span class="n">uid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">euid</span>	<span class="o">||</span>
	    <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">euid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">euid</span>	<span class="o">||</span>
	    <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">suid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">euid</span>	<span class="o">||</span>
	    <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">gid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">egid</span>	<span class="o">||</span>
	    <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">egid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">egid</span>	<span class="o">||</span>
	    <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">sgid</span>	<span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* the keyrings must have the same UID */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pcred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span> <span class="o">&amp;&amp;</span>
	     <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">tgcred</span><span class="o">-&gt;</span><span class="n">session_keyring</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">mycred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* cancel an already pending keyring replacement */</span>
	<span class="n">oldwork</span> <span class="o">=</span> <span class="n">task_work_cancel</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">key_change_session_keyring</span><span class="p">);</span>

	<span class="cm">/* the replacement session keyring is applied just prior to userspace</span>
<span class="cm">	 * restarting */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">task_work_add</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">newwork</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">newwork</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldwork</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">oldwork</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">oldwork</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newwork</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">newwork</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">newwork</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">error_newwork:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">newwork</span><span class="p">);</span>
<span class="nl">error_keyring:</span>
	<span class="n">key_ref_put</span><span class="p">(</span><span class="n">keyring_r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The key control system call</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">keyctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KEYCTL_GET_KEYRING_ID</span>:
		<span class="k">return</span> <span class="n">keyctl_get_keyring_ID</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg3</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_JOIN_SESSION_KEYRING</span>:
		<span class="k">return</span> <span class="n">keyctl_join_session_keyring</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_UPDATE</span>:
		<span class="k">return</span> <span class="n">keyctl_update_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					 <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_REVOKE</span>:
		<span class="k">return</span> <span class="n">keyctl_revoke_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_DESCRIBE</span>:
		<span class="k">return</span> <span class="n">keyctl_describe_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_CLEAR</span>:
		<span class="k">return</span> <span class="n">keyctl_keyring_clear</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_LINK</span>:
		<span class="k">return</span> <span class="n">keyctl_keyring_link</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg3</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_UNLINK</span>:
		<span class="k">return</span> <span class="n">keyctl_keyring_unlink</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg3</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_SEARCH</span>:
		<span class="k">return</span> <span class="n">keyctl_keyring_search</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					     <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					     <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg4</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg5</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_READ</span>:
		<span class="k">return</span> <span class="n">keyctl_read_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_CHOWN</span>:
		<span class="k">return</span> <span class="n">keyctl_chown_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					<span class="p">(</span><span class="n">uid_t</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					<span class="p">(</span><span class="n">gid_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_SETPERM</span>:
		<span class="k">return</span> <span class="n">keyctl_setperm_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">key_perm_t</span><span class="p">)</span> <span class="n">arg3</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_INSTANTIATE</span>:
		<span class="k">return</span> <span class="n">keyctl_instantiate_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					      <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg5</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_NEGATE</span>:
		<span class="k">return</span> <span class="n">keyctl_negate_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_SET_REQKEY_KEYRING</span>:
		<span class="k">return</span> <span class="n">keyctl_set_reqkey_keyring</span><span class="p">(</span><span class="n">arg2</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_SET_TIMEOUT</span>:
		<span class="k">return</span> <span class="n">keyctl_set_timeout</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg3</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_ASSUME_AUTHORITY</span>:
		<span class="k">return</span> <span class="n">keyctl_assume_authority</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_GET_SECURITY</span>:
		<span class="k">return</span> <span class="n">keyctl_get_security</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">arg4</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_SESSION_TO_PARENT</span>:
		<span class="k">return</span> <span class="n">keyctl_session_to_parent</span><span class="p">();</span>

	<span class="k">case</span> <span class="n">KEYCTL_REJECT</span>:
		<span class="k">return</span> <span class="n">keyctl_reject_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg4</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg5</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_INSTANTIATE_IOV</span>:
		<span class="k">return</span> <span class="n">keyctl_instantiate_key_iov</span><span class="p">(</span>
			<span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">,</span>
			<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg3</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">arg4</span><span class="p">,</span>
			<span class="p">(</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg5</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">KEYCTL_INVALIDATE</span>:
		<span class="k">return</span> <span class="n">keyctl_invalidate_key</span><span class="p">((</span><span class="n">key_serial_t</span><span class="p">)</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
