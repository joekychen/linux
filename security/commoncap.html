<!DOCTYPE html>
<html><head><title>joekychen/linux » security › commoncap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>commoncap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Common capabilities, needed by capability.o.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/prctl.h&gt;</span>
<span class="cp">#include &lt;linux/securebits.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * If a non-root user executes a setuid-root binary in</span>
<span class="cm"> * !secure(SECURE_NOROOT) mode, then we raise capabilities.</span>
<span class="cm"> * However if fE is also set, then the intent is for only</span>
<span class="cm"> * the file capabilities to be applied, and the setuid-root</span>
<span class="cm"> * bit is left on either to change the uid (plausible) or</span>
<span class="cm"> * to get full privilege on a kernel without file capabilities</span>
<span class="cm"> * support.  So in that case we do not raise capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * Warn if that happens, once per boot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_setuid_and_fcaps_mixed</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">warned</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;warning: `%s&#39; has both setuid-root and&quot;</span>
			<span class="s">&quot; effective capabilities. Therefore not raising all&quot;</span>
			<span class="s">&quot; capabilities.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
		<span class="n">warned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cap_netlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_capable - Determine whether a task has a particular effective capability</span>
<span class="cm"> * @cred: The credentials to use</span>
<span class="cm"> * @ns:  The user namespace in which we need the capability</span>
<span class="cm"> * @cap: The capability to check for</span>
<span class="cm"> * @audit: Whether to write an audit message or not</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether the nominated task has the specified capability amongst</span>
<span class="cm"> * its effective set, returning 0 if it does, -ve if it does not.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE WELL: cap_has_capability() cannot be used like the kernel&#39;s capable()</span>
<span class="cm"> * and has_capability() functions.  That is, it has the reverse semantics:</span>
<span class="cm"> * cap_has_capability() returns 0 when a task has a capability, but the</span>
<span class="cm"> * kernel&#39;s capable() and has_capability() returns 1 for this case.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">targ_ns</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* The owner of the user namespace has all caps. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targ_ns</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_user_ns</span> <span class="o">&amp;&amp;</span> <span class="n">uid_eq</span><span class="p">(</span><span class="n">targ_ns</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Do we have the necessary capabilities? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targ_ns</span> <span class="o">==</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cap_raised</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">,</span> <span class="n">cap</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="cm">/* Have we tried all of the parent namespaces? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targ_ns</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *If you have a capability in a parent user ns, then you have</span>
<span class="cm">		 * it over all children user namespaces as well.</span>
<span class="cm">		 */</span>
		<span class="n">targ_ns</span> <span class="o">=</span> <span class="n">targ_ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We never get here */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_settime - Determine whether the current process may set the system clock</span>
<span class="cm"> * @ts: The time to set</span>
<span class="cm"> * @tz: The timezone to set</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether the current process may set the system clock and timezone</span>
<span class="cm"> * information, returning 0 if permission granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_settime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_ptrace_access_check - Determine whether the current process may access</span>
<span class="cm"> *			   another</span>
<span class="cm"> * @child: The process to be accessed</span>
<span class="cm"> * @mode: The mode of attachment.</span>
<span class="cm"> *</span>
<span class="cm"> * If we are in the same or an ancestor user_ns and have all the target</span>
<span class="cm"> * task&#39;s capabilities, then ptrace access is allowed.</span>
<span class="cm"> * If we have the ptrace capability to the target user_ns, then ptrace</span>
<span class="cm"> * access is allowed.</span>
<span class="cm"> * Else denied.</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether a process may access another, returning 0 if permission</span>
<span class="cm"> * granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="o">*</span><span class="n">child_cred</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="n">child_cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">==</span> <span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cap_issubset</span><span class="p">(</span><span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_PTRACE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_ptrace_traceme - Determine whether another process may trace the current</span>
<span class="cm"> * @parent: The task proposed to be the tracer</span>
<span class="cm"> *</span>
<span class="cm"> * If parent is in the same or an ancestor user_ns and has all current&#39;s</span>
<span class="cm"> * capabilities, then ptrace access is allowed.</span>
<span class="cm"> * If parent has the ptrace capability to current&#39;s user_ns, then ptrace</span>
<span class="cm"> * access is allowed.</span>
<span class="cm"> * Else denied.</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether the nominated task is permitted to trace the current</span>
<span class="cm"> * process, returning 0 if permission is granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="o">*</span><span class="n">child_cred</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">child_cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">==</span> <span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cap_issubset</span><span class="p">(</span><span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_ns_capability</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child_cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_PTRACE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_capget - Retrieve a task&#39;s capability sets</span>
<span class="cm"> * @target: The task from which to retrieve the capability sets</span>
<span class="cm"> * @effective: The place to record the effective set</span>
<span class="cm"> * @inheritable: The place to record the inheritable set</span>
<span class="cm"> * @permitted: The place to record the permitted set</span>
<span class="cm"> *</span>
<span class="cm"> * This function retrieves the capabilities of the nominated task and returns</span>
<span class="cm"> * them to the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_capget</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
	       <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>

	<span class="cm">/* Derived from kernel/capability.c:sys_capget. */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="o">*</span><span class="n">effective</span>   <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">;</span>
	<span class="o">*</span><span class="n">inheritable</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span><span class="p">;</span>
	<span class="o">*</span><span class="n">permitted</span>   <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether the inheritable capabilities are limited to the old</span>
<span class="cm"> * permitted set.  Returns 1 if they are limited, 0 if they are not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cap_inh_is_capped</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* they are so limited unless the current task has the CAP_SETPCAP</span>
<span class="cm">	 * capability</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span> <span class="n">current_cred</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span>
			<span class="n">CAP_SETPCAP</span><span class="p">,</span> <span class="n">SECURITY_CAP_AUDIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_capset - Validate and apply proposed changes to current&#39;s capabilities</span>
<span class="cm"> * @new: The proposed new credentials; alterations should be made here</span>
<span class="cm"> * @old: The current task&#39;s current credentials</span>
<span class="cm"> * @effective: A pointer to the proposed new effective capabilities set</span>
<span class="cm"> * @inheritable: A pointer to the proposed new inheritable capabilities set</span>
<span class="cm"> * @permitted: A pointer to the proposed new permitted capabilities set</span>
<span class="cm"> *</span>
<span class="cm"> * This function validates and applies a proposed mass change to the current</span>
<span class="cm"> * process&#39;s capability sets.  The changes are made to the proposed new</span>
<span class="cm"> * credentials, and assuming no error, will be committed by the caller of LSM.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_capset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
	       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
	       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
	       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_inh_is_capped</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
			  <span class="n">cap_combine</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span><span class="p">,</span>
				      <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">)))</span>
		<span class="cm">/* incapable of using this inheritable set */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
			  <span class="n">cap_combine</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span><span class="p">,</span>
				      <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_bset</span><span class="p">)))</span>
		<span class="cm">/* no new pI capabilities outside bounding set */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* verify restrictions on target&#39;s new Permitted set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="o">*</span><span class="n">permitted</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* verify the _new_Effective_ is a subset of the _new_Permitted_ */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="o">*</span><span class="n">effective</span><span class="p">,</span> <span class="o">*</span><span class="n">permitted</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span>   <span class="o">=</span> <span class="o">*</span><span class="n">effective</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span> <span class="o">=</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span>   <span class="o">=</span> <span class="o">*</span><span class="n">permitted</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear proposed capability sets for execve().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bprm_clear_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cap_clear</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">);</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_inode_need_killpriv - Determine if inode change affects privileges</span>
<span class="cm"> * @dentry: The inode/dentry in being changed with change marked ATTR_KILL_PRIV</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if an inode having a change applied that&#39;s marked ATTR_KILL_PRIV</span>
<span class="cm"> * affects the security markings on that inode, and if it is, should</span>
<span class="cm"> * inode_killpriv() be invoked or the change rejected?</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if granted; +ve if granted, but inode_killpriv() is required; and</span>
<span class="cm"> * -ve to deny the change.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_inode_need_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">)</span>
	       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_inode_killpriv - Erase the security markings on an inode</span>
<span class="cm"> * @dentry: The inode/dentry to alter</span>
<span class="cm"> *</span>
<span class="cm"> * Erase the privilege-enhancing security markings on an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, -ve on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_inode_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">removexattr</span><span class="p">)</span>
	       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">removexattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the new process capability sets from the capability sets attached</span>
<span class="cm"> * to a file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bprm_caps_from_vfs_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span> <span class="o">*</span><span class="n">caps</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
					  <span class="n">bool</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
					  <span class="n">bool</span> <span class="o">*</span><span class="n">has_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">magic_etc</span> <span class="o">&amp;</span> <span class="n">VFS_CAP_FLAGS_EFFECTIVE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">effective</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">magic_etc</span> <span class="o">&amp;</span> <span class="n">VFS_CAP_REVISION_MASK</span><span class="p">)</span>
		<span class="o">*</span><span class="n">has_cap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">CAP_FOR_EACH_U32</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u32</span> <span class="n">permitted</span> <span class="o">=</span> <span class="n">caps</span><span class="o">-&gt;</span><span class="n">permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">__u32</span> <span class="n">inheritable</span> <span class="o">=</span> <span class="n">caps</span><span class="o">-&gt;</span><span class="n">inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * pP&#39; = (X &amp; fP) | (pI &amp; fI)</span>
<span class="cm">		 */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_bset</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">permitted</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">inheritable</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">permitted</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="cm">/* insufficient to execute correctly */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For legacy apps, with no internal support for recognizing they</span>
<span class="cm">	 * do not have enough capabilities, we return an error if they are</span>
<span class="cm">	 * missing some &quot;forced&quot; (aka file-permitted) capabilities.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">effective</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Extract the on-exec-apply capability sets for an executable file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_vfs_caps_from_disk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span> <span class="o">*</span><span class="n">cpu_caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">magic_etc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tocopy</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfs_cap_data</span> <span class="n">caps</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cpu_caps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span> <span class="o">||</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">((</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">,</span>
				   <span class="n">XATTR_CAPS_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
		<span class="cm">/* no data, that&#39;s ok */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">magic_etc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpu_caps</span><span class="o">-&gt;</span><span class="n">magic_etc</span> <span class="o">=</span> <span class="n">magic_etc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">magic_etc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">magic_etc</span> <span class="o">&amp;</span> <span class="n">VFS_CAP_REVISION_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VFS_CAP_REVISION_1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">XATTR_CAPS_SZ_1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">tocopy</span> <span class="o">=</span> <span class="n">VFS_CAP_U32_1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VFS_CAP_REVISION_2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">XATTR_CAPS_SZ_2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">tocopy</span> <span class="o">=</span> <span class="n">VFS_CAP_U32_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">CAP_FOR_EACH_U32</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">tocopy</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_caps</span><span class="o">-&gt;</span><span class="n">permitted</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">permitted</span><span class="p">);</span>
		<span class="n">cpu_caps</span><span class="o">-&gt;</span><span class="n">inheritable</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inheritable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to get the on-exec apply capability sets for an executable file from</span>
<span class="cm"> * its xattrs and, if present, apply them to the proposed credentials being</span>
<span class="cm"> * constructed by execve().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_file_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">has_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span> <span class="n">vcaps</span><span class="p">;</span>

	<span class="n">bprm_clear_caps</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_caps_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_vfsmnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOSUID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">get_vfs_caps_from_disk</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcaps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: get_vfs_caps_from_disk returned %d for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">bprm_caps_from_vfs_caps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcaps</span><span class="p">,</span> <span class="n">bprm</span><span class="p">,</span> <span class="n">effective</span><span class="p">,</span> <span class="n">has_cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: cap_from_disk returned %d for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">bprm_clear_caps</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_bprm_set_creds - Set up the proposed credentials for execve().</span>
<span class="cm"> * @bprm: The execution parameters, including the proposed creds</span>
<span class="cm"> *</span>
<span class="cm"> * Set up the proposed credentials for a new execution context being</span>
<span class="cm"> * constructed by execve().  The proposed creds in @bprm-&gt;cred is altered,</span>
<span class="cm"> * which won&#39;t take effect immediately.  Returns 0 if successful, -ve on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">effective</span><span class="p">,</span> <span class="n">has_cap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">root_uid</span><span class="p">;</span>

	<span class="n">effective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_file_caps</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">effective</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">has_cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">root_uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_NOROOT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the legacy file capability is set, then don&#39;t set privs</span>
<span class="cm">		 * for a setuid root binary run by a non-root user.  Do set it</span>
<span class="cm">		 * for a root user just to cause least surprise to an admin.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_cap</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">warn_setuid_and_fcaps_mixed</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * To support inheritance of root-permissions and suid-root</span>
<span class="cm">		 * executables under compatibility mode, we override the</span>
<span class="cm">		 * capability sets for the file.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If only the real uid is 0, we do not set the effective bit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">||</span> <span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* pP&#39; = (cap_bset &amp; ~0) | (pI &amp; ~0) */</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span> <span class="o">=</span> <span class="n">cap_combine</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_bset</span><span class="p">,</span>
							 <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span>
			<span class="n">effective</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">skip:</span>

	<span class="cm">/* if we have fs caps, clear dangerous personality flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>


	<span class="cm">/* Don&#39;t let someone trace a set[ug]id/setpcap binary with the revised</span>
<span class="cm">	 * credentials unless they have the appropriate permit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LSM_UNSAFE_PTRACE_CAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* downgrade; they get no more than they had, and maybe less */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETUID</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">&amp;</span> <span class="n">LSM_UNSAFE_NO_NEW_PRIVS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span> <span class="o">=</span> <span class="n">cap_intersect</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span>
						   <span class="n">old</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">suid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">fsuid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">sgid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">fsgid</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">effective</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cap_clear</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">);</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">effective</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Audit candidate if current-&gt;cap_effective is set</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not bother to audit if 3 things are true:</span>
<span class="cm">	 *   1) cap_effective has all caps</span>
<span class="cm">	 *   2) we are root</span>
<span class="cm">	 *   3) root is supposed to have all caps (SECURE_NOROOT)</span>
<span class="cm">	 * Since this is just a normal root execing a process.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Number 1 above might fail if you don&#39;t have a full bset, but I think</span>
<span class="cm">	 * that is interesting information to audit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_isclear</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_issubset</span><span class="p">(</span><span class="n">CAP_FULL_SET</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_NOROOT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">audit_log_bprm_fcaps</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">issecure_mask</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_bprm_secureexec - Determine whether a secure execution is required</span>
<span class="cm"> * @bprm: The execution parameters</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether a secure execution is required, return 1 if it is, and 0</span>
<span class="cm"> * if it is not.</span>
<span class="cm"> *</span>
<span class="cm"> * The credentials have been committed by this point, and so are no longer</span>
<span class="cm"> * available through @bprm-&gt;cred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="n">kuid_t</span> <span class="n">root_uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_isclear</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_inode_setxattr - Determine whether an xattr may be altered</span>
<span class="cm"> * @dentry: The inode/dentry being altered</span>
<span class="cm"> * @name: The name of the xattr to be changed</span>
<span class="cm"> * @value: The value that the xattr will be changed to</span>
<span class="cm"> * @size: The size of value</span>
<span class="cm"> * @flags: The replacement flag</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether an xattr may be altered or set on an inode, returning 0 if</span>
<span class="cm"> * permission is granted, -ve if denied.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to make sure security xattrs don&#39;t get updated or set by those</span>
<span class="cm"> * who aren&#39;t privileged to do so.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETFCAP</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SECURITY_PREFIX</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">XATTR_SECURITY_PREFIX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_inode_removexattr - Determine whether an xattr may be removed</span>
<span class="cm"> * @dentry: The inode/dentry being altered</span>
<span class="cm"> * @name: The name of the xattr to be changed</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether an xattr may be removed from an inode, returning 0 if</span>
<span class="cm"> * permission is granted, -ve if denied.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to make sure security xattrs don&#39;t get removed by those who</span>
<span class="cm"> * aren&#39;t privileged to remove them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_NAME_CAPS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETFCAP</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SECURITY_PREFIX</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">XATTR_SECURITY_PREFIX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cap_emulate_setxuid() fixes the effective / permitted capabilities of</span>
<span class="cm"> * a process after a call to setuid, setreuid, or setresuid.</span>
<span class="cm"> *</span>
<span class="cm"> *  1) When set*uiding _from_ one of {r,e,s}uid == 0 _to_ all of</span>
<span class="cm"> *  {r,e,s}uid != 0, the permitted and effective capabilities are</span>
<span class="cm"> *  cleared.</span>
<span class="cm"> *</span>
<span class="cm"> *  2) When set*uiding _from_ euid == 0 _to_ euid != 0, the effective</span>
<span class="cm"> *  capabilities of the process are cleared.</span>
<span class="cm"> *</span>
<span class="cm"> *  3) When set*uiding _from_ euid != 0 _to_ euid == 0, the effective</span>
<span class="cm"> *  capabilities are set to the permitted capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> *  fsuid is handled elsewhere. fsuid == 0 and {r,e,s}uid!= 0 should</span>
<span class="cm"> *  never happen.</span>
<span class="cm"> *</span>
<span class="cm"> *  -astor</span>
<span class="cm"> *</span>
<span class="cm"> * cevans - New behaviour, Oct &#39;99</span>
<span class="cm"> * A process may, via prctl(), elect to keep its capabilities when it</span>
<span class="cm"> * calls setuid() and switches away from uid==0. Both permitted and</span>
<span class="cm"> * effective sets will be retained.</span>
<span class="cm"> * Without this change, it was impossible for a daemon to drop only some</span>
<span class="cm"> * of its privilege. The call to setuid(!=0) would drop all privileges!</span>
<span class="cm"> * Keeping uid 0 is not an option because uid 0 owns too many vital</span>
<span class="cm"> * files..</span>
<span class="cm"> * Thanks to Olaf Kirch and Peter Benie for spotting this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cap_emulate_setxuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kuid_t</span> <span class="n">root_uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap_clear</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">);</span>
		<span class="n">cap_clear</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span>
		<span class="n">cap_clear</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_task_fix_setuid - Fix up the results of setuid() call</span>
<span class="cm"> * @new: The proposed credentials</span>
<span class="cm"> * @old: The current task&#39;s current credentials</span>
<span class="cm"> * @flags: Indications of what has changed</span>
<span class="cm"> *</span>
<span class="cm"> * Fix up the results of setuid() call before the credential changes are</span>
<span class="cm"> * actually applied, returning 0 to grant the changes, -ve to deny them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_task_fix_setuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LSM_SETID_RE</span>:
	<span class="k">case</span> <span class="n">LSM_SETID_ID</span>:
	<span class="k">case</span> <span class="n">LSM_SETID_RES</span>:
		<span class="cm">/* juggle the capabilities to follow [RES]UID changes unless</span>
<span class="cm">		 * otherwise suppressed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_NO_SETUID_FIXUP</span><span class="p">))</span>
			<span class="n">cap_emulate_setxuid</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LSM_SETID_FS</span>:
		<span class="cm">/* juggle the capabilties to follow FSUID changes, unless</span>
<span class="cm">		 * otherwise suppressed</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME - is fsuser used for all CAP_FS_MASK capabilities?</span>
<span class="cm">		 *          if not, we might be a bit too harsh here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_NO_SETUID_FIXUP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kuid_t</span> <span class="n">root_uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span>
					<span class="n">cap_drop_fs_set</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uid_eq</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">,</span> <span class="n">root_uid</span><span class="p">))</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span>
					<span class="n">cap_raise_fs_set</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span><span class="p">,</span>
							 <span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rationale: code calling task_setscheduler, task_setioprio, and</span>
<span class="cm"> * task_setnice, assumes that</span>
<span class="cm"> *   . if capable(cap_sys_nice), then those actions should be allowed</span>
<span class="cm"> *   . if not capable(cap_sys_nice), but acting on your own processes,</span>
<span class="cm"> *   	then those actions should be allowed</span>
<span class="cm"> * This is insufficient now since you can call code without suid, but</span>
<span class="cm"> * yet with increased caps.</span>
<span class="cm"> * So we check for increased caps on the target process.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_safe_nice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_subset</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">is_subset</span> <span class="o">=</span> <span class="n">cap_issubset</span><span class="p">(</span><span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">,</span>
				 <span class="n">current_cred</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cap_permitted</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_subset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_task_setscheduler - Detemine if scheduler policy change is permitted</span>
<span class="cm"> * @p: The task to affect</span>
<span class="cm"> *</span>
<span class="cm"> * Detemine if the requested scheduler policy change is permitted for the</span>
<span class="cm"> * specified task, returning 0 if permission is granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_safe_nice</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_task_ioprio - Detemine if I/O priority change is permitted</span>
<span class="cm"> * @p: The task to affect</span>
<span class="cm"> * @ioprio: The I/O priority to set</span>
<span class="cm"> *</span>
<span class="cm"> * Detemine if the requested I/O priority change is permitted for the specified</span>
<span class="cm"> * task, returning 0 if permission is granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_safe_nice</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_task_ioprio - Detemine if task priority change is permitted</span>
<span class="cm"> * @p: The task to affect</span>
<span class="cm"> * @nice: The nice value to set</span>
<span class="cm"> *</span>
<span class="cm"> * Detemine if the requested task priority change is permitted for the</span>
<span class="cm"> * specified task, returning 0 if permission is granted, -ve if denied.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_safe_nice</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implement PR_CAPBSET_DROP.  Attempt to remove the specified capability from</span>
<span class="cm"> * the current task&#39;s bounding set.  Returns 0 on success, -ve on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">cap_prctl_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETPCAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cap_lower</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_bset</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_task_prctl - Implement process control functions for this security module</span>
<span class="cm"> * @option: The process control function requested</span>
<span class="cm"> * @arg2, @arg3, @arg4, @arg5: The argument data for this function</span>
<span class="cm"> *</span>
<span class="cm"> * Allow process control functions (sys_prctl()) to alter capabilities; may</span>
<span class="cm"> * also deny access to other functions not otherwise implemented here.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or +ve on success, -ENOSYS if this function is not implemented</span>
<span class="cm"> * here, other -ve on error.  If -ENOSYS is returned, sys_prctl() and other LSM</span>
<span class="cm"> * modules will consider performing the function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_task_prctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PR_CAPBSET_READ</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_valid</span><span class="p">(</span><span class="n">arg2</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">!!</span><span class="n">cap_raised</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_bset</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PR_CAPBSET_DROP</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">cap_prctl_drop</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">changed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next four prctl&#39;s remain to assist with transitioning a</span>
<span class="cm">	 * system from legacy UID=0 based privilege (when filesystem</span>
<span class="cm">	 * capabilities are not in use) to a system using filesystem</span>
<span class="cm">	 * capabilities only - as the POSIX.1e draft intended.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  PR_SET_SECUREBITS =</span>
<span class="cm">	 *      issecure_mask(SECURE_KEEP_CAPS_LOCKED)</span>
<span class="cm">	 *    | issecure_mask(SECURE_NOROOT)</span>
<span class="cm">	 *    | issecure_mask(SECURE_NOROOT_LOCKED)</span>
<span class="cm">	 *    | issecure_mask(SECURE_NO_SETUID_FIXUP)</span>
<span class="cm">	 *    | issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED)</span>
<span class="cm">	 *</span>
<span class="cm">	 * will ensure that the current process and all of its</span>
<span class="cm">	 * children will be locked into a pure</span>
<span class="cm">	 * capability-based-privilege environment.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">PR_SET_SECUREBITS</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((((</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">&amp;</span> <span class="n">SECURE_ALL_LOCKS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
		     <span class="o">&amp;</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">^</span> <span class="n">arg2</span><span class="p">))</span>			<span class="cm">/*[1]*/</span>
		    <span class="o">||</span> <span class="p">((</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">&amp;</span> <span class="n">SECURE_ALL_LOCKS</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">arg2</span><span class="p">))</span>	<span class="cm">/*[2]*/</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">arg2</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SECURE_ALL_LOCKS</span> <span class="o">|</span> <span class="n">SECURE_ALL_BITS</span><span class="p">))</span>	<span class="cm">/*[3]*/</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">cap_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span>
				    <span class="n">current_cred</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">CAP_SETPCAP</span><span class="p">,</span>
				    <span class="n">SECURITY_CAP_AUDIT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>		<span class="cm">/*[4]*/</span>
			<span class="cm">/*</span>
<span class="cm">			 * [1] no changing of bits that are locked</span>
<span class="cm">			 * [2] no unlocking of locks</span>
<span class="cm">			 * [3] no setting of unsupported bits</span>
<span class="cm">			 * [4] doing anything requires privilege (go read about</span>
<span class="cm">			 *     the &quot;sendmail capabilities bug&quot;)</span>
<span class="cm">			 */</span>
		    <span class="p">)</span>
			<span class="cm">/* cannot change a locked bit */</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">changed</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PR_GET_SECUREBITS</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PR_GET_KEEPCAPS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PR_SET_KEEPCAPS</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* Note, we rely on arg2 being unsigned here */</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issecure</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS_LOCKED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg2</span><span class="p">)</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">|=</span> <span class="n">issecure_mask</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">issecure_mask</span><span class="p">(</span><span class="n">SECURE_KEEP_CAPS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">changed</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* No functionality available - continue with default */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Functionality provided */</span>
<span class="nl">changed:</span>
	<span class="k">return</span> <span class="n">commit_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

<span class="nl">no_change:</span>
<span class="nl">error:</span>
	<span class="n">abort_creds</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cap_vm_enough_memory - Determine whether a new virtual mapping is permitted</span>
<span class="cm"> * @mm: The VM space in which the new mapping is to be made</span>
<span class="cm"> * @pages: The size of the mapping</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether the allocation of a new virtual mapping by the current</span>
<span class="cm"> * task is permitted, returning 0 if permission is granted, -ve if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap_sys_admin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">,</span>
			<span class="n">SECURITY_CAP_NOAUDIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cap_sys_admin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__vm_enough_memory</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">cap_sys_admin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cap_mmap_addr - check if able to map given addr</span>
<span class="cm"> * @addr: address attempting to be mapped</span>
<span class="cm"> *</span>
<span class="cm"> * If the process is attempting to map memory below dac_mmap_min_addr they need</span>
<span class="cm"> * CAP_SYS_RAWIO.  The other parameters to this function are unused by the</span>
<span class="cm"> * capability security module.  Returns 0 if this mapping should be allowed</span>
<span class="cm"> * -EPERM if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cap_mmap_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">dac_mmap_min_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cap_capable</span><span class="p">(</span><span class="n">current_cred</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_RAWIO</span><span class="p">,</span>
				  <span class="n">SECURITY_CAP_AUDIT</span><span class="p">);</span>
		<span class="cm">/* set PF_SUPERPRIV if it turns out we allow the low mmap */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SUPERPRIV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cap_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
