<!DOCTYPE html>
<html><head><title>joekychen/linux » security › capability.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>capability.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Capabilities Linux Security Module</span>
<span class="cm"> *</span>
<span class="cm"> *  This is the default security module in case no other module is loaded.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/security.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_quotactl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_quota_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_bprm_check_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_bprm_committing_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_bprm_committed_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sb_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_copy_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_pivotroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_set_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sb_clone_mnt_opts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">oldsb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">newsb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sb_parse_opts_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_inode_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="n">umode_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			   <span class="n">umode_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			   <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nameidata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_inode_post_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_getsecurity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bool</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_setsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_listsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_inode_getsecid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SECURITY_PATH</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_chmod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_chown</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_path_chroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_file_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_mprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_fcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_set_fowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_send_sigiotask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_task_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_cred_alloc_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_cred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_cred_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_cred_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_kernel_act_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_kernel_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_kernel_module_request</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kmod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_setpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_getpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_getsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_task_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_getioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_setrlimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_rlim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_getscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_movememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_task_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_task_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_ipc_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="kt">short</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_ipc_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_msg_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_msg_msg_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_queue_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_msg_queue_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_queue_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_queue_msgctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_queue_msgsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">msgflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_msg_queue_msgrcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_shm_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_shm_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_shm_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_shm_shmctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_shm_shmat</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sem_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sem_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sem_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sem_semctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sem_semop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_getsockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_getpeername</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_sock_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_getpeersec_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_socket_getpeersec_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_sk_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sk_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sk_clone_security</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sk_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inet_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_inet_csk_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_inet_conn_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_secmark_relabel_packet</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_secmark_refcount_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_secmark_refcount_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_req_classify_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_tun_dev_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_tun_dev_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_tun_dev_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_policy_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">ctxp</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_policy_clone_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">old_ctx</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">new_ctxp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_xfrm_policy_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_policy_delete_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_state_alloc_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_xfrm_state_free_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_state_delete_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_policy_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sk_sid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_state_pol_flow_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_xfrm_decode_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ckall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SECURITY_NETWORK_XFRM */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_getprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_setprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_secid_to_secctx</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_secctx_to_secid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_release_secctx</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_notifysecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_setsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_inode_getsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_key_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_key_permission</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			      <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_key_getsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_audit_rule_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">lsmrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_audit_rule_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cap_audit_rule_match</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cap_audit_rule_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDIT */</span><span class="cp"></span>

<span class="cp">#define set_to_cap_if_null(ops, function)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (!ops-&gt;function) {					\</span>
<span class="cp">			ops-&gt;function = cap_##function;			\</span>
<span class="cp">			pr_debug(&quot;Had to override the &quot; #function	\</span>
<span class="cp">				 &quot; security operation with the default.\n&quot;);\</span>
<span class="cp">			}						\</span>
<span class="cp">	} while (0)</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">security_fixup_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">ptrace_access_check</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">ptrace_traceme</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">capget</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">capset</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">capable</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">quotactl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">quota_on</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">syslog</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">settime</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">vm_enough_memory</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">bprm_set_creds</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">bprm_committing_creds</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">bprm_committed_creds</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">bprm_check_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">bprm_secureexec</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_copy_data</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_remount</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_kern_mount</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_show_options</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_statfs</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_mount</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_umount</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_pivotroot</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_set_mnt_opts</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_clone_mnt_opts</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sb_parse_opts_str</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_init_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_link</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_unlink</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_symlink</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_mkdir</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_rmdir</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_mknod</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_rename</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_readlink</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_follow_link</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_permission</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_setattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_getattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_setxattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_post_setxattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_getxattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_listxattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_removexattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_need_killpriv</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_killpriv</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_getsecurity</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_setsecurity</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_listsecurity</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_getsecid</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SECURITY_PATH</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_mknod</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_mkdir</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_rmdir</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_unlink</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_symlink</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_link</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_rename</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_truncate</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_chmod</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_chown</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">path_chroot</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_permission</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_ioctl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">mmap_addr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">mmap_file</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_mprotect</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_lock</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_fcntl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_set_fowner</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_send_sigiotask</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_receive</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">file_open</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_free</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">cred_alloc_blank</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">cred_free</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">cred_prepare</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">cred_transfer</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">kernel_act_as</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">kernel_create_files_as</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">kernel_module_request</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_fix_setuid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_setpgid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_getpgid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_getsid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_getsecid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_setnice</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_setioprio</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_getioprio</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_setrlimit</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_setscheduler</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_getscheduler</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_movememory</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_wait</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_kill</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_prctl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">task_to_inode</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">ipc_permission</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">ipc_getsecid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_msg_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_msg_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_associate</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_msgctl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_msgsnd</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_queue_msgrcv</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">shm_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">shm_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">shm_associate</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">shm_shmctl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">shm_shmat</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sem_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sem_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sem_associate</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sem_semctl</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sem_semop</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">netlink_send</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">d_instantiate</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">getprocattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">setprocattr</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">secid_to_secctx</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">secctx_to_secid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">release_secctx</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_notifysecctx</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_setsecctx</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inode_getsecctx</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">unix_stream_connect</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">unix_may_send</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_post_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_bind</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_connect</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_listen</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_accept</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_sendmsg</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_recvmsg</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_getsockname</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_getpeername</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_setsockopt</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_getsockopt</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_shutdown</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_sock_rcv_skb</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_getpeersec_stream</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">socket_getpeersec_dgram</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sk_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sk_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sk_clone_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sk_getsecid</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sock_graft</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inet_conn_request</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inet_csk_clone</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">inet_conn_established</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">secmark_relabel_packet</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">secmark_refcount_inc</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">secmark_refcount_dec</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">req_classify_flow</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">tun_dev_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">tun_dev_post_create</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">tun_dev_attach</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_policy_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_policy_clone_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_policy_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_policy_delete_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_state_alloc_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_state_free_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_state_delete_security</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_policy_lookup</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_state_pol_flow_match</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">xfrm_decode_session</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK_XFRM */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">key_alloc</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">key_free</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">key_permission</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">key_getsecurity</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">audit_rule_init</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">audit_rule_known</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">audit_rule_match</span><span class="p">);</span>
	<span class="n">set_to_cap_if_null</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">audit_rule_free</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
