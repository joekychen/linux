<!DOCTYPE html>
<html><head><title>joekychen/linux » crypto › vmac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>vmac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Modified to interface to the Linux kernel</span>
<span class="cm"> * Copyright (c) 2009, Intel Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> */</span>

<span class="cm">/* --------------------------------------------------------------------------</span>
<span class="cm"> * VMAC and VHASH Implementation by Ted Krovetz (tdk@acm.org) and Wei Dai.</span>
<span class="cm"> * This implementation is herby placed in the public domain.</span>
<span class="cm"> * The authors offers no warranty. Use at your own risk.</span>
<span class="cm"> * Please send bug reports to the authors.</span>
<span class="cm"> * Last modified: 17 APR 08, 1700 PDT</span>
<span class="cm"> * ----------------------------------------------------------------------- */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;crypto/scatterwalk.h&gt;</span>
<span class="cp">#include &lt;crypto/vmac.h&gt;</span>
<span class="cp">#include &lt;crypto/internal/hash.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Constants and masks</span>
<span class="cm"> */</span>
<span class="cp">#define UINT64_C(x) x##ULL</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">p64</span>   <span class="o">=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0xfffffffffffffeff</span><span class="p">);</span>  <span class="cm">/* 2^64 - 257 prime  */</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">m62</span>   <span class="o">=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0x3fffffffffffffff</span><span class="p">);</span>  <span class="cm">/* 62-bit mask       */</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">m63</span>   <span class="o">=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0x7fffffffffffffff</span><span class="p">);</span>  <span class="cm">/* 63-bit mask       */</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">m64</span>   <span class="o">=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">);</span>  <span class="cm">/* 64-bit mask       */</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">mpoly</span> <span class="o">=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0x1fffffff1fffffff</span><span class="p">);</span>  <span class="cm">/* Poly key mask     */</span>

<span class="cp">#define pe64_to_cpup le64_to_cpup		</span><span class="cm">/* Prefer little endian */</span><span class="cp"></span>

<span class="cp">#ifdef __LITTLE_ENDIAN</span>
<span class="cp">#define INDEX_HIGH 1</span>
<span class="cp">#define INDEX_LOW 0</span>
<span class="cp">#else</span>
<span class="cp">#define INDEX_HIGH 0</span>
<span class="cp">#define INDEX_LOW 1</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The following routines are used in this implementation. They are</span>
<span class="cm"> * written via macros to simulate zero-overhead call-by-reference.</span>
<span class="cm"> *</span>
<span class="cm"> * MUL64: 64x64-&gt;128-bit multiplication</span>
<span class="cm"> * PMUL64: assumes top bits cleared on inputs</span>
<span class="cm"> * ADD128: 128x128-&gt;128-bit addition</span>
<span class="cm"> */</span>

<span class="cp">#define ADD128(rh, rl, ih, il)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		u64 _il = (il);						\</span>
<span class="cp">		(rl) += (_il);						\</span>
<span class="cp">		if ((rl) &lt; (_il))					\</span>
<span class="cp">			(rh)++;						\</span>
<span class="cp">		(rh) += (ih);						\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define MUL32(i1, i2)	((u64)(u32)(i1)*(u32)(i2))</span>

<span class="cp">#define PMUL64(rh, rl, i1, i2)	</span><span class="cm">/* Assumes m doesn&#39;t overflow */</span><span class="cp">	\</span>
<span class="cp">	do {								\</span>
<span class="cp">		u64 _i1 = (i1), _i2 = (i2);				\</span>
<span class="cp">		u64 m = MUL32(_i1, _i2&gt;&gt;32) + MUL32(_i1&gt;&gt;32, _i2);	\</span>
<span class="cp">		rh = MUL32(_i1&gt;&gt;32, _i2&gt;&gt;32);				\</span>
<span class="cp">		rl = MUL32(_i1, _i2);					\</span>
<span class="cp">		ADD128(rh, rl, (m &gt;&gt; 32), (m &lt;&lt; 32));			\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define MUL64(rh, rl, i1, i2)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		u64 _i1 = (i1), _i2 = (i2);				\</span>
<span class="cp">		u64 m1 = MUL32(_i1, _i2&gt;&gt;32);				\</span>
<span class="cp">		u64 m2 = MUL32(_i1&gt;&gt;32, _i2);				\</span>
<span class="cp">		rh = MUL32(_i1&gt;&gt;32, _i2&gt;&gt;32);				\</span>
<span class="cp">		rl = MUL32(_i1, _i2);					\</span>
<span class="cp">		ADD128(rh, rl, (m1 &gt;&gt; 32), (m1 &lt;&lt; 32));			\</span>
<span class="cp">		ADD128(rh, rl, (m2 &gt;&gt; 32), (m2 &lt;&lt; 32));			\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * For highest performance the L1 NH and L2 polynomial hashes should be</span>
<span class="cm"> * carefully implemented to take advantage of one&#39;s target architecture.</span>
<span class="cm"> * Here these two hash functions are defined multiple time; once for</span>
<span class="cm"> * 64-bit architectures, once for 32-bit SSE2 architectures, and once</span>
<span class="cm"> * for the rest (32-bit) architectures.</span>
<span class="cm"> * For each, nh_16 *must* be defined (works on multiples of 16 bytes).</span>
<span class="cm"> * Optionally, nh_vmac_nhbytes can be defined (for multiples of</span>
<span class="cm"> * VMAC_NHBYTES), and nh_16_2 and nh_vmac_nhbytes_2 (versions that do two</span>
<span class="cm"> * NH computations at once).</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>

<span class="cp">#define nh_16(mp, kp, nw, rh, rl)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		int i; u64 th, tl;					\</span>
<span class="cp">		rh = rl = 0;						\</span>
<span class="cp">		for (i = 0; i &lt; nw; i += 2) {				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+1]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define nh_16_2(mp, kp, nw, rh, rl, rh1, rl1)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		int i; u64 th, tl;					\</span>
<span class="cp">		rh1 = rl1 = rh = rl = 0;				\</span>
<span class="cp">		for (i = 0; i &lt; nw; i += 2) {				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+1]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i+2],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+3]);	\</span>
<span class="cp">			ADD128(rh1, rl1, th, tl);			\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#if (VMAC_NHBYTES &gt;= 64) </span><span class="cm">/* These versions do 64-bytes of message at a time */</span><span class="cp"></span>
<span class="cp">#define nh_vmac_nhbytes(mp, kp, nw, rh, rl)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		int i; u64 th, tl;					\</span>
<span class="cp">		rh = rl = 0;						\</span>
<span class="cp">		for (i = 0; i &lt; nw; i += 8) {				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+1]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+2)+(kp)[i+2],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+3)+(kp)[i+3]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+4)+(kp)[i+4],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+5)+(kp)[i+5]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+6)+(kp)[i+6],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+7)+(kp)[i+7]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define nh_vmac_nhbytes_2(mp, kp, nw, rh, rl, rh1, rl1)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		int i; u64 th, tl;					\</span>
<span class="cp">		rh1 = rl1 = rh = rl = 0;				\</span>
<span class="cp">		for (i = 0; i &lt; nw; i += 8) {				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+1]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i)+(kp)[i+2],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+1)+(kp)[i+3]);	\</span>
<span class="cp">			ADD128(rh1, rl1, th, tl);			\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+2)+(kp)[i+2],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+3)+(kp)[i+3]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+2)+(kp)[i+4],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+3)+(kp)[i+5]);	\</span>
<span class="cp">			ADD128(rh1, rl1, th, tl);			\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+4)+(kp)[i+4],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+5)+(kp)[i+5]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+4)+(kp)[i+6],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+5)+(kp)[i+7]);	\</span>
<span class="cp">			ADD128(rh1, rl1, th, tl);			\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+6)+(kp)[i+6],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+7)+(kp)[i+7]);	\</span>
<span class="cp">			ADD128(rh, rl, th, tl);				\</span>
<span class="cp">			MUL64(th, tl, pe64_to_cpup((mp)+i+6)+(kp)[i+8],	\</span>
<span class="cp">				pe64_to_cpup((mp)+i+7)+(kp)[i+9]);	\</span>
<span class="cp">			ADD128(rh1, rl1, th, tl);			\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define poly_step(ah, al, kh, kl, mh, ml)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		u64 t1h, t1l, t2h, t2l, t3h, t3l, z = 0;		\</span>
<span class="cp">		</span><span class="cm">/* compute ab*cd, put bd into result registers */</span><span class="cp">	\</span>
<span class="cp">		PMUL64(t3h, t3l, al, kh);				\</span>
<span class="cp">		PMUL64(t2h, t2l, ah, kl);				\</span>
<span class="cp">		PMUL64(t1h, t1l, ah, 2*kh);				\</span>
<span class="cp">		PMUL64(ah, al, al, kl);					\</span>
<span class="cp">		</span><span class="cm">/* add 2 * ac to result */</span><span class="cp">				\</span>
<span class="cp">		ADD128(ah, al, t1h, t1l);				\</span>
<span class="cp">		</span><span class="cm">/* add together ad + bc */</span><span class="cp">				\</span>
<span class="cp">		ADD128(t2h, t2l, t3h, t3l);				\</span>
<span class="cp">		</span><span class="cm">/* now (ah,al), (t2l,2*t2h) need summing */</span><span class="cp">		\</span>
<span class="cp">		</span><span class="cm">/* first add the high registers, carrying into t2h */</span><span class="cp">	\</span>
<span class="cp">		ADD128(t2h, ah, z, t2l);				\</span>
<span class="cp">		</span><span class="cm">/* double t2h and add top bit of ah */</span><span class="cp">			\</span>
<span class="cp">		t2h = 2 * t2h + (ah &gt;&gt; 63);				\</span>
<span class="cp">		ah &amp;= m63;						\</span>
<span class="cp">		</span><span class="cm">/* now add the low registers */</span><span class="cp">				\</span>
<span class="cp">		ADD128(ah, al, mh, ml);					\</span>
<span class="cp">		ADD128(ah, al, z, t2h);					\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#else </span><span class="cm">/* ! CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#ifndef nh_16</span>
<span class="cp">#define nh_16(mp, kp, nw, rh, rl)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		u64 t1, t2, m1, m2, t;					\</span>
<span class="cp">		int i;							\</span>
<span class="cp">		rh = rl = t = 0;					\</span>
<span class="cp">		for (i = 0; i &lt; nw; i += 2)  {				\</span>
<span class="cp">			t1 = pe64_to_cpup(mp+i) + kp[i];		\</span>
<span class="cp">			t2 = pe64_to_cpup(mp+i+1) + kp[i+1];		\</span>
<span class="cp">			m2 = MUL32(t1 &gt;&gt; 32, t2);			\</span>
<span class="cp">			m1 = MUL32(t1, t2 &gt;&gt; 32);			\</span>
<span class="cp">			ADD128(rh, rl, MUL32(t1 &gt;&gt; 32, t2 &gt;&gt; 32),	\</span>
<span class="cp">				MUL32(t1, t2));				\</span>
<span class="cp">			rh += (u64)(u32)(m1 &gt;&gt; 32)			\</span>
<span class="cp">				+ (u32)(m2 &gt;&gt; 32);			\</span>
<span class="cp">			t += (u64)(u32)m1 + (u32)m2;			\</span>
<span class="cp">		}							\</span>
<span class="cp">		ADD128(rh, rl, (t &gt;&gt; 32), (t &lt;&lt; 32));			\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">poly_step_func</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">ahi</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">alo</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">kh</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">kl</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">mh</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ml</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define a0 (*(((u32 *)alo)+INDEX_LOW))</span>
<span class="cp">#define a1 (*(((u32 *)alo)+INDEX_HIGH))</span>
<span class="cp">#define a2 (*(((u32 *)ahi)+INDEX_LOW))</span>
<span class="cp">#define a3 (*(((u32 *)ahi)+INDEX_HIGH))</span>
<span class="cp">#define k0 (*(((u32 *)kl)+INDEX_LOW))</span>
<span class="cp">#define k1 (*(((u32 *)kl)+INDEX_HIGH))</span>
<span class="cp">#define k2 (*(((u32 *)kh)+INDEX_LOW))</span>
<span class="cp">#define k3 (*(((u32 *)kh)+INDEX_HIGH))</span>

	<span class="n">u64</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">t2</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">k3</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">mh</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">k1</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">k3</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">k1</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">31</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ml</span><span class="p">)[</span><span class="n">INDEX_LOW</span><span class="p">]);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span>  <span class="n">MUL32</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">k3</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">k1</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">+=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ml</span><span class="p">)[</span><span class="n">INDEX_HIGH</span><span class="p">]);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">k1</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span>  <span class="n">MUL32</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">k3</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">+=</span> <span class="n">MUL32</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">+=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">q</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">alo</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">ahi</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">t</span><span class="p">;</span>

<span class="cp">#undef a0</span>
<span class="cp">#undef a1</span>
<span class="cp">#undef a2</span>
<span class="cp">#undef a3</span>
<span class="cp">#undef k0</span>
<span class="cp">#undef k1</span>
<span class="cp">#undef k2</span>
<span class="cp">#undef k3</span>
<span class="p">}</span>

<span class="cp">#define poly_step(ah, al, kh, kl, mh, ml)				\</span>
<span class="cp">	poly_step_func(&amp;(ah), &amp;(al), &amp;(kh), &amp;(kl), &amp;(mh), &amp;(ml))</span>

<span class="cp">#endif  </span><span class="cm">/* end of specialized NH and poly definitions */</span><span class="cp"></span>

<span class="cm">/* At least nh_16 is defined. Defined others as needed here */</span>
<span class="cp">#ifndef nh_16_2</span>
<span class="cp">#define nh_16_2(mp, kp, nw, rh, rl, rh2, rl2)				\</span>
<span class="cp">	do { 								\</span>
<span class="cp">		nh_16(mp, kp, nw, rh, rl);				\</span>
<span class="cp">		nh_16(mp, ((kp)+2), nw, rh2, rl2);			\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef nh_vmac_nhbytes</span>
<span class="cp">#define nh_vmac_nhbytes(mp, kp, nw, rh, rl)				\</span>
<span class="cp">	nh_16(mp, kp, nw, rh, rl)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef nh_vmac_nhbytes_2</span>
<span class="cp">#define nh_vmac_nhbytes_2(mp, kp, nw, rh, rl, rh2, rl2)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		nh_vmac_nhbytes(mp, kp, nw, rh, rl);			\</span>
<span class="cp">		nh_vmac_nhbytes(mp, ((kp)+2), nw, rh2, rl2);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhash_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmac_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_block_processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">l3hash</span><span class="p">(</span><span class="n">u64</span> <span class="n">p1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">p2</span><span class="p">,</span> <span class="n">u64</span> <span class="n">k1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">k2</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* fully reduce (p1,p2)+(len,0) mod p127 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">;</span>
	<span class="n">p1</span> <span class="o">&amp;=</span> <span class="n">m63</span><span class="p">;</span>
	<span class="n">ADD128</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="cm">/* At this point, (p1,p2) is at most 2^127+(len&lt;&lt;64) */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">m63</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">p1</span> <span class="o">==</span> <span class="n">m63</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="n">m64</span><span class="p">));</span>
	<span class="n">ADD128</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">p1</span> <span class="o">&amp;=</span> <span class="n">m63</span><span class="p">;</span>

	<span class="cm">/* compute (p1,p2)/(2^64-2^32) and (p1,p2)%(2^64-2^32) */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mh">0xfffffffeu</span><span class="p">;</span>
	<span class="n">p1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">p2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="cm">/* compute (p1+k1)%p64 and (p2+k2)%p64 */</span>
	<span class="n">p1</span> <span class="o">+=</span> <span class="n">k1</span><span class="p">;</span>
	<span class="n">p1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="n">k1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">257</span><span class="p">;</span>
	<span class="n">p2</span> <span class="o">+=</span> <span class="n">k2</span><span class="p">;</span>
	<span class="n">p2</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">257</span><span class="p">;</span>

	<span class="cm">/* compute (p1+k1)*(p2+k2)%p64 */</span>
	<span class="n">MUL64</span><span class="p">(</span><span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">rh</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">;</span>
	<span class="n">ADD128</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">rh</span><span class="p">);</span>
	<span class="n">rh</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ADD128</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">rh</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rl</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">rl</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">rl</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">257</span><span class="p">;</span>
	<span class="n">rl</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">rl</span> <span class="o">&gt;</span> <span class="n">p64</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">257</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vhash_update</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mbytes</span><span class="p">,</span> <span class="cm">/* Pos multiple of VMAC_NHBYTES */</span>
			<span class="k">struct</span> <span class="n">vmac_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="o">*</span><span class="n">mptr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">kptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nhkey</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pkh</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">pkl</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">mptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">mbytes</span> <span class="o">/</span> <span class="n">VMAC_NHBYTES</span><span class="p">;</span>  <span class="cm">/* Must be non-zero */</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cl</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_block_processed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_block_processed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nh_vmac_nhbytes</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">rh</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">ADD128</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">mptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nh_vmac_nhbytes</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">rh</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">poly_step</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">pkl</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">mptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vhash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">m</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mbytes</span><span class="p">,</span>
			<span class="n">u64</span> <span class="o">*</span><span class="n">tagl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmac_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="o">*</span><span class="n">mptr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">kptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nhkey</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pkh</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">pkl</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polykey</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">mptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">mbytes</span> <span class="o">/</span> <span class="n">VMAC_NHBYTES</span><span class="p">;</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">mbytes</span> <span class="o">%</span> <span class="n">VMAC_NHBYTES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_block_processed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">polytmp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nh_vmac_nhbytes</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">ch</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">ADD128</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">pkl</span><span class="p">);</span>
		<span class="n">mptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nh_16</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">remaining</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span> <span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">ch</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">ADD128</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">pkl</span><span class="p">);</span>
		<span class="n">mptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">do_l3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="cm">/* Empty String */</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">pkh</span><span class="p">;</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">pkl</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_l3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nh_vmac_nhbytes</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">rh</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">poly_step</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">pkl</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">mptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">VMAC_NHBYTES</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nh_16</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">kptr</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">remaining</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
		<span class="n">rh</span> <span class="o">&amp;=</span> <span class="n">m62</span><span class="p">;</span>
		<span class="n">poly_step</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">pkl</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">do_l3:</span>
	<span class="n">vhash_abort</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">remaining</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">l3hash</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l3key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l3key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">remaining</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vmac</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">m</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mbytes</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">n</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">u64</span> <span class="o">*</span><span class="n">tagl</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">in_n</span><span class="p">,</span> <span class="o">*</span><span class="n">out_p</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">in_n</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">cached_nonce</span><span class="p">;</span>
	<span class="n">out_p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">cached_aes</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">n</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="n">in_n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">in_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">in_n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">in_n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">n</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in_n</span><span class="p">)[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xFE</span><span class="p">;</span>
		<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">out_p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in_n</span><span class="p">);</span>

		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in_n</span><span class="p">)[</span><span class="mi">15</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out_p</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">vhash</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mbytes</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_set_key</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_key</span><span class="p">[],</span> <span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">in</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_cipher_setkey</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span> <span class="n">user_key</span><span class="p">,</span> <span class="n">VMAC_KEY_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Fill nh key */</span>
	<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">nhkey</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">nhkey</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">nhkey</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill poly key */</span>
	<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC0</span><span class="p">;</span>
	<span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">polykey</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">polytmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">polykey</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mpoly</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">polytmp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">polykey</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mpoly</span><span class="p">;</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill ip key */</span>
	<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xE0</span><span class="p">;</span>
	<span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">l3key</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">l3key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">l3key</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">be64_to_cpup</span><span class="p">(</span><span class="n">out</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">)[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">l3key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">p64</span>
			<span class="o">||</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">l3key</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">p64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Invalidate nonce/aes cache and reset other elements */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">cached_nonce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Ensure illegal nonce */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">cached_nonce</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Ensure illegal nonce */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">.</span><span class="n">first_block_processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_setkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crypto_shash_ctx</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keylen</span> <span class="o">!=</span> <span class="n">VMAC_KEY_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crypto_shash_set_flags</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">CRYPTO_TFM_RES_BAD_KEY_LEN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vmac_set_key</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_desc</span> <span class="o">*</span><span class="n">pdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_desc</span> <span class="o">*</span><span class="n">pdesc</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">pdesc</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crypto_shash_ctx</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">vhash_update</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_desc</span> <span class="o">*</span><span class="n">pdesc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">pdesc</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crypto_shash_ctx</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">vmac_t</span> <span class="n">mac</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nonce</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

	<span class="n">mac</span> <span class="o">=</span> <span class="n">vmac</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vmac_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vmac_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">__vmac_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmac_ctx</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_init_tfm</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">cipher</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_instance</span> <span class="o">*</span><span class="n">inst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tfm</span><span class="o">-&gt;</span><span class="n">__crt_alg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_spawn</span> <span class="o">*</span><span class="n">spawn</span> <span class="o">=</span> <span class="n">crypto_instance_ctx</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crypto_tfm_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">cipher</span> <span class="o">=</span> <span class="n">crypto_spawn_cipher</span><span class="p">(</span><span class="n">spawn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cipher</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cipher</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">cipher</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmac_exit_tfm</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmac_ctx_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crypto_tfm_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">crypto_free_cipher</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmac_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_template</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shash_instance</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_check_attr_type</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">CRYPTO_ALG_TYPE_SHASH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">alg</span> <span class="o">=</span> <span class="n">crypto_get_attr_alg</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">CRYPTO_ALG_TYPE_CIPHER</span><span class="p">,</span>
			<span class="n">CRYPTO_ALG_TYPE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">alg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">alg</span><span class="p">);</span>

	<span class="n">inst</span> <span class="o">=</span> <span class="n">shash_alloc_instance</span><span class="p">(</span><span class="s">&quot;vmac&quot;</span><span class="p">,</span> <span class="n">alg</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_alg</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_init_spawn</span><span class="p">(</span><span class="n">shash_instance_ctx</span><span class="p">(</span><span class="n">inst</span><span class="p">),</span> <span class="n">alg</span><span class="p">,</span>
			<span class="n">shash_crypto_instance</span><span class="p">(</span><span class="n">inst</span><span class="p">),</span>
			<span class="n">CRYPTO_ALG_TYPE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_inst</span><span class="p">;</span>

	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_priority</span> <span class="o">=</span> <span class="n">alg</span><span class="o">-&gt;</span><span class="n">cra_priority</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_blocksize</span> <span class="o">=</span> <span class="n">alg</span><span class="o">-&gt;</span><span class="n">cra_blocksize</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_alignmask</span> <span class="o">=</span> <span class="n">alg</span><span class="o">-&gt;</span><span class="n">cra_alignmask</span><span class="p">;</span>

	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">digestsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vmac_t</span><span class="p">);</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_ctxsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmac_ctx_t</span><span class="p">);</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_init</span> <span class="o">=</span> <span class="n">vmac_init_tfm</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">cra_exit</span> <span class="o">=</span> <span class="n">vmac_exit_tfm</span><span class="p">;</span>

	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">vmac_init</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">update</span> <span class="o">=</span> <span class="n">vmac_update</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">vmac_final</span><span class="p">;</span>
	<span class="n">inst</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">.</span><span class="n">setkey</span> <span class="o">=</span> <span class="n">vmac_setkey</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">shash_register_instance</span><span class="p">(</span><span class="n">tmpl</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out_free_inst:</span>
		<span class="n">shash_free_instance</span><span class="p">(</span><span class="n">shash_crypto_instance</span><span class="p">(</span><span class="n">inst</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">out_put_alg:</span>
	<span class="n">crypto_mod_put</span><span class="p">(</span><span class="n">alg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypto_template</span> <span class="n">vmac_tmpl</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;vmac&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">vmac_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">shash_free_instance</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vmac_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">crypto_register_template</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmac_tmpl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vmac_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">crypto_unregister_template</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmac_tmpl</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">vmac_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">vmac_module_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;VMAC hash algorithm&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
